---
title: "Newton-Raphson from scratch"
author: "The WANT team"
date: "27/11/2018"
output:
  html_document:
    css: want.css
---
<!-- include the hint.js -->
<script src="hints.js"></script>

# Learning goal
* Understand the underlying principle of the FV/FD packages

# Introduction
For the assignments of this week, we have the FV/FD packages available that will take care of the numerics that are involved with solving differential equations using Finite Volumes and Finite Elements. A main principle used in the packages to solve the numerics is that non-linear systems (generally the ones that we are interested in) can be approximated with linear systems, iteratively evaluating the difference between the linear and non-linear system. This approach is called 'Newton-Raphson' and frequently used in numerical mathematics. In this short assignment, you will build a Newton-Raphson solver from scratch. 

# Question 1
In the Finite Volume technique, given a certain state or in/outflux of a control volume, neighbouring volumes have to update their state to conserve the balance of the overall system. So basically, we search for the zero-point of the system (no change in overall balance). 

<div class="question">
We have a linear system described by $f(x)=ax+b$, for which $x$ does the system $f$ equal zero? 
</div>

<span class="student_answer">
Fill in your answer...
</span>

<span class="answer">
For linear systems, we can answer this question directly. The system is described by $f(x) = ax+b$, we search for the point $f(\hat{x}) = 0$, so $\hat{x}=\frac{-b}{a}$. For linear systems, we only need one step to find the zero-point. 
</span>


# Question 2
Generally, the systems that we encounter in Earth sciences behave non-linear, and therefore we can not directly find the solution where the system equals zero. This requires iteration; the states of the control volumes have to be identified iteratively. What Newton-Raphson does, is linearize the non-linear function, obtain the zero-point, and compare this zero-point with the non-linear equation. Let's go through it step-by-step. 

<span class="question"> 
1. Implement y(x)=x^2-10 using a function <br>
<!-- HINT 1 -->
<button type="button" onclick="showHint(1)">Hint 1</button>
<p id="Q1"> </p>
</span>

<span class="question"> 
2. Linearize y by taking a local derivative, e.g. around x=7, and implement using a function <br>
<!-- HINT 2 -->
<button type="button" onclick="showHint(2)">Hint 2</button>
<p id="Q2"> </p>
</span>

<span class="question"> 
3. Plot y(x)=x^2-10 for x = 0:10 <br>
</span>

<span class="question"> 
4. Add the linearized function to your plot. <br>
</span>

<span class="question"> 
5. Calculate the x for which the linearized function equals zero. <br>
</span>

<span class="question"> 
6. Insert the obtained x from 5 into the non-linear function, does that indeed give zero? <br>
</span>

```{r}
# Type your code here.
```

<span class="answer">

```{r}
# x-domain
x = seq(0:10)

# non-linear function
y <- function(x){x^2-10}

# linearized function 
estimate = 7
epsilon  = 0.1
f <- function(x){y(estimate)+ ((y(estimate+epsilon)-y(estimate))/epsilon)*(x-estimate)}

# plot 
plot(x,y(x),col="blue",type="l",lwd=2)
lines(x,f(x),col="red")
abline(a=x,b=0,lty="dotted")

# find where x is zero for the linearized function
b = f(0)
a = (y(estimate+epsilon)-y(estimate))/epsilon
x_0 = -b/a
f(x_0) # indeed leads to zero!

# check if this also leads to zero in the non-linear function
y(x_0) # this is certainly not equal to zero! 

```
</span>

# Question 3
In the previous question, we only took one step; we linearized the non-linear function and searched for the 0-point in the linearized function. Subsequently, we compared if the 0-point of the linearized function was close to the 0-point of the non-linear function, by filling out the linearized 0-point in the non-linearized function. The Newton-Raphson algorithm will do this in the same way, but will repeat the procedure when the result of the non-linear function is too far off zero, based on a stopping-criterion. The algorithm will the the 0-point of the linearized function as estimate for the next linearization of the non-linear function. 

<span class="question"> 
Implement a Newton-Raphson algorithm for the equation given in the previous question, using a while-loop. The stopping criterion is 0.05, that means that the iteration may stop as soon as the non-linear function reaches a result of 0.05 (or lower). Plot the steps in the while-loop to see the process. Later, you can of course adapt the non-linear equation and the stopping-algorithm.
</span>

```{r}
# Type your code here.
```

<span class="answer">
```{r}
# Define your non-linear function (can be anything, uncomment the one you want to use)
#y <- function(x){sin(x)+2*x^2}
y <- function(x){x^2-10}
#y <- function(x){4*sin(x)+0.5*cos(x^2)} # what does it do here? 

# Define your linear function
f <- function(x){y(estimate)+ ((y(estimate+epsilon)-y(estimate))/epsilon)*(x-estimate)}

# Plot your non-linear function
x = seq(0:10)
plot(x,y(x),col="blue",type="l",lwd=2)
abline(a=x,b=0,lty="dotted")

# Define a start-estimate, the epsilon for the linearization, 
# and a begin-value of the output to initiate the while-loop,
# define the stopping criterion
estimate = 7
epsilon  = 0.1 
output   = 10
stopcrit = 0.05

while (output>stopcrit)
{
 # calculate the zero-point for the linear function
 b = f(0)
 a = (y(estimate+epsilon)-y(estimate))/epsilon
 x_0 = -b/a
 # plot this linear function
 lines(x,f(x),col="red",lty="dashed")
 # check what the output is for the non-linear function
 output = abs(y(x_0))
 # set the zero-point of the linear function as new estimate
 estimate = x_0
 print(c(x_0,output))
}

# Of course, you can also turn this into a function completely. 
```
</span>

