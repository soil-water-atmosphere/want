---
title: "FVFE Practical 1 - Stationary Flow in 1D"
output:
  html_notebook:
    css: want_n.css
    toc: yes
  bookdown::html_document2:
    css: want_n.css
    toc: yes
  html_document:
    css: want_n.css
    toc: yes
date: "March 2019"
subtitle: Groundwater flow near rivers and heat transfer in the near-surface atmosphere
---

```{r, echo=FALSE}
rm(list = ls())

#Check to see if package(s) are installed, install if not and then load

#pkgs is a vector of strings with length >= 1

CheckInstallPackages <- function(pkgs){

#For each pkg in pkgs (attempt to load each package one at a time):

 x <- lapply(pkgs, function(pkg){

  #Load the package if available,

  if(!do.call("require", list(pkg))) {

   #Silently attempt to install into the default library

   try(install.packages(pkg, lib=.Library,repos="http://cran.rstudio.com"))

   #Now attempt to load the package, catch error if it wasn't installed

   tryCatch(do.call("library", list(pkg)),

    #Catch if we're unable to install into the default library

    error = function(err) {

     #If non-interactive, install into this user's personal library

     if(!interactive()) {

      #Get the path to this user's personal library

      personalLibPath <- Sys.getenv("R_LIBS_USER")

      #If the personal library is not in the list of libraries

      if(is.na(match(personalLibPath, .libPaths()))) {

       #Then create the personal library

       dir.create(personalLibPath, recursive = TRUE)

       #And add the personal library to the list of libraries

       .libPaths(personalLibPath)

      }

      #Attempt to install the package into the personal library

      #If this fails, raise the error back to the report

      install.packages(pkg, lib=personalLibPath, repos="http://cran.rstudio.com")

      #Finally, attempt to load the package

      do.call("library", list(pkg))

 }})}})

} 
CheckInstallPackages(c("bookdown","knitr","FVFE1D"))

# No further action needed if the code block runs without complaints.
```

<button class="collapsible">Info on this document</button>
<div class="content">
This document is a R-markdown document. It contains:  

1.  explanatory text in chapters and sections 
2.  code chunks
3.  questions and assignments
4.  answers and worked-out assignments  

The different chapters and sections cover different aspects of the material in this document. In the code chunks a specific piece of code can be run.  
Questions and assignments are colored red and the answers and worked out assigments are in blue. The 'answer' version will be available on Brightspace when suitable.  

This document is meant to be self-contained, meaning that all aspects required to work with it, are included.  

Simply load this `*.Rmd` document into R-studio and "knit" or "preview" this document and have a look at the created html (in the previewer of R-studio or in a browser). With "knit" the document will run all chunks and create an html document with the output of the chunks and the text in the markdown. With "preview" the document will be created based on the text in the Rmd and the chunk which have already run. While working on the R-chunks, one can run the individual chunks seperately in order to see the results. However, in preview mode some cross-referencing and numbering could not work correctly. Knitting the whole document (with knit option: "Knit to html_document2" should return proper cross-referencing and numbering.

Answers to the questions can be typed directly into this document. The assignments, most of the time finishing code chunks, also need to be worked out in this document. With this you will have a completed set of _your_ answers and _your_ worked out assignments in this document. At the end of the time slot of this assignment a completely filled out document (including answers and worked out assignments) will be available on Brightspace.  

First of all, make sure you have the package FVFE1D installed (available on Brightspace > Week 2: FV/FE > Assignment packages). You can find the Help-pages of this package in the bottom right part of your screen, under Packages > FVFE1D. If you click on FVFE1D here, all functions in the package are displayed. When you click on one of the functions, it shows a description of what the function does, and the required input. Consult the Help-pages if you want to know if a certain function exists, and what the required inputs are.
</div>

## Learning goals
*  Learning the steps to set up a numerical model (stationary, spatial 1D) (sections [Mathematical model setup], [Solving and checking convergence] _exercise 3-11,3_ and section [Model setup] _exercise 3,4_ ).
*	 Understanding the concepts of internal and external fluxes; applying different forms of these fluxes (sections [Internal flux], [Mathematical model setup] _exercise 1,2,8_ and section[**Extra Assignment**: Including a radiative cooling sink] _exercise 10_ )
*  Understanding the difference between linear and nonlinear internal flow functions (section [Type 2 internal flow] _exercise 22,23_)*
*  Evaluating the model results by checking convergence, analytical solutions and water/heat balances (sections [Solving and checking convergence], [Comparing with the analytical solution], [Examining the water balance] _exercise 11, 12, 14, 15_ and sections [Testing different resolutions], [**Extra assignment**: Surface flux as a Cauchy/Robin boundary] _exercise 5,14_)
*  Working with spatially varying parameters (section [A non-uniform kD field] _exercise 20,21_)
* Test the effect of spatial resolution on model results (section [Testing different resolutions], [Stratification-dependent diffusivity] _exercise 5,6_)
* Applying different kinds of boundary conditions (section [Adding a Cauchy Boundary Condition] _exercise 18,19_ and section [**Extra Assignment**: Surface flux as a Cauchy/Robin boundary] _exercise 13_)

# Part I: Groundwater flow towards rivers

## Introduction 
The first part of this assignment will deal with a hydrological problem: saturated groundwater flow. In the second part the same ideas will be applied to a meteorological case.

In this first part, a model will be developed to simulate saturated groundwater flow towards two rivers, left and  right, in a one dimensional domain as shown in the graph below. The flow is stationary.  


```{r 1D2rivers, fig.cap="Saturated 1D groundwater flow towards rivers", echo=FALSE}

include_graphics("assignment1_1D_2rivers.png")
```

   
***   

The total length of the model-domain is 200 m and both rivers form prescribed head (*Dirichlet*) boundary conditions with a level of 5 m A.M.S.L. (Above Mean Sea Level). The model is discretized with a nodal distance of 10 m.  
The net rainfall (recharge) on top of the model is the only external flux and is $0.001 [\mathsf{m/d}]$.  
The transmissivity $kD$ of the aquifer (hydraulic conductivity * thickness) is $45 [\mathsf{m^2/d}]$ .  
The model will calculate the hydraulic head.

<button class="collapsible">Background info</button>
<div class="content">

_internal flux_:  

In this zone, groundwater flow is predominantly horizontal and can flow for several hundreds of meters or even in the order of kilometers. The velocity of groundwater is low; in the order of a centimeter up to a meter per day or so.  
The energy used to get groundwater flowing comes from potential energy which is contained in the difference of (piezometer) heads (=water level as if one would install a tube at that position) over a certain distance.  
This "Darcy" flux is : 
\begin{equation}
q_{Darcy}=-k \frac{\partial H}{\partial s}
(\#eq:darcy-eq)
\end{equation}

With:  

* k:  hydraulic conductivity [$\mathsf{m/d}$]  
* H:  (piezometer) head [$\mathsf{m}$]  
* s:  spatial dimension, x, y or z [$\mathsf{m}$]  

The saturated part of groundwater begins at the groundwater table and stops, in principle at bedrock. For Dutch circumstances flow is mainly restricted to the coarser deposits in the subsoil such as gravel, coarser and finer sands. In clayey deposits (certainly the heavy ones) flow is limited and mostly vertical. The coarser deposits build up the water bearing layers which are called aquifers. In stratified sub soils, like in the Netherlands,  aquifers can be confined by (thick) clayey deposits building up an aquitard.  Thick clayey deposits could also be used as a lower boundary.  
The permeability of the deposits is defined by the hydraulic conductivity $k$ with unit [$\mathsf{m/d}$].  The product of the conductivity and the (average) saturated thickness $D$ of an aquifer over which the flow occurs, is called **Transmissivity** $kD$ or $T$ with unit [$\mathsf{m^2/d}$].  This extends the basic Darcy equation to:  

\begin{equation}
q_{Darcy}=-kD \frac{\partial H}{\partial s}
(\#eq:Dupuit-eq)
\end{equation}
With:  

* D:  Saturated thickness over which the flow occurs [$\mathsf{m}$]  


_external flux_:  
The external flux applied to this model comes from the top and origins from precipitation. A reasonable value for this in this region is 1 $\mathsf{mm/d}$

_boundary conditions_:  

*  Dirichlet boundary condition (BC) which prescribes the head (state) and could be imagined as the water level of a river, lake or sea(not including density effects).  
*  Neumann BC which prescribes the gradient of the head normal to that boundary. It could be used when e.g. a flow-line or  water divide would be assumed.  
*  Cauchy BC which combines the above two BC's. It could be used to simulate the effect of e.g. a canal which does not fully penetrate the aquifer and contains a certain resistance against flow due to the canal-bed (due to e.g. plant residue deposits and sedimentation) and the aquifer. The prescribed water level is the Dirichlet part, and as a result of a potential difference between canal and aquifer and the resistance, a certain flux (Neumann part) will occur. One could call this a 'top' boundary condition.  

</div>
<br> 



## Internal flux 

In this model we apply a Darcy water flux, using the Dupuit assumption - this means we assume the flow in the aquifer to be mainly horizontal and uniform with depth, allowing us to make volume flow simply proportional to the thickness over which it occurs.   
We may distinguish two types of internal Darcy fluxes:  

* the _linear_ Darcy flux. Here we assume that the thickness of the aquifer is much larger compared to the differences in groundwater levels within the domain. Therefore, we make a simplification: we take the thickness over which flow occurs as a constant, the aquifer thickness $D$ in m (type 1 internal flux).  
* the _non-linear_ Darcy flux, in which we recognise that the thickness over which flow occurs is smaller when the groundwater level is lower. Here we make the thickness of the aquifer through which flow occurs dependent on the calculated groundwater head (the state) at the nodes (type 2 internal flux).

<div class="exercise">
1. Give the formula for both equations.
</div>

<div class="student_answer">
Fill in your answer...
</div>

<div class="answer">
* type 1 internal flux is given by: 

$$\vec{q} = - k\;D\; \frac{\partial H}{\partial x}$$

* type 2 internal flux is given by: 

$$\vec{q} = - k\;H\; \frac{\partial H}{\partial x}$$
</div>

<div class="exercise">
2. What are the units of this model?
</div>

<div class="student_answer">
scales and units:

* space : 
* time  : 
* state :  
* internal flux:  
* external flux:  
</div>

<div class="answer">
scales and units:

* space: m (meters)
* time: d (day)
* state: m (meters)
* internal flux: m$^2$/d
* external flux: m/d

Note that the external flux, the net rainfall, is given to the model as a flux density in m/d. In the calculations, the model will multiply this flux density with the width of the control volume, to get the amount of incoming water in m$^2$/d, the same unit as the internal flux. Then, the water balance for that volume can be solved with the correct units. 

The unit of the internal flux is already given to the model in m$^2$/d, because we use the transmissivity kD, which already includes the depth (D) over which the internal flow occurs.
</div>

## Mathematical model setup
When setting up your model, you can make use of the model template `ModelTemplate1D.Rmd`, which is included in the folder of this assignment. This document explains all the steps needed in setting up a 1D flow model. The Help-pages of the FVFE1D package may also be helpful.

<div class="exercise"> 
3. Clean the workspace and load the package 
</div> 

```{r}
rm(list=ls()) 
library(FVFE1D)
```

<div class="exercise"> 
4. Define the model domain  
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
domain = c(0,200) 
```
</div>

<div class="exercise"> 
5. The internal flux function 
</div>  
Create the internal flux function here. Use the linear (type 1) Darcy flux function.

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
kD=45 # transmissivity, m2/d
type1.flux = function(x,state,gradstate)  
{
  return(-kD*gradstate) #minus to account for the flow direction
}
```
</div>

<div class="exercise"> 
6. The first model  
</div>
Make your first groundwater model here.

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
Hydro_1Dmodel_type1 = newFLOW1D(domain=domain,systemfluxfunction = type1.flux) 
```
</div>

<div class="exercise"> 
7. The boundary conditions 
</div>  
Define the required boundary conditions here. These are the prescribed heads (water levels) of both rivers.

<div class="hint">
<button type="button" onclick="showHint(1001)">Show Hint</button>
<p id="Q1001"> </p>
</div>

<div class="student_answer">
```{r}
## insert your code here
```
</div>

<div class="answer">
```{r}
BCleft=5 #m
BCright=5 #m
set.BC.fixedstate(Hydro_1Dmodel_type1,'left',BCleft) 
set.BC.fixedstate(Hydro_1Dmodel_type1,'right',BCright)
```
</div>

<div class="exercise"> 
8. Adding recharge (net rainfall, or rainfall minus evapotranspiration)
</div>    
Create a __spatial flux__ here. 

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
recharge=0.001 #1mm/day --> all length units are in meters
add.spatialflux(Hydro_1Dmodel_type1,recharge,"recharge")  
```
</div>

<div class="exercise"> 
9. Giving the model a name  
</div>     
You can give the model a specific name. This name will appear when you plot the model. It is not required though.

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
set.name(Hydro_1Dmodel_type1,'Hydro type-1 1D groundwater model ')
```
</div>

## Numerical model setup
In the section above, you defined the mathematical or conceptual model setup. This relates to your understanding of the system: the domain that is relevant for the system you study, a mathematical formulation of the fluxes that occur, and defining the boundary conditions. Now, the numerical setup needs to be formulated.

<div class="exercise"> 
10. Make the model discrete  
</div>
Use the spatial delta x (nodal distance) here to define the (number of) nodes.  
Make the model discrete using these nodes and set the type of numerical approximation.  
<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
dx = 10 # nodal distance as described at the beginning of this assignment
nodes = seq(from=domain[1],to=domain[2],by=dx)
set.discretisation(Hydro_1Dmodel_type1,nodes,method='FV') 
```
</div>

## Solving and checking convergence

<div class="exercise">
11. Solve the model in the following chunk.
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
solve.steps(Hydro_1Dmodel_type1,verboselevel=1)
```
</div>

The low values of RMSM and MAM show that the solution has converged.

<div class="exercise">
12. What do the RMSM and MAM signify? Look at the FVFE1D package documentation.
</div>

<div class="student_answer">
Fill in your answer...
</div>

<div class="answer">
12. The RMSM and MAM are measures of the misfit of the model. The misfit of each node shows how much its mass balance currently differs from zero. RMSM=root mean squared misfit; MAM=maximum absolute misfit. When these are low, the model has converged.
</div>

<div class="exercise">
13. Plot the solution here. Tip: if you add the argument `FVstyle=T`, the 'real' Finite Volume results will be plotted: one state per calculation volume. Otherwise, the plot interpolates between the obtained states for each node.
</div>

<div class="student_answer">
```{r}
##insert your code here
#plot()
```
</div>

<div class="answer">
```{r}
plot(Hydro_1Dmodel_type1,stateplot=TRUE,fluxplot=TRUE, FVstyle=T)
```
</div>

## Comparing with the analytical solution 
It is interesting to see how well the numerical solution compares to the analytical solution.  Analytical solutions generally only exist in homogeneous and uniform conditions, which is the case in this situation. If the aquifer transmissivity would not be a constant, an analytical solution would be much harder to find.  The analytical solution is given by:

$$
 H_{analytic}=H_{river}+\frac {R}{2kD}x(L-x)
$$
This formula is based on one of the solutions for the calculation of drain spacings of Hooghoudt (a Dutch hydrologist, 1901 - 1953). Here $H_{river}$ is the river or ditch level, $R$ is the recharge (net rainfall), $x$ is the location in space and $L$ is the distance between two rivers. 

<div class="exercise"> 
14. Plot both the analytical and the numerical solution. Also, calculate the difference (in m) between the hydraulic heads in the numerical and the analytical solution. How well does the numerical solution perform? 
</div>

<div class="hint">
<button type="button" onclick="showHint(1002)">Show Hint</button>
<p id="Q1002"> </p>
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
H_anal =  BCleft+(recharge)/(2*kD)*nodes*(200-nodes)
H_num = dataframe.states(Hydro_1Dmodel_type1)$state
plot(nodes,H_anal,type="l",col="red",xlab="x", ylab="groundwater head",main="Analytical (red) vs. numerical (black) solution")
points(nodes,H_num)
print(c('difference :',H_anal-H_num))
```
</div>

## Examining the water balance

A very important tool for a hydrologist is the water balance, to assess the flows into and out of the system.  

<div class="exercise">
15. Use the appropriate function in the FVFE1D package to print the model water balance.
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
print(dataframe.balance(Hydro_1Dmodel_type1))
```
</div>

<div class="exercise"> 
16. Do the values of the balance 'add up'?
</div>  

<div class="student_answer">
Fill in your answer here...  
</div>

<div class="answer">
16. Yes, the total recharge is $200m * 0.001m/d=0.2 m^2/d$. This is equal to the total discharge.
</div>

<div class="exercise"> 
17. Another function is added to the FVFE1D package to determine the fluxes over specific boundaries. Use this to find the fluxes to each of the two rivers. 
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
print(dataframe.boundaries(Hydro_1Dmodel_type1))
```

17. So $0.1 m^2/d$ leaves the system through the left boundary and $0.1 m^2/d$ through the right boundary.
</div>

## Adding a Cauchy Boundary Condition

In this section the basic model is going to be adjusted with the replacement of the left river with a canal which does not fully penetrate the aquifer.  

The new situation is illustrated in the following figure : \@ref(fig:1Drivercanal) .

```{r 1Drivercanal, fig.cap="The 1 dimensional groundwater model with a Cauchy BC on the right side ; a canal replacing the fully penetrating river "}
knitr::include_graphics("assignment1_1D_river_canal.png")
```

The main difference between the first situation (a river on the right hand side) in figure :\@ref(fig:1D2rivers), is the flow situation at the right hand side.  
The river was implemented as a Dirichlet boundary condition with a prescribed head of 5 m. A.M.S.L. This results in a flux at that boundary depending on the head next to that river and the level of the river itself.  When the river level is lower flow will go out of the model at that boundary otherwise it will create an inflow.  
There is one execption; when the head(state) calculated next to this river is exactly the same as the river level itself, no flow will occur at that boundary.  
When this river is replaced with a canal, a few differences can be noticed:  

*  the (entrance) resistance of 10 days of the canal-bed is added
*  flow at that boundary is now forced to flow through that canal-bed

The most obvious way to simulate such a situaton is by using a Cauchy/Robin boundary condition (BC).  
The Cauchy BC contains aspects of both the Dirichlet and Neumann BC:  

*  The prescribed head of the canal is the Dirichlet part (and is equal to the river level)
*  An extra resistance is introduced, the canal-bed (brown hashes in figure \@ref(fig:1D2rivers)), through which flow takes place

This means that the flux at this boundary depends on the calculated state next to the boundary and a certain _coefficient_ which regulates the flux_rate_ at that boundary. The coefficient in this case is the canal_resistance.  
To accomplish this an additional function need to be developed describing the relation between the prescribed state, the coefficient and the flux rate. In a formula:  

\begin{equation}
q = -k \frac{\Delta H}{\Delta z}\rightarrow q=\frac{H_{canal}-H_{aquifer}}{C}
(\#eq:cauchy-eq)
\end{equation}  


with: 
$C^{-1} : \frac{k}{\Delta z}\rightarrow C=\frac{\Delta z}{k}$  

One can see that this formula is simply Darcy's eqation again, see also: \@ref(eq:darcy-eq) in the "Background info"  

### Implementation

To implement this 'state dependent flux rate' the `set.BC.fluxstate(model, where, func)` function can be used from the FVFE1D-package. See the help of this package for details  
This function requires a `func` : a function in stead of a `value` here.  
In addition, this function requires a state of the node next to it and returns the flux-rate to the model.  

The code chunk below gives a format to implement such a state dependent flux function:

```{r}
Cauchy_BC = function(state)
{

  flux = #  type here your 'flux' function here
  return(flux)
}
```

<div class="question">
18. Finish the state dependent flux function in the example chunk above. Use the following chunk to create a copy of the base model.
Add the new BC to the new model replacing the previous Dirichlet BC on the right hand side and run this model.  Create plot(use the FVFE package and set `fluxplot=TRUE`), a water balance of the whole model and a dataframe of the boundary fluxes.


```{r}
# create a copy of the basic model with function copy.model(), see help in FVFE1D package for details

#define the new boundary condition replacing the old one.
```
</div>



<div class="answer">
18. For the Cauchy_BC one can simply implement the abovementioned equation: \@ref(eq:cauchy-eq).
Next the model is copied and this BC will override the previous Dirichlet BC on the right hand side.
```{r}
H_canal = 5 #m water level in the canal
bed_resist = 10 #d the entrance resistance of the canal bed
Cauchy_BC = function(state)
{
  flux = (H_canal - state) / bed_resist
  return(flux)
}
#create a copy of the base model and adjust the name (visible in the plots)
Hydro_1Dmodel_cauchy = copy.model(Hydro_1Dmodel_type1) 
set.name(Hydro_1Dmodel_cauchy,'Hydro type-1 with Cauchy BC')
#check if all went OK
summary(Hydro_1Dmodel_cauchy)
#add the new BC which automatically replaces the old one.
set.BC.fluxstate(model = Hydro_1Dmodel_cauchy, where = 'right',func = Cauchy_BC)
#check the model if the BC right is adjusted
summary(Hydro_1Dmodel_cauchy)
#run the model with the new BC
solve.steps(Hydro_1Dmodel_cauchy)
#have a look at the results
plot(Hydro_1Dmodel_cauchy,fluxplot=TRUE,FVstyle=TRUE  )

#some dataframes to create tables
w_bal = dataframe.balance(Hydro_1Dmodel_cauchy)

bc_flux = dataframe.boundaries(Hydro_1Dmodel_cauchy)

```

The water balance of this model is:  

```{r}
knitr::kable(head(w_bal), booktabs=TRUE, caption='water balance')
```

The outflow at the boundaries of this model:  

```{r}
knitr::kable(head(bc_flux), booktabs=TRUE, caption='boundary fluxes')
```

</div>

<div class="question">
19. Compare the results (head distribution, water balance, and boundary outflow) with the basic model and explain the differences.  
</div>  

<div class="answer">  
19:  
_head_  
The water divide is shifted towards the right indicating that more water is flowing towards the right.  
_water balance_  
Values of the water balance are identical. That is not surprising since the internal and exterenal fluxes are not altered.  
_boundary outflow_  
The specific outfluxes are clearly different. Most of the water: `r bc_flux[2,4]/w_bal[5,2]` % is flowing towards the river.  Since the canal introduces an extra resistance to flow water can be transported to the river more easily.  

</div>


## A non-uniform kD field

Up till now the transmissivity of the aquifer has been constant. Now we are going to investigate the effect of a gradually increasing transmissivity from left to right in the model.  
For this, a kD-function is created with `approxfun` in R, as shown in the chunk below. Type `help(approxfun)` at the console prompt to have some insight in the workings of this function.  

```{r}
kD.func = approxfun(c(0,200),c(15,60),rule=2)
plot(kD.func(0:200),type="o",main="Transmissivity values over the domain",xlab="x",ylab="kD")
```

<div class="exercise">
20. Create a new model which is based on the newly defined kD-values (which are a function of x). This requires the internal flux function to be redefined for this model. All other items of the model (domain, nodes, boundary conditions etc.) are identical to the previous model. For clarity you can give this model a new name.
</div>

<div class= "student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
# internal flux
kDfunc.flux = function(x,state,gradstate)  
{
  return(-kD.func(x)*gradstate)
}

# define model and domain
Hydro_1Dmodel_kDvar = newFLOW1D(domain=domain,systemfluxfunction = kDfunc.flux) 

# external flux
recharge = 0.001 #m/d
add.spatialflux(Hydro_1Dmodel_kDvar, recharge,"recharge")

# boundary conditions
BCleft=5 #m
BCright=5 #m
set.BC.fixedstate(Hydro_1Dmodel_kDvar,'left',BCleft) 
set.BC.fixedstate(Hydro_1Dmodel_kDvar,'right',BCright)

# spatial resolution
dx = 10
nodes = seq(from=domain[1],to=domain[2],by=dx)
set.discretisation(Hydro_1Dmodel_kDvar,nodes,method='FV') 

# define model name, solve model, plot results
set.name(Hydro_1Dmodel_kDvar,"1D type-1 groundwater model, varying kD")
solve.steps(Hydro_1Dmodel_kDvar,verboselevel=1)
plot(Hydro_1Dmodel_kDvar,fluxplot=TRUE,FVstyle=TRUE)
```
</div>

<div class="exercise"> 
21. Solve the model with a varying kD-value, make a plot of the fluxes and states and consider the following questions.  

*    What can you conclude about the water divide?  
*    What is the fraction of water draining to the left and the right river?  
*    Can you give arguments (without calculations) for the changes observed?  
</div>

<div class="student_answer">
Fill in your answer here...  
</div>

<div class="answer">  
21:  
*    The water divide has moved from the middle about 20m to the left.    
*    The outflow to the right river is larger than to the left river, as shown below.  
*    The water divide is shifted to the left since it is easier for water to flow to the right where transmissivities are larger.
</div>  

<div class="answer">
```{r}
db = dataframe.boundaries(Hydro_1Dmodel_kDvar)
print(paste('out left :',db[1,4],'out right :',db[2,4]))
print(paste('fraction of total to right river :',db[2,4]/sum(db[,4])))
```
</div>

## Type 2 internal flow
Until now the model was of a type 1 flow: it assumed a constant saturated thickness $D$ over which groundwater flow occurred. In reality groundwater flow is limited to the saturated thickness $H(x)$. Such a change makes the model non-linear in the state (head).  

<div class="exercise">
22. Make a model with a type 2 flow (see [Question 1: Internal flux] ) where the k-value varies linearly between 3 and 12 from left to right. As the model is non-linear, the solution of the model will take more than one step. Add a verbose argument to the `solve.steps` call (see help) to count the number of iterations needed and plot the solution.
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
k.func = approxfun(c(0,200),c(3,12),rule=2) #conductivity m/d
kHfunc.flux = function(x,state,gradstate)  
{
  return(-k.func(x)*state*gradstate)
}
Hydro_1Dmodel_type2 = newFLOW1D(domain=domain,systemfluxfunction = kHfunc.flux) 
recharge = 0.001 #m/d
add.spatialflux(Hydro_1Dmodel_type2,recharge,"recharge")
BCleft=5 #m
BCright=5 #m
set.BC.fixedstate(Hydro_1Dmodel_type2,'left',BCleft) 
set.BC.fixedstate(Hydro_1Dmodel_type2,'right',BCright)
nodes = seq(from=domain[1],to=domain[2],by=10)
set.discretisation(Hydro_1Dmodel_type2,nodes,method='FV') 
set.name(Hydro_1Dmodel_type2,"1D type-2 groundwater model")
solve.steps(Hydro_1Dmodel_type2,verbose=TRUE)
plot(Hydro_1Dmodel_type2,fluxplot=TRUE,FVstyle=TRUE)
```
</div>

As the solution technique is now iterative, a good initialization may help in finding the solution. Initialize the states to a (constant) value of 5 and count the number of iterations needed in the solve.steps procedure after this initialization.  

<div class="answer">
```{r}
do.initialize(Hydro_1Dmodel_type2,5)
solve.steps(Hydro_1Dmodel_type2,verbose=TRUE)
```
</div>

<div class="exercise">
22. The chunk below compares the results of the linear and nonlinear model. At `XLINEARMODELX` and `XNONLINEARMODELX`, fill in the name of your linear model and your nonlinear model respectively, both with varying k-values. Do you see differences?
</div>

<div class="student_answer">
```{r eval=FALSE}
plot(dataframe.states(XLINEARMODELX),col="black",main=paste("Linear (dots) vs nonlinear model (red); D =",dataframe.boundaries(XLINEARMODELX)[1,3],"m"))
lines(dataframe.states(XNONLINEARMODELX),col="red")
```
</div>

Now look at the effect of the aquifer depth $D$. Our reference level for the head is 0 m (this is the bottom of the system, bedrock or an aquitard, as displayed in Figure 1), so $D$ is simply equal to the river level at the boundaries (see Figure 1). In the current situation, $D=5$ m. The linear varying-kD model, with kD between 15 and 60, therefore has the same conductivities over the domain (from 15/5=3 m/d to 60/5=12 m/d) as the nonlinear model. Using this logic, depth $D$ can be varied by adapting the boundary conditions and kD values of the linear varying-kD model; and adapting the boundary conditions in the nonlinear model.

<div class="exercise">
23. Vary the $D$ for the two models. What effect does $D$ have on the differences between the linear and nonlinear model?
</div>

<div class="answer">
```{r }
plot(dataframe.states(Hydro_1Dmodel_kDvar),col="black",main=paste("Linear (dots) vs nonlinear model (red); D =",dataframe.boundaries(Hydro_1Dmodel_kDvar)[1,3],"m"),xlab="x",ylab="groundwater level")
lines(dataframe.states(Hydro_1Dmodel_type2),col="red")
```

23. For $D=5$ m, the linear and nonlinear method give about the same result. When you change $D$, for example to 1 m (see figure below), the linear and nonlinear models start to diverge. When $D$ is small relative to the variation in hydraulic head in the domain, the assumption that groundwater level differences are negligible in determining the flow thickness is no longer valid. A nonlinear internal flux function will then be more appropriate.

![](Answer1.8.png)
</div>

# Part II: Turbulent heat transfer in the stable atmospheric boundary layer

## Introduction
During the night, the surface of the Earth loses more energy through outgoing thermal radiation than it receives from the atmosphere, and therefore it is cooling. Air that comes in contact with the surface cools, hence the atmosphere is cooling as well. Turbulent whirls driven by the wind replace the cool air at the surface with warm air from aloft, and therefore transport relatively warmer air downwards and cold air upwards. Therefore, the entire layer that is under the influence of turbulence is cooling (see figure below). This layer is the **stable boundary layer (SBL)**.

```{r potentialH, fig.align='center', fig.cap='profile of potential temperature in the Atmospheric Boundary Layer.',echo=FALSE}
knitr::include_graphics('potentialT_height.png')
```

<button class="collapsible">Background info</button>
<div class="content">
In the atmosphere, we often quantify the temperature in terms of the potential temperature $\theta$, which is the temperature a parcel of air has if it is brought down to the surface. This is very convenient, because it therefore does not change under adiabatic expansion, for instance if one moves to greater altitudes, and it only changes if energy is added or removed from the system. In the assignment below, potential temperature $\theta$ is the state variable, expressed in units of Kelvin, K. 

_internal flux_  
The transport of energy in this problem is described by the internal flux that is explained below. Internal fluxes have units of K m s$^{-1}$, and can be related to energy fluxes in W m$^{-2}$) by multiplication with the density of air $\rho$ and its heat capacity at constant pressure $c_p$. The density is the weight in kg of one cubic meter of air, whereas the heat capacity is the amount of energy it takes to warm one kg of air with one K.

_external flux_  
It is possible to consider external fluxes as well in this problem in the form of radiative cooling through thermal radiation. This is energy that directly escapes from the system and is therefore considered an external flux. Under clear skies, radiation can escape very efficiently and therefore the coldest nights have clear skies.

_boundary conditions_  

* A Dirichtlet boundary condition is a fixed temperature at the surface.
* A Neumann boundary condition is boundary condition in which energy is removed from the atmosphere at a constant rate.
</div>

The transport of heat through the atmosphere towards the surface can be modelled in a similar way as the groundwater system from the previous assignment. You will build a 1D, stationary model to simulate transfer of energy in the vertical direction. Here, the potential temperature $\theta$ [K] is the state variable. The *potential temperature* of a parcel of air is the temperature it would have at a standard (surface) pressure (see also http://glossary.ametsoc.org/wiki/Potential_temperature).

## Model setup

The **flow domain** has a length of 99.5 m, starting at a height of 0.5 m above the surface and ending at the top of the SBL, which is set at a (fixed) height of 100 m.

The **internal flux** is a flux of energy in the x-direction (height). This is calculated using Fick's law with a so-called eddy diffusivity:
\begin{equation}
Q=-K_{eddy} \frac{\partial\theta}{\partial x}
(\#eq:Fick-eq)
\end{equation}

where $Q$ is the internal flux (defined positive upwards), $K_{eddy}$ is the eddy diffusivity and $\frac{\partial\theta}{\partial x}$ is the gradient of the potential temperature.

The eddy diffusivity can be calculated as: 
$$ K_{eddy}=ku_* x$$
where $k$ is the Von Karman constant [-], $u_*$ is the friction velocity [m/s] at the surface and $x$ is the location (height above the surface). The Von Karman constant $k$ is 0.4 [-] and $u_*$ will be 0.25 [m/s]. 

<div class="exercise"> 
1. On which quantities does the internal flux depend? 
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
1. As seen from the formulas, the internal heat flow at a specific location depends on the vertical gradient in potential temperature, the height above the surface, the friction velocity and the Von Karman constant.
</div>

In these exercises we will apply two kinds of **external fluxes**:   
1. No radiative cooling [0 K/s] within the entire domain       
2. A constant radiative cooling of -1.0E-4 K/s within the entire domain.        
It is also possible to apply a variable radiative cooling, which is defined as a function of height.

The **boundary conditions** are Dirichlet boundaries. At the bottom a potential temperature of 291.73 K is prescribed; at the upper boundary we use 295 K.

<div class="exercise"> 
2. What are the units of the model? 
</div>

<div class="student_answer">
System variable     | Unit           
--------------------|---------     
State ($\theta$)    | ...           
Internal flux       | ...           
External flux       | ...           
Boundary conditions | ...           
Space (scale)       | ...           
</div>

<div class="answer">
System variable     | Unit               
--------------------|---------------    
State ($\theta$)    | K                
Internal flux       | K*m/s           
External flux       | K/s             
Boundary conditions | m               
Space  (scale)      | m                    
The unit of the internal flux can be derived from the formulas: as $u_*$ is a 'velocity' in m/s, the eddy diffusivity K has units $m^2/s$. The internal flux $Q$ is then in $m^2/s*K/m=K*m/s$.
</div>

## Building the model

<div class="exercise">
3. In the chunk below, set up the mathematical part of the stationary heat flow model. Specify the domain, the system flux function and the boundary conditions as given above. 
</div>

Note that upwards flow is defined positive, so **'left' now refers to the lower BC and 'right' refers to the upper BC**. Use the first external flux option (external flux=0).

<div class="student_answer">
```{r}
## insert your code here
```
</div>

<div class="answer">
```{r}
#create domain
domain = c(0.5, 100.) 
#create internal flux function
k = 0.4 # von Karman constant
ust = 0.25 # friction velocity, m/s
tempflux = function(x, state, gradstate)  
{
  return(-k*ust*x*gradstate)
}
#create the model
Meteo_1Dmodel = newFLOW1D(domain=domain, systemfluxfunction=tempflux, name="Heat flow, no radiative cooling")
#set boundary conditions
set.BC.fixedstate(Meteo_1Dmodel,'left',291.7) #left=lower boundary condition [K]
set.BC.fixedstate(Meteo_1Dmodel,'right',295.) # right=upper boundary condition [K]
```
</div>

<div class="exercise">
4. Now set up the numerical part of the model.    
* Use a nodal distance of 2 m.      
* Solve the model by running the current and the previous chunk.    
* Plot the resulting states and fluxes. The argument `vertical=TRUE` in the `plot` function allows you to plot the profiles vertically.  
</div>

<div class="student_answer">
```{r}
## insert your code here
```
</div>

<div class="answer">
```{r}
#create nodes
nodes = seq(domain[1],domain[2],by=2)
#set the discretisation
set.discretisation(Meteo_1Dmodel,nodes,'FV')
#solve and plot
solve.steps(Meteo_1Dmodel)
plot(Meteo_1Dmodel,fluxplot=TRUE,vertical=TRUE,FVstyle=T)
```
</div>

## Testing different resolutions
In this section you will test how the nodal spacing affects the solution of the model.   
Like the groundwater case, this system also has an analytical solution:
\begin{equation}
\theta(x)=290+\frac{(295-290)}{\ln(100/0.03)} \ln(\frac{x}{0.03})
(\#eq:analyt)
\end{equation}

<div class="exercise"> 
5. Make a plot to compare the numerical results to the analytical solution. You can use `dataframe.states` to get a dataframe of the resulting states, that you can plot the way you like it. Then set the nodal spacing to 20 m and compare again. What is your conclusion? 
</div>

<div class="student_answer">
```{r}
## insert your code here
```
</div>

<div class="answer">
```{r}
#find analytical solution
xanalyt = seq(domain[1],domain[2],by=1)
thanalyt = 290+5.*log(xanalyt/0.03)/log(100./0.03) 
#states from numerical solution
oneDstates = dataframe.states(Meteo_1Dmodel)
#make a new, coarser model
Meteo_1Dmodel_coarse = copy.model(Meteo_1Dmodel)
set.name(Meteo_1Dmodel_coarse,"Heat flow model, coarse resolution")
nodescoarse = seq(domain[1],domain[2],by=20.)
set.discretisation(Meteo_1Dmodel_coarse,nodescoarse,'FV')
solve.steps(Meteo_1Dmodel_coarse)
oneDstatescoarse = dataframe.states(Meteo_1Dmodel_coarse)
#and compare with a plot
plot(oneDstates$state,oneDstates$x,xlab='pot.temp. [K]',ylab='height [m]', main="Analytical vs numerical solution, coarse (blue) and fine (black)")
lines(thanalyt,xanalyt,col='red')
points(oneDstatescoarse$state,oneDstatescoarse$x, pch=16, col="blue")
```

5. Clearly, a nodal distance of 20 m is too coarse for this case. If you try out different resolutions, you will find that a resolution of at most 5 m is necessary to get reasonable results. 
</div>

## Stratification-dependent diffusivity
In reality, the eddy diffusivity $K_{eddy}$ depends on the stratification of the atmosphere:
\begin{equation}
K_{eddy}=\frac{ku_*x}{1+5 x/L}
(\#eq:K-eddy)
\end{equation}

where L is the Monin-Obukhov length in m. The Monin-Obukhov length reflects the stability of the near-surface atmosphere, which depends on the surface heat flux (sensible heat from the earth surface).     

The L for the surface layer is often calculated as: 
\begin{equation}
L=-\frac{u_*^3}{k(g/\theta_{ref})(w'\theta')_0}
(\#eq:L-eq)
\end{equation}

where $g$ is the gravitational constant (= 9.81 $kg m^2 s^{-1}$), $\theta_{ref}$ is the reference temperature (~288 K) and $(w'\theta')_0$ is the energy flux at the surface [K m/s]. 

For more information on the Obukhov length, you can have a look at:
http://glossary.ametsoc.org/wiki/Obukhov_length   

<div class="exercise"> 
6. Create a new model object, implement the new eddy diffusivity $K_{eddy}$ that depends on the surface heat flux. Use a surface heat flux of -0.025 $K m s^{-1}$ (downwards heat flux). Define the parameters surface heat flux, L and $K_{eddy}$ separate from the functions so you can adapt them easily. Thereafter, solve and plot the model.
</div>

<div class="student_answer">
```{r}
##Insert your code here
```
</div>

<div clas="answer">
```{r}
k = 0.4  # Von Karman constant, same as before
ust = 0.25 # friction velocity [m/s], same as before
SurfFlux = -0.025 #surface heat flux in K m/s
L=-ust^3/(k*(9.81/288.)*SurfFlux) #Monin-Obukhov length
Keddy=function (x){return (k*ust*x/(1.+5*x/L))} #the eddy diffusivity depends on height and L
#create a new internal flux function
tempflux = function(x,state,gradstate)  
{
  return(-Keddy(x)*gradstate)
}
Meteo_1Dmodel_strat = newFLOW1D(domain=domain,systemfluxfunction = tempflux,name="Heat flow, with stratification") 
#Boundary conditions and discretisation
set.BC.fixedstate(Meteo_1Dmodel_strat,'left',291.7) #K
set.BC.fixedstate(Meteo_1Dmodel_strat,'right',295.) #K
nodes = seq(domain[1],domain[2],by=2)
set.discretisation(Meteo_1Dmodel_strat,nodes,'FV')

solve.steps(Meteo_1Dmodel_strat)
##plotting
plot(Meteo_1Dmodel_strat,fluxplot=TRUE,vertical=TRUE,FVstyle=T)
```
</div>

<div class="exercise">	
7. Check whether the flux over the lower boundary equals the prescribed heat flux. You can use the function `dataframe.boundaries(model)`. 
</div>

<div class="student_answer">
```{r}
##Insert your code here
```
</div>

<div class="answer">
```{r}
dataframe.boundaries(Meteo_1Dmodel_strat)
```
7. The heat flux at the lower boundary is close to -0.025 Km/s, but not exactly. Note that the internal fluxes both at the surface and at the top of the SBL are negative, whereas according to `dataframe.boundaries(Meteo_1Dmodel_strat)` the flux at the top of the SBL is positive. Negative internal fluxes arise as fluxes are directed downwards, whereas the fluxes in `dataframe.boundaries(Meteo_1Dmodel_strat)` are positive when there is a flux over the boundary into the domain and negative when the flux is going out of the domain. 
</div>

<div class="exercise">	
8. If the flux at the surface does not equal the prescribed surface heat flux, adapt the boundary conditions at the surface in such a way that the two fluxes are the same. Solve the model and check the boundary fluxes again.
</div>

<div class="student_answer">
```{r}
##Insert your code here
```
</div>

<div class="answer">
```{r}
set.BC.fixedflux(Meteo_1Dmodel_strat,'left',-0.025) #Not a fixed-state but a fixed-flux boundary (Neumann)
solve.steps(Meteo_1Dmodel_strat)
dataframe.boundaries(Meteo_1Dmodel_strat)
```
</div>

<div class="exercise">
9. Now reset the lower boundary to a fixed value of 291.7 K. Also set the L to a fixed value of 50 m. With that, the eddy diffusivity $K_{eddy}$ becomes constant again.
</div>

<div class="answer">
```{r}
set.BC.fixedstate(Meteo_1Dmodel_strat,'left', 291.7) 
L = 50.
# check if everything is ok
summary(Meteo_1Dmodel_strat)
```
</div>

## **Extra Assignment**: Including a radiative cooling sink
Until now we have considered a situation where the external fluxes are zero (first external flux option, see section 2.1). In many conditions however, there are processes that act as sources and sinks to the state variables (detailed modelling of these processes is beyond the scope of this assignment). Therefore they should be handled as external fluxes to the system, that may depend on the location and the state. Here we will apply radiative cooling as a sink over the entire domain (second external flux option).

<div class="exercise"> 
10. Make a new model which is similar to the model defined above. You can use the function `copy.model(model)`. Then, create an external flux of the second type: a constant radiative cooling of -1.0E-4 K/s within the entire domain (see introduction). 
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
Meteo_1Dmodel_sink = copy.model(Meteo_1Dmodel_strat)
set.name(Meteo_1Dmodel_sink,"Heat flow model, with radiative cooling")
add.spatialflux(Meteo_1Dmodel_sink,-1.0E-4,'RDconst')
summary(Meteo_1Dmodel_sink)
```
</div>

<div class="exercise">
11. Solve the new model and plot the profiles of the potential temperature and internal fluxes. Compare these profiles with the profiles obtained in the situation where no external flux is applied. Can you explain the differences? 
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
solve.steps(Meteo_1Dmodel_sink)
statesSink = dataframe.states(Meteo_1Dmodel_sink)
fluxesSink = dataframe.internalfluxes(Meteo_1Dmodel_sink)
#to compare
solve.steps(Meteo_1Dmodel_strat)
statesNoSink = dataframe.states(Meteo_1Dmodel_strat)
fluxesNoSink = dataframe.internalfluxes(Meteo_1Dmodel_strat)
plot(statesSink$state,statesSink$x,xlab='pot.temp. [K]',ylab='height [m]',main='Tpot profile with (black) and without (red) external sink')
lines (statesNoSink$state,statesNoSink$x, col='red')
plot(fluxesSink$intflux,fluxesSink$x,xlab='internal flux [K m/s]',ylab='height [m]',main = 'Heat flux with (black) and without (red) external sink')
lines (fluxesNoSink$intflux,fluxesNoSink$x, col='red')
```

11. The model with a sink predicts lower temperatures, as it has an additional loss of heat over the domain. These differences remain small due to the top boundary condition which forces the potential temperature to be the same for both models. 
The internal fluxes are constant for the zero external flux model because it has two Dirichlet boundary conditions. For the radiative sink model, in every control volume the incoming and outgoing fluxes have to balance; F$_{top}$ comes into the control volume, and F$_{bottom}$ and R (the radiative sink) leave the control volume. Therefore, F$_{bottom}$+R have to balance F$_{top}$. F$_{bottom}$ of volume 1 is the input F$_{top}$ for the next volume, volume 2, and therefore leads to a decrease in heat transport downwards. 
</div>

The `dataframe.balance` function can calculate the balance (of water, heat, or anything else) over the model domain as a whole. It can also calculate the balance over specific parts of the domain. 

<div class="exercise">
12. Use `dataframe.balance` to calculate the energy balance for the region defined by the volumes (nodes) 14, 15 and 16. Check whether the net inflow to this region equals its total external flux.
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
dataframe.balance(Meteo_1Dmodel_sink, c(14,15,16))
```
</div>

## **Extra Assignment**: Surface flux as a Cauchy/Robin boundary
Until now, we have prescribed the BCs as either fixed states or fixed fluxes (exercise 12.3). In many meteorological models however, the surface BC is defined using so-called drag laws. The flux at the surface, a heat flux in our case, is calculated as a drag coefficient times the difference in temperature between the surface and lowest model level:

\begin{equation}
F_S=C_H (T_S-\theta_1 )
(\#eq:Robin)
\end{equation}

where $F_S$ is the heat flux between the surface and the lowest model level [K m/s]; $C_H$ is the drag coefficient for heat [m/s], $T_S$ is the surface temperature, and $\theta_1$ is the temperature at the lowest model level. This boundary condition is a Cauchy or Robin BC, where the flux is directly coupled to the state of the variable at the boundary. These BCs can be applied using the function `set.BC.fluxstate()`. 

<div class="exercise"> 
13. Make an R-function that takes the state as an argument and returns the surface heat flux. Use a value for $C_H$ of 1.2E-3 m/s and a value of 289 K for the surface temperature. Adapt your previous model such that this Robin BC is applied as the lower boundary. Then solve and plot the new model, the states as well as the fluxes. To see if the new boundary condition is implemented have a look at the `summary(yourmodel)` after the Robin BC is assigned to the model and just before it is solved.  
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
#the new state dependent flux a.k.a. a Robin/Cauchy boundary condition
boundflux  = function(state)  #surface flux in K m/s
{  
  boundflux = 1.2E-3*(289.-state)
  return(boundflux)
}
# create a copy of the previous model and set a new name
Meteo_1Dmodel_robin = copy.model(Meteo_1Dmodel_sink)
set.name(Meteo_1Dmodel_robin,"Heat flow, with Robin BC")
#assign the new BC to the model and check it with `summary()`
set.BC.fluxstate(Meteo_1Dmodel_robin,'left',boundflux)
summary(Meteo_1Dmodel_robin)
#solve the new model
solve.steps(Meteo_1Dmodel_robin)
#create some dataframes on the output for further inspection
oneDstates = dataframe.states(Meteo_1Dmodel_robin)
oneDfluxes = dataframe.internalfluxes(Meteo_1Dmodel_robin)
#plot the model
plot(Meteo_1Dmodel_robin,fluxplot=TRUE,vertical=TRUE,FVstyle=T)
```
</div>

<div class="exercise"> 
14. Check the balance of the system as a whole. Is the net inflow over the boundaries equal to the total external flux? 
</div>

<div class="student_answer">
```{r}
##insert your code here
```
</div>

<div class="answer">
```{r}
dataframe.balance(Meteo_1Dmodel_robin)
```
14. The sum of the external fluxes is equal to the boundary fluxes, while the net internal fluxes are zero, as they should be in this steady-state model.
</div>

<!-- include the hint.js -->  
<script src="hints_n.js"></script>
