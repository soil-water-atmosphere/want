---
title: "Assignment 4 - Exercises on two dimensional modelling"
subtitle: "Finite volumes & elements, 2D"
author: "The Want Team"
date: "December 2020"
output:
  html_notebook:
    css: want_n.css
    toc: yes
  html_document:
    code_folding: show
    css: want_n.css
    toc: yes
---
<div class="comment">
**[GB]**Use of sandbox FVFE2D
</div>
```{r}
rm(list = ls())
library("FVFE2D")
#source("sourceFVFE2D.R")
library("fields")
```



Note: If you want all the generated 3D-plots to remain open, run the complete Rmd before knitting the document to html.


# Learning Goals
* Understand how one dimensional groundwater models differ from 2 dimensional groundwater models.
* Understand how different external fluxes are applied and calculated in 2 dimensional groundwater models
* Understand how the model solution differs between the Finite Volume and Finite Elements method.
* Know why interpolation functions are needed, which are implemented in the FVFE2D package and how they differ.
* Understand the effect of changing the nodal distances near points of interest on the model solution.
* Understand why unsaturated groundwater flow complicates the solution of the model and know which state variable would be more useful for this situation.

# Introduction
In these exercises the basic steps of two dimensional groundwater flow models will be reviewed with the Finite Volume method and Finite Element method as implemented in the FVFE2D package. These exercises do not provide a complete overview of the functionality of the package, but several important functionalities will be discussed. You can use the built-in help for more information on this package. In many exercises an R-code chunk is given and needs to be edited by adding your answers. Editing is only necessary at locations indicated with 'XXXX', unless explicitly stated otherwise. After completing the R-code chunk, remove the `eval=FALSE` statement in the header of it so it will be included in the final document.

<div class="comment">
**[GB]**in header chunk hieronder eval=F gezet ivm pandoc conversion errors en fvfe2d gedoe.. nu met sandbox
</div>



```{r, include=FALSE,eval=FALSE}
# Clear the environment.
#rm(list=ls())
#check packages to use and activate/install them
#Check to see if package(s) are installed, install if not and then load

#pkgs is a vector of strings with length >= 1

CheckInstallPackages <- function(pkgs){

#For each pkg in pkgs (attempt to load each package one at a time):

 x <- lapply(pkgs, function(pkg){

  #Load the package if available,

  if(!do.call("require", list(pkg))) {

   #Silently attempt to install into the default library

   try(install.packages(pkg, lib=.Library,repos="http://cran.rstudio.com"))

   #Now attempt to load the package, catch error if it wasn't installed

   tryCatch(do.call("library", list(pkg)),

    #Catch if we're unable to install into the default library

    error = function(err) {

     #If non-interactive, install into this user's personal library

     if(!interactive()) {

      #Get the path to this user's personal library

      personalLibPath <- Sys.getenv("R_LIBS_USER")

      #If the personal library is not in the list of libraries

      if(is.na(match(personalLibPath, .libPaths()))) {

       #Then create the personal library

       dir.create(personalLibPath, recursive = TRUE)

       #And add the personal library to the list of libraries

       .libPaths(personalLibPath)

      }

      #Attempt to install the package into the personal library

      #If this fails, raise the error back to the report

      install.packages(pkg, lib=personalLibPath, repos="http://cran.rstudio.com")

      #Finally, attempt to load the package

      do.call("library", list(pkg))

 }})}})

} 
CheckInstallPackages(c("fields","FVFE2D"))


```

# 1. Construct the mathematical part of the two dimensional model
The first step in making a two dimensional model is defining the domain. In figure 1 below an example of such a domain is given on a Cartesian grid.

![Figure 1: Two dimensional model domain.](domain2D.png)

<div class="exercise">
1. Edit the R-code chunk below such that the model domain is defined as illustrated in figure 1.
```{r, eval=FALSE}
domain = XXXX
print(domain)
plot(domain, xlab="x", ylab="y", xlim=c(0,2000), ylim=c(0,2000))
grid()
polygon(domain, col=rgb(0.5,0.9,0.9,0.2))
```
</div>

<button type="button" onclick="showHint(4001)">Show Hint</button>
<p id="Q4001"> </p>

<div class="answer">
```{r}
# The domain is defined by a matrix with 2 columns.
domain = matrix(c(300,200,
                  900,100,
                  1800,450,
                  1900,1900,
                  900,1850,
                  100,1400),ncol=2,byrow=TRUE)
print(domain)
# Plot your domain on a cartesian grid.
plot(domain,xlab="x",ylab="y",xlim=c(0,2000),ylim=c(0,2000))
grid()
polygon(domain,col=rgb(0.5,0.9,0.9,0.2))
```
</div>

To complete the mathematical part of the model, the internal flux, the boundary conditions and an external flux have to be defined. The following information has to be added to the two dimensional model:

* A (linear) internal flux based on Darcy's law with $kD=60\frac{m^2}{d}$.
* The western and eastern boundary have a Dirichlet boundary condition set to 0.0 and 1.0 $m$, respectively.
* An external flux simulating a precipitation rate of 1 $mm/day$, uniform in space.

<div class="exercise">
2. Complete the mathematical part of the two dimensional model by editing the R-code chunk below.
```{r, eval=FALSE}
# Define the internal flux.
grad.flux = function(x, y, state, grad)
{
  return(XXXX)
}

# Construct the model.
GWModel2D = newFLOW2D(domain, grad.flux) 
set.name(GWModel2D, "2D groundwater model")

# Add external flux.
add.spatialflux(GWModel2D, XXXX, "rain")

# Setting the boundary conditions. This command shows you the name of each boundary.
 plot.BC.id(GWModel2D)

XXXX # western boundary
XXXX # eastern boundary

summary(GWModel2D)
```
</div>

<button type="button" onclick="showHint(4002)">Show Hint</button>
<p id="Q4002"> </p>

<div class="answer">
```{r}
# Define the internal flux. Note the extra argument in the internal flux function.
kD = 60
grad.flux = function(x, y, state, grad)
{
  return(-kD*grad)
}

# Construct the model.
GWModel2D = newFLOW2D(domain, grad.flux) 
set.name(GWModel2D, "2D groundwater model")

# Add external flux.
add.spatialflux(GWModel2D, 0.001, "rain")

# Makes a plot of the domain containing the boundary segment identifiers which can be used as arguments for the set.BC functions.
 plot.BC.id(GWModel2D)

# Setting the boundary conditions
set.BC.fixedstate(GWModel2D, "W", 0)
set.BC.fixedstate(GWModel2D, "E", 1)

summary(GWModel2D)
```
</div>

# 2. Construct the numerical part of the two dimensional model
The next step in the two dimensional model construction is to make the model discrete by choosing nodes and a numerical technique, either FV or FE. In a separate file called 'geogendemo.R' the function geogendemo() is defined. This function illustrates some techniques built in the FVFE2D package to generate nodes. If you run the script you will see a first example being plotted. The plot shows the resulting Voronoi cells randomly colored. Changing the argument of the geogendem() function in the last line and running the script again shows a second example. There are 10 different examples defined.

<div class="question">
3. The descriptions for example 3-10 in the geodendemo() function are missing. Give for each case the proper description, suggestions are given above the first if-statement of the geodendemo() function. Choose the correct description from the commented list above the geogendemo function and add these to the "descr[]" vector.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">  
Answer to 3; descriptions

1. descr[1] = "distance order of 1, graph-verbose"
2. descr[2] = "distance order of 1, non-graph-verbose"
3. descr[3] = "distance order of 1, some prefixed node at lower center"
4. descr[4] = "distance order of 0.3"
5. descr[5] = "distance x not equal to distance y"
6. descr[6] = "distance increasing in x-direction
7. descr[7] = "distance increasing in y-direction"
8. descr[8] = "distance smaller near (5,5)"
9. descr[9] = "distance larger near (5,5)"
10. descr[10] = "distance smaller near line"
</div>

<div class="question">
4. Change the geodendemo() function such that it generates nodes for the Finite Elements method. Observe the differences with the Finite Volumes method. What are the main differences observed between these methods?
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
4. The shapes of the control volumes are clearly different. The control volumes from the finite volume method have a variable amount of vertices, in contrary to the control volumes produced by the finite elements method which are all triangles.
Besides, the control volumes at the boundaries of the domain look differently. The control volumes from the finite volume method are cut in half, while the control volumes from the finite elements method are not and look equal to those generated anywhere else in the domain. Finally, there exists only one descretization solution to a given nodal configuration if one applies the finite volume method. Using the finite elements method there exist at least two different configuration solutions to a certain nodal configuration (the triangles can be drawn mirrored in this case). 
</div>

Now, we will construct our two dimensional model. The following information is given in order to complete the numerical part:

* Discretise with an opdist of 100 and use the Finite Volumes method; see `set.discretisaton()` for details
* Use the `solve.steps()` function to solve the model
* To view the result, a plotting line: `plot(GWModel2D, fill="state", fill.3D=True)` has to be added, which produces both a 2D and 3D plot.

<div class="exercise">
5. Create a new R-code chunk. Finalize the numerical part, solve the model and create a plot in both 2D and 3D. To make sure that each three dimensional plot is created in a new window, add: 'new_dev = open3d()' before the 3D plotting command.
</div>

<button type="button" onclick="showHint(4003)">Show Hint</button>
<p id="Q4003"> </p>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
```{r}
# Discretisation
set.discretisation(GWModel2D, nodes=list(type="geomgen", optdist=100, verbose=FALSE), method="FV")

# plot Voronoi cells with random colors.
plot(GWModel2D, fill="random")

# Solve 
solve.steps(GWModel2D)

# Plot states
new_dev = open3d()
plot(GWModel2D,fill="state", fill.3D=TRUE, main.title = "2D groundwater model - FV")

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q5", line = 3)
})
```
</div>

There are many other post processing and plotting possibilities built in the FVFE2D package. Some suggestions are given:

* Printing the first 10 rows of the x, y and state values of the model
* Creating a 2D plot with contour lines for the values 1 to 8
* Creating a 1D plot of a cross section through the domain

<div class="exercise">
6. Use the help function to carry out the post processing and plotting suggestions, as given above. Describe the results of the plots.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
```{r}
# list of x, y and state of the first ten rows.
print(head(dataframe.states(model=GWModel2D), 10))

# 2D plot with contour lines for the values 1 to 8. Note that the contour lines cannot cross through a control volume since they have a constant value over the complete section.
plot(GWModel2D, fill="state", fill.contours = seq(0,8,by=1))

# 1D plot of a cross section that you can define yourself. Note the step behavior due to the constant values of the control volumes produced by the finite volumes method.
plot(GWModel2D, fill="state", linesection=c(500,500,1500,1500))
```
</div>

Now that it is clear how the two dimensional model looks if it is solved using the Finite Volumes method, we will investigate the model solution when the Finite Elements method is used.

<div class="exercise">
7. Change the numerical part of the two dimensional model, such that it solves using the Finite Elements method. Also, make a contour plot of the new situation.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
7. In the Finite Elements method, contours can intersect through the segments because of linear interpolation between the nodes of the two dimensional system. This results in a smooth contour line. In the Finite Volume method each Voronoi cell is assigned a value and this value is constant for the complete segment. Therefore, a contour line can be located at the boundary of the segment only. This results in the blocky behavior of the contour line.
</div>

# 3. Several interpolation functions
In the one dimensional models, `approxfun()` was used to interpolate the kD parameter. In the transient models, we used the built-in `state.fun()` to interpolate the states at a certain time step for use in the next time step. A two dimensional equivalent of the interpolation functions is useful for two dimensional modelling. Several different functions will be discussed in this part.

<div class="exercise">
8. The two dimensional interpolation functions are not built into the standard library of R. Therefore, three of these functions are built into the FVFE2D package. Use the help to find them.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">

8. 


* invdist.fun():          Inverse distance interpolator
* lininterpol.fun():      Linear interpolator
* nearestneighbour.fun(): Nearest neighbour interpolator
</div>


The following chunk generates several plots. Inspect this chunk and it results.

```{r}
# The data: This will construct a dataframe containing a small example of a spatially measured quantity called T. This is the value to be interpolated and the location of this value is described by an x and y position.
tointerp = data.frame(
  x=c(45,34,19,52,93,87),
  y=c(64,73,15,40,31,62),
  T=c(33,26,17,31,21,41))

# A simple plot of the data frame with the data to be interpolated.
plot(tointerp$x, tointerp$y, cex=tointerp$T/10,
     xlim=c(0, 100), ylim=c(0, 100),
     main="size=T-value", xlab="x", ylab="y")

# Construct the interpolation function using the nearestneighbour.fun(). This is a 2D generalisation of the 1D approxfun() with method=constant.
nnf = nearestneighbour.fun(tointerp, zname="T")

# Test the interpolation function by giving it a random x and y coordinate that does not occur in the 'tointerp' data frame.
nnf(30, 40)
nnf(22.45, 67.88)

# Define boundaries for the demonstration of the interpolation function.
Npl = 50
xtopl = seq(0, 100, length=Npl)
ytopl = seq(0, 100, length=Npl)

# Makes a plot illustrating the interpolation function. It calculates all the combinations of x-values in 'xtopl' and all the y-values in 'ytopl' by means of the interpolation function just constructed. It is the magical function 'outer()' that does this. You do not need to understand this function, just observe the third argument to be the constructed interpolation function.
z = outer(xtopl, ytopl, nnf)
image.plot(xtopl, ytopl, z, main="Nearest neighbour interpolation (nnf)")
points(tointerp$x, tointerp$y, cex=2, pch=20, col="white")
points(tointerp$x, tointerp$y, cex=1, pch=10, col="black")

# 3D plot
new_dev = open3d()
surface3d(xtopl,ytopl, z, opacity=0.3, col="light blue")
spheres3d(tointerp$x, tointerp$y, tointerp$T, radius=2, col="red")
box3d()

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q8: Nearest neighbour inter.", line = 3)
})
```

<div class="exercise">
9.Observe the 2D and 3D plots produced by the constructed interpolation function. Choose between the following two lines:

* This reminds me of the plots made with the FE principle
* This reminds me of the plots made with the FV principle
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
9. This should remind you of the FV principle. The same state is assigned to all positions within the volume. A blocky behavior is found. 
</div>

<div class="exercise">
10.Change the nearestneigbour.fun() to the lininterpol.fun() and create the 2D an 3D plots again. choose:

* This reminds me of the plots made with the FE principle
* This reminds me of the plots made with the FV principle

What do you think of the interpolation outside of the interior of the convex hull (smallest area that contains all the nodes) defined by the nodes?
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
10. This should remind you of the FE principle because of the gradual change of states between the nodes. If the Finite Elements method is used, triangles between the nodes are constructed. Outside of these triangles triangular-linear-interpolation is not possible.
```{r}
# Construct the interpolation function using the lininterpol.fun(). This is a 2D generalisation of the 1D approxfun() with method=linear.
lif = lininterpol.fun(tointerp, zname="T")

# Makes a plot illustrating the interpolation function. It calculates all the combinations of x-values in 'xtopl' and all the y-values in 'ytopl' by means of the interpolation function just constructed. It is the magical function 'outer()' that does this. You do not need to understand this function, just observe the third argument to be the contructed interpolation function.
z = outer(xtopl, ytopl, lif)
image.plot(xtopl, ytopl, z, main="Linear interpolation function (lif)")
points(tointerp$x, tointerp$y, cex=2, pch=20, col="white")
points(tointerp$x, tointerp$y, cex=1, pch=10, col="black")

# 3D plot
new_dev = open3d()
surface3d(xtopl,ytopl, z, opacity=0.3, col="light blue")
spheres3d(tointerp$x, tointerp$y, tointerp$T, radius=2, col="red")
box3d()

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q10: Linear inter.", line = 3)
})
```
</div>

<div class="exercise">
11. Change the `lininterpol.fun()` to the `invdist.fun()` and create the 2D an 3D plots again. Find an explanation of the inverse distance function on the Internet. What is your conclusion if you compare the result with the results from the previous two interpolation functions?
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
11. Inverse distance weighted (IDW) interpolation explicitly makes the assumption that things that are close to one another are more alike than those that are farther apart. To predict a value for any unmeasured location, IDW uses the measured values surrounding the prediction location. The measured values closest to the prediction location have more influence on the predicted value than those farther away. IDW assumes that each measured point has a local influence that diminishes with distance. It gives greater weights to points closest to the prediction location, and the weights diminish as a function of distance, hence the name inverse distance weighted. Taken from:
http://pro.arcgis.com/en/pro-app/help/analysis/geostatistical-analyst/how-inverse-distance-weighted-interpolation-works.htm

The result of the invdist.fun() in comparison with the other two interpolation functions is that the result is now smooth and space filling.
```{r}
# Construct the interpolation function using the invdist.fun().
idf2 = invdist.fun(tointerp, zname="T")

# Makes a plot illustrating the interpolation function. It calculates all the combinations of x-values in 'xtopl' and all the y-values in 'ytopl' by means of the interpolation function just constructed. It is the magical function 'outer()' that does this. You do not need to understand this function, just observe the third argument to be the contructed interpolation function.
z = outer(xtopl, ytopl, idf2)
image.plot(xtopl, ytopl, z, main="Inverse distance interpolation, power=2 (idf2)")
points(tointerp$x, tointerp$y, cex=2, pch=20, col="white")
points(tointerp$x, tointerp$y, cex=1, pch=10, col="black")

# 3D plot
new_dev = open3d()
surface3d(xtopl,ytopl, z, opacity=0.3, col="light blue")
spheres3d(tointerp$x, tointerp$y, tointerp$T, radius=2, col="red")
box3d()

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q11: Inverse distance inter.", line = 3)
})
```
</div>

The invdist.fun() has an extra parameter called power. The default value of this parameter is 2, so that is the value that we have used in the previous construction of the invdist.fun(). 

<div class="exercise">
12. Construct new interpolation functions called e.g., "idf0.5" and "idf4", using 0.5 and 4 as value for the argument power. Discuss the differences and similarities with all the previously used interpolation functions.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
12. Since the influence of the individual observations is based on the *inverse* of the distance powered, a lower value of 0.5 makes the influence of the observations large in the whole domain. In the extreme case of a power value of 0.0 the interpolated value will be the average of the observations in the whole domain.  
With a value of 4 for the power influence of each observation will be fairly local and resembles the nearest neighbour interpolation.  

```{r}
# power is 0.5
idf0.5 = invdist.fun(tointerp, zname="T", power=0.5)

z = outer(xtopl, ytopl, idf0.5)
image.plot(xtopl, ytopl, z, main="Inverse distance interpolation, power=0.5 (idf0.5)")
points(tointerp$x, tointerp$y, cex=2, pch=20, col="white")
points(tointerp$x, tointerp$y, cex=1, pch=10, col="black")

# 3D plot of power=0.5 interpolation.
new_dev = open3d()
surface3d(xtopl,ytopl, z, opacity=0.3, col="light blue")
spheres3d(tointerp$x, tointerp$y, tointerp$T, radius=2, col="red")
box3d()

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q12: inv. dist. power=0.5", line = 3)
})

# power is 4
idf4 = invdist.fun(tointerp, zname="T", power=4)

z = outer(xtopl, ytopl, idf4)
image.plot(xtopl, ytopl, z, main="Inverse distance interpolation, power=4 (idf4)")
points(tointerp$x, tointerp$y, cex=2, pch=20, col="white")
points(tointerp$x, tointerp$y, cex=1, pch=10, col="black")
```
```{r}
# 3D plot of power=4 interpolation.
new_dev = open3d()
surface3d(xtopl,ytopl, z, opacity=0.3, col="light blue")
spheres3d(tointerp$x, tointerp$y, tointerp$T, radius=2, col="red")
box3d()

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q12: inv. dist. power=4", line = 3)
})
```
</div>

We will now apply the interpolation techniques to our 2D groundwater case.     
The transmissivity value $kD$ used in the Darcy function can vary strongly in space, due to variation in the thickness of an aquifer layer or its composition. Of course, transmissivities cannot be measured at every location in a domain. Below, an interpolation technique is going to be used to interpolate the kD values for unknown locations within the domain. The locations at which the transmissivities are known are presented in the R-code chunk below:

```{r}
kD.Data = data.frame(
  x = c(900,680,380,1040,1640,200,440,1900),
  y = c(1280,1460,300,620,1500,1240,655,210),
  kD = c(75,65,63,66,43,64,78,48))
```

<div class="exercise">
13.Choose, from the interpolation functions available, the smoothest interpolator that still respects the data and plot the two dimensional model domain of TwoDModel with the interpolated transmissivity values. For this use one of the previous interpolation chunks.  
</div>

<button type="button" onclick="showHint(4004)">Show Hint</button>
<p id="Q4004"> </p>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">

13. This will be the inverse distance method: `invdist.fun`

```{r}
# The interpolation function.
kD.field  = invdist.fun(kD.Data, zname="kD")

Npl = 50
xtopl = seq(0,2000, length=Npl)
ytopl = seq(0,2000, length=Npl)

z = outer(xtopl, ytopl, kD.field)
image.plot(xtopl, ytopl, z, main="Transmissivity field, inverse distance interpolation")
polygon(domain, border = "white", lwd=3)
polygon(domain, border = "black", lwd=0.7)
points(kD.Data$x, kD.Data$y, cex=kD.Data$kD/10, lwd=3, col="white")
points(kD.Data$x, kD.Data$y, cex=kD.Data$kD/10, lwd=0.5, col="black")
```
</div>

In the `GWModel2D` the constant value of $kD=60m^2/d$ was used as value for the transmissivity. We will now construct a model that is identical to the `GWModel2D`, except for the interpolation function of the transmissivities in the internal flux of the new model.

* Call the new model 'TwoDmodelInterp'
* Use an interpolation function of your own choice (think about what is realistic)
* Use the same nodal generation function as in the TwoDmodel
* For the discretisation use the Finite Volumes method
* Create a contour plot of the result

<div class="exercise">
14. Use the bullets above to construct a new model that uses an interpolation function of your choice in the internal flux function of the new model. Can you observe differences between the two models? Use the Finite Volume solver. 
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
14. If the interpolation function is implemented correctly, a change of the contour line positions in the model domain should be noticed.
```{r}
# Interpolation function.
kD.field  = invdist.fun(kD.Data, zname="kD")

# Internal flux definition.
grad.flux = function(x, y, state, grad)
{
  return(-kD.field(x, y)*grad)
}

# Construct the model
TwoDmodelInterp = newFLOW2D(domain, grad.flux) 
set.name(TwoDmodelInterp, "2D model, Interpolated kD field")

# Add external flux
add.spatialflux(TwoDmodelInterp, 0.001, "rain")

# Setting the boundary conditions
plot.BC.id(TwoDmodelInterp)
set.BC.fixedstate(TwoDmodelInterp, "W", 0)
set.BC.fixedstate(TwoDmodelInterp, "E", 1)

# Discretisation
set.discretisation(TwoDmodelInterp, nodes=list(type="geomgen", optdist=100, verbose=FALSE), method="FV")

# Solve 
solve.steps(TwoDmodelInterp)

# Plot states
plot(TwoDmodelInterp, fill="state", fill.contours = c(5,6))
plot(GWModel2D, fill="state", fill.contours = c(5,6))
```
</div>

# 4. Effect of nodal distances
One of the selling points of the Finite Volumes and Finite Elements method is that more nodes can be chosen near points of interest, and by that higher precision can be obtained. Use in this section the Finite Elements discretization technique, except when explicitly stated otherwise.

<div class="exercise">
15. Create a new chunk below. Copy the `GWModel2D` model, call it `TwoDModelWellFV` and implement a well at location x=1000 and y = 1000 with an extraction rate of 1000 $m^3/d$. Solve the model (use Finite Volumes) and create a 2D and 3D plot. You can use the `summary(modelname)` function to check what is implemented in the model.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">

15. see the code chunk below;  

```{r}
# Copy and assign new name to the model.
TwoDModelWellFV = copy.model(model=GWModel2D)
set.name(TwoDModelWellFV, newname="TwoDModelWell")

# Add the well.
add.pointflux(TwoDModelWellFV, c(1000, 1000), -1000, "Well")

# Solve
solve.steps(TwoDModelWellFV)

# Plotting
plot.BC.id(TwoDModelWellFV)
plot(TwoDModelWellFV, fill="random")

# 3D plot
new_dev = open3d()
plot(TwoDModelWellFV, fill="state", fill.3D=TRUE)

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q15: Well FV", line = 3)
})
```
</div>

<div class="exercise">
16. Create a copy af the previous chunk and replace the Finite Volume FV with the Finite Element FE technique. Call this model `TwoDmodelWellFE`. Compare the Finite Volumes discretisation with the Finite Elements discretisation in the TwoDModelWell visually. Does the result look as you expected?
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
16. The blocky, basalt like structure, should be found for the Finite Volumes method. The Finite Elements method should produce a continuous surface.
```{r}
# Copy and assign new name to the model.


TwoDModelWellFE = copy.model(model=GWModel2D)
set.name(TwoDModelWellFE, newname="TwoDModelWellFE")
set.discretisation(TwoDModelWellFE,nodes=list(type="geomgen", optdist=100),method="FE")

# Add the well.
add.pointflux(TwoDModelWellFE, c(1000, 1000), -1000, "Well")

# Solve
solve.steps(TwoDModelWellFE)

# Plotting
plot.BC.id(TwoDModelWellFE)
plot(TwoDModelWellFE, fill="random")

# 3D plot
new_dev = open3d()
plot(TwoDModelWellFE, fill="state", fill.3D=TRUE)

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q15: Well", line = 3)
})

```

</div>

<div class="question">
17. Decrease the nodal distance in a diameter of 200 $m$ around the location of the well to 25 $m$. Use a nodal distance of 100 $m$ outside of this area. Are the results indeed better/more realistic?
</div>

<button type="button" onclick="showHint(4005)">Show Hint</button>
<p id="Q4005"> </p>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
17. The deepest point in the well is calculated more precisely.
```{r}
# Decrease nodal distances near the location of the well.
welldist = func.dist.to.point(c(1000, 1000), 200, 25, 100)
set.discretisation(TwoDModelWellFE, nodes=list(type="geomgen", optdist=welldist, verbose=FALSE), method="FE")

# Solve
solve.steps(TwoDModelWellFE)

# Plotting
plot.BC.id(TwoDModelWellFE)
plot(TwoDModelWellFE, fill="random")

# 3D plot
new_dev = open3d()
plot(TwoDModelWellFE, fill="state", fill.3D=TRUE, main.title="TwoDModelWell - decreased nodal distance")

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q17: Well node config.", line = 3)
})
```
</div>

Another type of external flux is a line flux. A river in a groundwater model can be considered to be a line flux, that 'extracts' water by draining the groundwater. In the FVFE2D package a specific function is included to define a line flux in the model.

<div class="exercise">
18. Copy the `TwoDmodeWellFE`, remove the extraction well (see the help on this) and call it TwoDModelRiver. Implement a canal (straight line) between the points (400, 500) and (1500, 1000) and assign it an extraction rate of 1 $m^2/d$. Finally, solve the model and create a 2D and 3D plot.
</div>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
18. Model with a canal;  

```{r}
# Copy and assign new name to the model.
TwoDModelRiver = copy.model(model=TwoDModelWellFE)
set.name(TwoDModelRiver, newname="TwoDModelRiver")

rem.pointflux(TwoDModelRiver,'Well')
summary(TwoDModelRiver)

# Add the river.
river = matrix(c(400, 500, 1500, 1000), ncol=2, byrow=TRUE)
add.lineflux(TwoDModelRiver, points=river, rates=list(-1), name="canal")

# Solve
solve.steps(TwoDModelRiver)

# Plotting
plot.BC.id(TwoDModelRiver)
plot(TwoDModelRiver, fill="random")

# 3D plot
new_dev = open3d()
plot(TwoDModelRiver, fill="state", fill.3D=TRUE)

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q18: river", line = 3)
})
```
</div>

<div class="exercise">
19. Decrease the nodal distance in the neighbourhood of the river and solve the model again. Decrease the nodal distance in an area of 200 $m$ around the river to a distance of 25 $m$; use a nodal distance of 100 $m$ outside this area. How does this change the new solution? 
</div>

<button type="button" onclick="showHint(4006)">Show Hint</button>
<p id="Q4006"> </p>

<div class="student_answer">
Fill in your answer here...
</div>

<div class="answer">
19. The solution is more precise and realistic in the neighbourhood of the river, due to the change in discretisation.  

```{r}
# Copy and assign new name to the model.
TwoDModelRiverFine = copy.model(model=TwoDModelRiver)
set.name(TwoDModelRiverFine, newname="TwoDModelRiver - decreased nodal distance")

# Add the river.
river = matrix(c(400, 500, 1500, 1000), ncol=2, byrow=TRUE)
add.lineflux(TwoDModelRiverFine, points=river, rates=list(-1), name="canal")

# set discretisation.
optdist = func.dist.to.line(river, 200, 25, 100)
set.discretisation(TwoDModelRiverFine, nodes=list(type="geomgen", optdist=optdist, maxiter=20,stopcrit=0.005, verbose=FALSE, sleeptime=0.05), method="FE")

# Solve
solve.steps(TwoDModelRiverFine)

# Plotting
plot.BC.id(TwoDModelRiverFine)
plot(TwoDModelRiverFine, fill="random")

# 3D plot
new_dev = open3d()
plot(TwoDModelRiverFine, fill="state", fill.3D=TRUE)

# This adds a title to the 3D plot
bgplot3d({
  plot.new()
  title(main = "Q19: river node config.", line = 3)
})
```
</div>

# 5. Adding top boundary conditions to the model

With the two dimensional models additional functions can be added representing different kinds of interactions between the saturated groundwater and for example the open water system on top.  
In the previous exercises the effect of nodal spacing is illustrated, including the effect of local grid refinement close to a line flux.
In this section we will focus on the effect of implementing a river in the already developed 2D groundwater model `GWModel2D`.  
This basic groundwater model contains two Dirichlet boundary conditions and the borders of the model and recharge. The numerical discretization is based on the Finite Volume Method.

```{r}
plot(GWModel2D,fill = 'state',fluxvecsize = 1)
```
<div class="question">
20.  

Can you deduce from the plot above of the states of the model;  

1. at which sides the Dirichlet boundary conditions are applied?
2. what type of boundary conditions is used for the other two sides?
3. that a flux rate, called rain, is added to the model?
</div>

<div class="answer">
20.  

answers

1. indicated by the contours of the state and the flow direction, the western and eastern boundaries are the lowest and water is discharged at these boundaries.  
2. the north and south side are clearly flow lines, no water flows *over* these boundaries so these are Neumann boundary conditions. Since this is the 'natural'(you can consider it the default) boundary condition, nothing need to be set for these boundaries.  
3. as illustrated by the state (head) distribution, water flows from the center of the model towards the western and eastern boundaries. 
</div>


The river will be a function containing an entrance resistance of the river-bed and a prescribed river level. It could function as a source or sink for the groundwater, depending on the calculated state in the model.

<div class="question">
21. How would you call this kind of boundary condition?  
</div>

<div class="student_answer">
Give you answer here:    
</div>

<div class="answer">
21.  

That will be the Cauchy boundary condition since is will generate a flux based on the prescribed river level. The resistance takes care of the rate of the flux i.c.m. with the potential difference between the states (heads).  
</div>

## 5.1 Implementing the river  

As already illustrated in FVFE assignment 2, the interaction between the river and the groundwater model will be modeled with a function.  
The river level is prescribed at 1.25 m (Above Mean Sea Level)  
The entrance of the river bed will be 5 days  
The width of the river is 4 m.

To keep the original `GWModel2D` model, a copy of this model will be created in the following chunk.
```{r}
GWModel2D_river = copy.model(GWModel2D)
summary(GWModel2D_river)
```



<div class="question">
21. Set up a new function for the river in the following chunk
</div>


```{r eval=FALSE}
#river level
#river bed resistance
# river_BC = function(x,y,state)
# {
  
# }

```

<div class="answer">
22.  

See the code chunk below:

```{r }
river.level = 1.25
resistance = 5
river.width = 4 
river_BC = function(x,y,state)
{
  River_flux = river.width * (river.level - state)/resistance
  return(River_flux)
}
```

</div>

Now this river (the position) needs to be added to the model.  
In one of the exercises in the previous section a line flux variable called `river` was already defined.  
We will make use of this variable again. It is setup as a matrix, containing the begin point and end point coordinates, as shown in the chunk below:  

```{r}
river
```
To add the river to the model we can make use of the `add.lineflux()` function.  
Checkout the package help on this function for proper implementation.

<div class="question">
23. Define the river in a proper way to be added to the model in the following chunk  
```{r}
##add a river to model
#add.lineflux()
##check if the river is actually added to the model
#summary(TwoDmodelRiver)
```

</div>

<div class="answer">
23. see code chunk below:
```{r}
#add river to model
add.lineflux(model = GWModel2D_river, points = river, rates = list(river_BC), name = "river" )
#check if the river is actually added to the model
summary(GWModel2D_river)
```
As illustrated with the summary of the model the river is implemented as a line flux.
</div>

The model can now be run and the effect of the river analyzed.

<div class="question">
24. set up the following chunk for running the model, plot the states and calculate the balance of the model
```{r}
#run the model

#plot the states of the model

#print the (water) balance of the model
```

</div>

<div class="answer">
24. see code chunk below:

```{r}
#run the model
solve.steps(GWModel2D_river, verboselevel = 1)
#plot the states of the model
plot(GWModel2D_river,fill = "state", fluxvecsize = 1,
     fill.contours = c(1,2,3,4,5,6),
     addlines = list(list(river[,1],river[,2],col = 'green')))
#print the (water) balance of the model
dataframe.balance(GWModel2D_river)
```
The effect of the river is clearly visible in the plot and in the (water) balance.

</div>

We will now have a closer look at the effect of the river on a nodal/volume scale.  
For this we will add node numbers to the plot and zoom in a bit.

```{r}
plot(GWModel2D_river,fill="state",nodenumbersize = 0.6,addlines = list(list(river[,1],river[,2],col = 'green')))
plot(GWModel2D_river,xlim = c(800,1300),ylim=c(500,1000),fill="state",nodenumbersize = 0.6,addlines = list(list(river[,1],river[,2],col = 'green')))
```
We will focus on some calculations at node 252 half way the river. 
The calculated state, which is the head in the groundwater model is:

```{r}
#put the states in a dataframe
heads = dataframe.states(GWModel2D_river)
#have a look at the format of this dataframe
head(heads)
#select the data of the node
heads[252,]

heads[252,]$state


```
<div class="question">
25. Calculate "by hand", the discharge rate to the river in this node. Check your results with the (water) balance for this node.
Total total length $l$ of the river allocated to node 252 is 120.0829 m
</div>

<div class="answer">
25. The river level, the river-bed resistance and the width of the river are all given.
The discharge is calculated with the river function which is a Cauchy boundary condition.

the flux rate in $m^2/d$:  
$q_{river}= width \frac{H_{riv}-state}{C_{entrance}} \rightarrow 4 \frac{1.25-2.281047}{5}=-0.8248376 \,\,m^2/d$

and the total discharge for this river node :

$Q_{river}=l\, q_{river}\rightarrow 120.0829*-0.8248376=-99.048891$



```{r}
dataframe.balance(GWModel2D_river,c(252))
externe.fluxen = dataframe.externalfluxes(GWModel2D_river)
```

The results match perfectly.

</div>

<div class="question">
26. Calculate "by hand" the internal flux over the side of node 252 and 230.  

Besides the data already present, additional data is available in the following table:  

* the `facelength` between node 252 and node number `ni2`.  
* the `nodedistances` between node 252 and node number`ni2`.  

```{r}
#Selection for some geometrical info; the length of the face between node 252 and 230 and the nodal distance between them
nodal_interfaces = data.frame(GWModel2D_river$cellinterfaces)
node252.additional = nodal_interfaces[which(nodal_interfaces$ni1 == 252),names(nodal_interfaces) %in% c("ni2","facelength","nodedistance")]
print(node252.additional)
```

The numbers in the first column; 182, 183 and 184 are just row numbers of the (R) data frame. You may ignore them.

</div>


<div class="answer">
26. Based on the above data one can derive the internal flux over the face between node 252 and 230 by:  

* states of both nodes  
* transmissivity: 60 $m^2/d$  
* Darcy's equation
* `facelength`
* `nodedistance`  

States (heads) at node 252 and 230 are:
```{r}
print(heads[252,]$state)
print(heads[230,]$state)
```


In a formula: $\overrightarrow Q_{[252,230]} = facelength \,kD\,\frac{H_{252}-H_{230}}{nodedistance}$

Resulting in: $76.15510*60*\frac{2.281047 - 2.7731}{104.7965}=-21.4543$


To check the results the following table contains:  

* the node towards the flow goes from 252 `node2`.  
* `flux1to2`is the flux-rate calculated from node 252 to node; `node2`.  
* `totflux1to2`is the total flux going from node 252 to `node2`.  

```{r}
#put the internal fluxes into a dataframe 
internal.fluxes = dataframe.internalfluxes(GWModel2D_river)
#select from this dataframe data containing From node 252 to a neighbor node
node252.internal.flux = internal.fluxes[which(internal.fluxes$node1 == 252),names(internal.fluxes) %in% c("node2","flux1to2","totflux1to2")]
print(node252.internal.flux)
```



</div>

# 6. Flow through a dike

In the last part of this assignment, flow through a dike will be modeled, in a situation similar to figure 2.

<div align="center">
![Figure 2: Photo of a Dutch dike (source:beeldbank.rws.nl rijkswaterstaat.](dike_beeldbank_rws.png)
</div>

In figure 3 a schematized vertical cross section of a dike is presented. Note the different scale of the y-direction compared to the x-direction. From figure 3 can be seen that the y-to-x-ratio is not equal to one. This can be graphically observed in this particular case, but this is not always so clear. Be aware that this y-to-x-ratio exists in this model. 

<div align="center">
![Figure 3: Schematized vertical dike cross section.](DikeDomain.png)
</div>


<div class="exercise">
27. Define the model domain in a new R-code chunk, as illustrated in figure 3, and plot the new domain. Firstly, clear the defined objects from the work space to prevent unwanted interference with previous model simulations. What is the y-to-x-ratio in this example?
</div>

<button type="button" onclick="showHint(4007)">Show Hint</button>
<p id="Q4007"> </p>

<div class="student_answer">
Fill in your answer here...
</div>


<div class="comment">
**[GB]**moet hieronder de rm(list=ls()) weer terug (na sandbox)?
</div>


<div class=answer>
27. The y-to-x-ratio in this example is 5.
```{r}
#rm(list=ls())

# Domain corners
P1 = c(0,0)
P2 = c(10,0)
P3 = c(10,1)
P4 = c(8,2)
P5 = c(1.4,2)
P6 = c(0,0.5)

# Define domain
domain = matrix(c(P1,P2,P3,P4,P5,P6), ncol=2, byrow=TRUE)

# Create plot and define the domain range.
plot(c(0,10), c(0,2), xlab="x", ylab="y", col="white")
# Plot domain polygon.
polygon(domain, lwd=3, col=rgb(0.7,0.7,0.7,0.3))
grid()
```
</div>

## 6.1 Unsaturated flow  

While having a constant value for the saturated zone, the hydraulic conductivity is highly non-linear in the unsaturated zone and depends strongly on moisture content en pressure forces.

The hydraulic conductivity depends on the *pressure* head and **not** the *hydraulic* head which is currently the state.
The relation is simple and straight forward;

$$
H = \psi + z\\
\psi = H - z
$$


With:  

$H$: Hydraulic head (m)  

$\psi$: Pressure head (m)  

$z$: Elevation head (m)  

Figure 4 illustrates the relation between these variables. Imagine a bucket with a height of 1 meter and filled with water. The reference head (green line) equals 0.0 m at the bottom of the bucket, but the pressure head (red line) equals 1.0 m. The hydraulic head is a constant being 1.0 m (blue line). Suppose you would measure the pressure head at a height 0.20 m from the bottom. This would be 0.80 m (intersection point dashed line and red line). The elevation head is 0.20 m (intersection point dashed line and green line). Summing pressure head and elevation head results in the hydraulic head: $H=\psi+z=0.8+0.2=1.0 \, m$ over the whole depth.

![](HydraulicHead.png)

Figure 4: Elevation and pressure heads in a bucket.

In the unsaturated zone above the water table, the situation is different compared to the saturated groundwater model we constructed before:  

*   The hydraulic conductivity $k$ is no longer constant but dependent on the pressure head (and moisture content);   
*   The pressure head $\psi$ is now a negative number, when above the groundwater table, and can be interpreted as 'suction'.   

In the table below the relation between hydraulic conductivity and pressure is presented for a 'loamy sand'.   
Data is based on the so called "Staring series".

Table of $k(\psi)$ data

soil type| -1| -10| -20| -31| -50| -100| -250| -500| -1000|-2500|-5000|-10000|-16000 
---------|---|----|----|----|----|-----|-----|-----|------|-----|-----|------|-----
B2| 33.34|4.56| 2.42| 1.38|0.77|0.14|8.4E-3|1.9E-3|6.3E-4|1.7E-4|6.2E-5|2.7E-5|1.2E-5

This $k(\psi)$  relation will be turned into a function:

```{r}
psi.set = c(-1,-10,-20,-31,-50,-100,-250,-500,-1000,-2500,-5000,-10000,-16000)
k.set = c(33.34,4.56, 2.42, 1.38,0.77,0.14,8.4E-3,1.9E-3,6.3E-4,1.7E-4,6.2E-5,2.7E-5,1.2E-5)/100
k_psi = approxfun(psi.set,k.set,rule=2)
psi.pF = seq(4,0,length.out = 100)
plot(psi.pF,k_psi(-10^psi.pF),type = "l",lwd=3,col="blue",
     xlab = "pressure in pF (-log(psi) in cm)", ylab= "k(psi) m/d",
     main = c("k(psi) function for a loamy sand, based on B2 Staring series"))
#points(log10(-psi.set),k.set)
grid()
```


Comparing the internal flux for flow in the saturated zone with the internal flux for simulating unsaturated conditions show that they are identical except for the hydraulic conductivity.
As illustrated in the previous plot, the more a negative pressure (and also less moisture) is encountered in the soil, the lower the hydraulic conductivity. When the suction is in the order of -100 (pF=2) or less/more negative, conductivities become very small, resulting is very low fluxes most of the time.

The internal flux for flow in  the unsaturated zone is therefor highly non-linear:

$q_{s} = -k(\psi=H-z)\frac{\partial H}{\partial s}$

With:  

* $s$:    spatial coordinate (x or y/z) (m)  


```{r}
# Internal flux function.
grad.flux = function(x, y, state, grad)
{
  return(-k_psi(100*(state - y))*grad)
}
```


<div class="question">
28. Why should the (state - y) be multiplied by 100?  
</div>


<div class="answer">
28. It's simply the transformation from meter(the states) and centimeter for the `k_spi` function where the $\psi$ is in centimeters. It has a historical background.
</div>


Next, several boundary conditions have to be defined. The boundaries should be implemented as follows:

* Line segment (0,0)-(0,0.5) is assigned a fixed state of 0.5 $m$
* Line segment (10,0)-(10,1) is assigned a fixed state of 1.0 $m$
* The horizontal top of the dike receives a recharge flux of 0.001 $m/day$

<div class="exercise">
28. Create a new model and add the boundary conditions described above. Give an interpretation for each of these boundary conditions. What boundary condition is used on the remaining boundary segments?
</div>

<button type="button" onclick="showHint(4008)">Show Hint</button>
<p id="Q4008"> </p>

<div class="student_answer">
Fill in your answer here...
```{r}
# =newFLOW2D()
# plot.BC.id()
#set.BC...
#set.BC...
#set.BC...
```

</div>

<div class="answer">

28. Boundary conditions:  

* East & west:  A hydrostatic water depth on both sides of the dike
* Top:          Rainfall infiltrating into the dike
* Unspecified:  No-flux boundaries, so impermeable surface

```{r}
# new model object.
DikeFlow = newFLOW2D(domain=domain, grad.flux, "Dike Flow")

plot.BC.id(DikeFlow)

set.BC.fixedstate(DikeFlow, 2, 1)
set.BC.fixedstate(DikeFlow, 6, 0.5)
set.BC.fixedflux(DikeFlow, 4, 0.001)
```
</div>

<div class="exercise">
29. Add a proper discretization in the model.  

Use for this the `geomden` method, with an `opdist` of 0.5 and the proper y-to-x-ratio.  
Use the Finite Volumes discretisation method.  
Add a randomly filled plot of the discretised domain.
</div>

<div class="student_answer">
Fill in your answer here...
```{r}
#set.discretisation()


```
</div>

<div class="answer">

29. Using the ytoxratio = 5, gives an evenly distribution of nodes in the domain although length and height scale are different.
```{r}
# Set the discretisation.
set.discretisation(DikeFlow, nodes=list(type="geomgen", optdist=0.5, ytoxratio=5, verbose=FALSE), method="FV")
# Randomly filled plot.
plot(DikeFlow, fill="random", fill.border="black")
```
</div>

<div class="exercise">
30. Since the hydraulic conductivity is highly non-linear, it is good practice to initialize the model with reasonable heads first.  

* Initialize the model with a hydraulic head of 2.0 m.
* Solve/run the model. 
* Make a plot with 10 contour lines for the head distribution and add flux vectors.  
* Calculate the (water)balance for the model

Where do you observe the largest fluxes?  

TIP: Have a look at the plot help of the FVFE2D package for all plot options.
</div>

<div class="student_answer">
Fill in your answer here...
```{r}
#do.initialise()
#solve.stepts()
#plot(xx,fill.contours = )
#datframe.balance()
```

</div>

<div class="answer">
30. The largest flux is observed at the lower west boundary, where all the water is forced through a relatively small surface. The highest flux density is observed here. The length of these vectors represent the magnitude of the flux. The arrows point in the direction of the flow.
```{r}
#initiailize with fully saturated conditions
do.initialize(DikeFlow,2.00)
# Solve
solve.steps(DikeFlow, MAMcrit = 1e-6,RMSMcrit = 1e-9,verboselevel = 1)
 # Plotting
state.range = range(dataframe.states(DikeFlow)$state)
plot(DikeFlow, fill="state", fill.contours=seq(state.range[1],state.range[2], length=10), fill.name="head", fluxvecsize=1)
dataframe.balance(DikeFlow)
```
</div>


More interesting is to have a look at the pressure head distribution and the distribution of the hydraulic conductivity.
To plot this, one needs to create a $psi(x,z)$ and a $k(\psi)$ function first.  

<div class="question">
31.  For some further analysis of the result;  

* Create a $\psi_{x,z}$ and $k(\psi)_{x,z}$ function to be used with the plot function of FVFE2D.   
* Create both plots  
* Add one contour indicating the water table in the $\psi_{x,z}$ plot.
```{r}
##the psi function for plotting
# psi.func = function(x,y,state)
# {
#   # 
# }

##the k.psi function for plotting
# k.func = function(x,y,state)
# {
#   # 
# }
#plot(xx,fill = current.psi)

```
</div>

<div class="answer">
31. see the following code chunk;
```{r}
psi.func = function(x,y,state)
{
  return(100*(state - y))
}
k.func = function(x,y,state)
{
  return(k_psi(100*(state - y)))
}
plot(DikeFlow,fill = psi.func,fill.contours = c(0),main.title = "Pressure head in cm. and groundwater table")
plot(DikeFlow,fill = k.func,main.title = "Hydraulic condcutivity (m/d)")
```
</div>

<div class="question">
32. Create a copy of the Dike model and redo 29 and 30 with the same discretization but now with the FE method. Use just the simplest one: `"FE"`.  
Create the same plots for $\psi_{x,z}$ and $k(\psi)_{x,z}$

```{r}
#DikeFlow_FE = copy.model(DikeFlow)
#setdiscritisation(xx,method = "FE")
#do.initialize(xx,2.00)
#solve.steps()
#plot(xx,fill = psi.func,)
#plot(xx, fill = k.func)
```
</div>

<div class="answer">
32. see the chunk below

```{r}
DikeFlow_FE = copy.model(DikeFlow)
set.discretisation(DikeFlow_FE, nodes=list(type="geomgen", optdist=0.5, ytoxratio=5, verbose=FALSE), method="FE")
plot(DikeFlow_FE,fill = "random",main.title = "Finite Elements Discretisation")
do.initialize(DikeFlow_FE,2.0)
solve.steps(DikeFlow_FE)
state.range = range(dataframe.states(DikeFlow_FE)$state)
plot(DikeFlow_FE, fill="state", fill.contours=seq(state.range[1],state.range[2], length=10), fill.name="head", fluxvecsize=1)
dataframe.balance(DikeFlow_FE)
plot(DikeFlow_FE,fill = psi.func, fill.contour=c(0))
plot(DikeFlow_FE,fill = k.func)
```
</div>

<div class="question">
33. Compare both discretisation focussing on the (water) balance and the distribution of the hydraulic conductivity.  
For comparing the $k(\psi)$ plots in both models, simply plot both distributions in a new window (left option of three in the upper right corner of the plots in the Rmd)
Can you argue why the result are different?
</div>

<div class="student_answer">
Fill out your answer here.
</div>

<div class="answer">
33. Comparing the FV en FE results;  
Looking at the (water) balance; With the FV model, total outflow seems larger compared to the FE model. Since the recharge rate is the same for both, lateral flow is larger for the FV model.  
Having a look at the distribution of the hydraulic conductivities in the model; for the FV model only one strip of volumes located at the water table ($\psi = 0$) have clear different conductivities compared to the volumes above(low conductivities) and volumes below the water table, having all the saturated conductivity.  
For the FE model conductivities are more spread around the water table which makes it less 'easy' for this model to discharge water towards the left (west) side of the dike.
</div>



This concludes the last FVFE assignments

<!-- include the hint.js -->
<script src="hints_n.js"></script>
