---
title: "The Lorenz equations: why is the weather unpredictable?"
author: "Chiel van Heerwaarden"
date: "1/22/2019"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
library(plotly)
library(wavethresh)
```

## Introduction

```{R begin_state}
# Function that gives the states for the first time-step
calc_init_state = function(x)
{
  # Gaussian distribution
  exp(-(x-L/2)^2 / 2^2)
}
```

```{R problem_definition}
u = 1.
bl = 0.
br = 0.
L = 100.
end_time = 100.

# Compute reference line
init_state_x = seq(from=0, to=L, by=0.01)
init_state = calc_init_state(init_state_x)
```

```{R lecture_method}
omega = 0.5 # Crank-Nicholson
dx = 0.2
dt = 0.2

# Calculation preparation
n_time = round(end_time / dt)
N = L/dx
x = seq(from=0, by=dx, length.out=N)
state = calc_init_state(x)

M = matrix(0., nrow=N, ncol=N)

M[1, N] =  u/(2*dx)
M[1, 2] = -u/(2*dx)

for (i in 2:(N-1))
{
  M[i, i-1] =  u/(2*dx)
  M[i, i  ] = 0.
  M[i, i+1] = -u/(2*dx)
}

M[N, N-1] =  u/(2*dx)
M[N, 1  ] = -u/(2*dx)

I = diag(N)

# Define the matrices to avoid unnecessary computations.
N_rhs = (I + omega     * dt * M)
N_lhs = (I - (1-omega) * dt * M)

# Set the dirichlet BC in N_left.
# It is essential to do this AFTER the computation of N_left,
# otherwise there will be a row with zeros left.
N_lhs[1, 1] = 1
N_lhs[N, N] = 1

N_inv = solve(N_lhs)

# Time stepping variable.
time = 0.

for (i in (1:n_time))
{
  # Evaluate the righthand side.
  v = N_rhs %*% state
  
  # Compute the new state.
  new_state = N_inv %*% v
  
  # update the time and the state.
  time = time + dt
  state = new_state
}

# Store the results for this method.
cn_2nd_x = x
cn_2nd_state = state
```

```{R fft}
omega = 0.5 # Crank-Nicholson
dx = 1.
dt = 0.01

# Calculation preparation
n_time = round(end_time / dt)
N = L/dx
x = seq(from=0, by=dx, length.out=N)
state = calc_init_state(x)

# Time stepping variable.
time = 0.

k = seq(from=0, to=N-1)
k[(N/2):N] = k[(N/2):N] - length(k)
k = 2.*pi*k/L

for (i in (1:n_time))
{
  # Evaluate the righthand side.
  rhs = -u * Re(fft(1i*k*fft(state), inverse=TRUE) / length(state))

  # Compute the new state.
  new_state = state + dt*rhs
  
  # update the time and the state.
  time = time + dt
  state = new_state
}

# Store the results for this method.
cn_fft_x = x
cn_fft_state = state
```

```{r message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = add_trace(p, x=cn_2nd_x, y=cn_2nd_state, name='cn_2nd', mode='lines')
p = add_trace(p, x=cn_fft_x, y=cn_fft_state, name='cn_fft', mode='lines')
p = add_trace(p, x=init_state_x, y=init_state, name='ref', mode='lines', line=init_line)
p
```

## The challenge



## The tasks
1. Bla.

**END OF ASSIGNMENT**

