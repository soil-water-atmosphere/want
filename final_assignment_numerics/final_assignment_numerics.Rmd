---
title: "Advanced numerics: advection-diffusion with high accuracy"
author: "Chiel van Heerwaarden"
date: "1/22/2019"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
library(plotly)
library(wavethresh)
```

## Introduction

```{R begin_state}
# Function that gives the states for the first time-step
calc_init_state = function(x)
{
  # Gaussian distribution
  exp(-(x-L/2)^2 / 2^2)
}
```

```{R problem_definition}
u = 1.
bl = 0.
br = 0.
L = 100.
end_time = 100.

# Compute reference line
init_state_x = seq(from=0, to=L, by=0.01)
init_state = calc_init_state(init_state_x)
```

```{R lecture_method}
omega = 0.5
dx = 1.
dt = 0.1

# Calculation preparation
n_time = round(end_time / dt)
N = L/dx
x = seq(from=0, by=dx, length.out=N)
state = calc_init_state(x)

M = matrix(0., nrow=N, ncol=N)

M[1, N] =  u/(2*dx)
M[1, 2] = -u/(2*dx)

for (i in 2:(N-1))
{
  M[i, i-1] =  u/(2*dx)
  M[i, i+1] = -u/(2*dx)
}

M[N, N-1] =  u/(2*dx)
M[N, 1  ] = -u/(2*dx)

I = diag(N)

# Define the matrices to avoid unnecessary computations.
N_rhs = (I + omega     * dt * M)
N_lhs = (I - (1-omega) * dt * M)

# Set the dirichlet BC in N_left.
# It is essential to do this AFTER the computation of N_left,
# otherwise there will be a row with zeros left.
N_lhs[1, 1] = 1
N_lhs[N, N] = 1

N_inv = solve(N_lhs)

# Time stepping variable.
time = 0.

for (i in (1:n_time))
{
  # Evaluate the righthand side.
  v = N_rhs %*% state
  
  # Compute the new state.
  new_state = N_inv %*% v
  
  # update the time and the state.
  time = time + dt
  state = new_state
}

# Store the results for this method.
cn_2nd_x = x
cn_2nd_state = state
```

```{R lecture_method}
omega = 0.5
dx = 1.
dt = 0.1

# Calculation preparation
n_time = round(end_time / dt)
N = L/dx
x = seq(from=0, by=dx, length.out=N)
state = calc_init_state(x)

M = matrix(0., nrow=N, ncol=N)

M[1, N-2] =  1./12.
M[1, N-1] = -2./ 3.
M[1, 2  ] =  2./ 3.
M[1, 3  ] = -1./12.

M[2, N-1] =  1./12.
M[2, 1  ] = -2./ 3.
M[2, 3  ] =  2./ 3.
M[2, 4  ] = -1./12.

for (i in 3:(N-2))
{
  M[i, i-2] =  1./12.
  M[i, i-1] = -2./ 3.
  M[i, i+1] =  2./ 3.
  M[i, i-2] = -1./12.
}

M[N-1, N-3] =  1./12.
M[N-1, N-2] = -2./ 3.
M[N-1, N  ] =  2./ 3.
M[N-1, 1  ] = -1./12.

M[N, N-2] =  1./12.
M[N, N-1] = -2./ 3.
M[N, 1  ] =  2./ 3.
M[N, 2  ] = -1./12.

M = - u/dx * M

I = diag(N)

# Define the matrices to avoid unnecessary computations.
N_rhs = (I + omega     * dt * M)
N_lhs = (I - (1-omega) * dt * M)

# Set the dirichlet BC in N_left.
# It is essential to do this AFTER the computation of N_left,
# otherwise there will be a row with zeros left.
N_lhs[1, 1] = 1
N_lhs[N, N] = 1

N_inv = solve(N_lhs)

# Time stepping variable.
time = 0.

for (i in (1:n_time))
{
  # Evaluate the righthand side.
  v = N_rhs %*% state
  
  # Compute the new state.
  new_state = N_inv %*% v
  
  # update the time and the state.
  time = time + dt
  state = new_state
}

# Store the results for this method.
cn_2nd_x = x
cn_2nd_state = state
```

```{R fft}
omega = 0.5
dx = 1.
dt = 0.1

# Calculation preparation
n_time = round(end_time / dt)
N = L/dx
x = seq(from=0, by=dx, length.out=N)
state = calc_init_state(x)

# Time stepping variable.
time = 0.

k = seq(from=0, to=N-1)
k[(N/2):N] = k[(N/2):N] - length(k)
k = 2.*pi*k/L

state_fft = fft(state)

for (i in (1:n_time))
{
  # Compute the new state.
  new_state_fft = (1. - omega*dt*u*1i*k) / (1. + (1.-omega)*dt*u*1i*k) * state_fft
  
  # update the time and the state.
  time = time + dt
  state_fft = new_state_fft
}

state = Re(fft(state_fft, inverse=TRUE) / length(state))

# Store the results for this method.
cn_fft_x = x
cn_fft_state = state
```

```{r message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = add_trace(p, x=cn_2nd_x, y=cn_2nd_state, name='cn_2nd', mode='lines')
p = add_trace(p, x=cn_fft_x, y=cn_fft_state, name='cn_fft', mode='lines')
p = add_trace(p, x=init_state_x, y=init_state, name='ref', mode='lines', line=init_line)
p
```

## The challenge



## The tasks
1. Bla.

**END OF ASSIGNMENT**

