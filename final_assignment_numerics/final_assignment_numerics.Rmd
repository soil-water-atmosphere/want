---
title: "Advanced numerics: advection-diffusion with high spatial accuracy"
author: "Chiel van Heerwaarden"
date: "1/22/2019"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
library(plotly)
```

## Introduction

```{R ref_functions}
# Generate gaussian in middle of domain.
calc_init_state = function(x)
{
  sigma = 1.
  exp(-(x-L/2)^2 / (2*sigma^2))
}

calc_error = function(df, n=1)
{
  error_vec = abs(df$state - calc_init_state(df$x))^n
  error = (sum(error_vec))^(1./n)
  return(error)
}
```

```{R problem_definition}
u = 1.
bl = 0.
br = 0.
L = 100.
end_time = 100.

# Compute reference line to compare solutions against.
ref = data.frame(x=seq(from=0, to=L, by=0.01))
ref$state = calc_init_state(ref$x)
```

```{R cn_2nd}
solve_cn_2nd = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M = matrix(0., nrow=N, ncol=N)
  
  M[1, N] = -1./2.
  M[1, 2] =  1./2.
  
  for (i in 2:(N-1))
  {
    M[i, i-1] = -1./2.
    M[i, i+1] =  1./2.
  }
  
  M[N, N-1] = -1./2.
  M[N, 1  ] =  1./2.
  
  M = - u/dx * M
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I + omega     * dt * M)
  N_lhs = (I - (1-omega) * dt * M)
  N_inv = solve(N_lhs)
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, state=state))
}

cn_2nd = solve_cn_2nd(omega=0.5, dx=0.5, dt=0.1)
```

```{R cn_4th}
solve_cn_4th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M = matrix(0., nrow=N, ncol=N)
  
  M[1, N-1] =  1./12.
  M[1, N  ] = -2./ 3.
  M[1, 2  ] =  2./ 3.
  M[1, 3  ] = -1./12.
  
  M[2, N] =  1./12.
  M[2, 1] = -2./ 3.
  M[2, 3] =  2./ 3.
  M[2, 4] = -1./12.
  
  for (i in 3:(N-2))
  {
    M[i, i-2] =  1./12.
    M[i, i-1] = -2./ 3.
    M[i, i+1] =  2./ 3.
    M[i, i+2] = -1./12.
  }
  
  M[N-1, N-3] =  1./12.
  M[N-1, N-2] = -2./ 3.
  M[N-1, N  ] =  2./ 3.
  M[N-1, 1  ] = -1./12.
  
  M[N, N-2] =  1./12.
  M[N, N-1] = -2./ 3.
  M[N, 1  ] =  2./ 3.
  M[N, 2  ] = -1./12.
  
  M = - u/dx * M
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I + omega     * dt * M)
  N_lhs = (I - (1-omega) * dt * M)
  N_inv = solve(N_lhs)
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, state=state))
}
```

```{R cn_pade_4th}
solve_cn_pade_4th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M_a = matrix(0., nrow=N, ncol=N)
  M_alpha = matrix(0., nrow=N, ncol=N)
  
  M_a[1, N] = -3./4.
  M_a[1, 2] =  3./4.
  
  for (i in 2:(N-1))
  {
    M_a[i, i-1] = -3./4.
    M_a[i, i+1] =  3./4.
  }
  
  M_a[N, N-1] = -3./4.
  M_a[N, 1  ] =  3./4.
  
  M_alpha[1, N] = 1./4.
  M_alpha[1, 1] = 1.
  M_alpha[1, 2] = 1./4.
  
  for (i in 2:(N-1))
  {
    M_alpha[i, i-1] = 1./4.
    M_alpha[i, i  ] = 1.
    M_alpha[i, i+1] = 1./4.
  }
  
  M_alpha[N, N-1] = 1./4.
  M_alpha[N, N  ] = 1.
  M_alpha[N, 1  ] = 1./4.
  
  M = - u * solve(M_alpha) %*% (M_a/dx)
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I + omega     * dt * M)
  N_lhs = (I - (1-omega) * dt * M)
  N_inv = solve(N_lhs)
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, state=state))
}
```

```{R cn_pade_6th}
solve_cn_pade_6th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M_a = matrix(0., nrow=N, ncol=N)
  M_alpha = matrix(0., nrow=N, ncol=N)
  
  M_a[1, N-1] =  -1./36.
  M_a[1, N  ] = -14./18.
  M_a[1, 2  ] =  14./18
  M_a[1, 3  ] =   1./36.
  
  M_a[2, N] =  -1./36.
  M_a[2, 1] = -14./18
  M_a[2, 3] =  14./18
  M_a[2, 4] =   1./36.
  
  for (i in 3:(N-2))
  {
    M_a[i, i-2] =  -1./36.
    M_a[i, i-1] = -14./18
    M_a[i, i+1] =  14./18
    M_a[i, i+2] =   1./36.
  }
  
  M_a[N-1, N-3] =  -1./36.
  M_a[N-1, N-2] = -14./18
  M_a[N-1, N  ] =  14./18
  M_a[N-1, 1  ] =   1./36.
  
  M_a[N, N-2] =  -1./36.
  M_a[N, N-1] = -14./18
  M_a[N, 1  ] =  14./18
  M_a[N, 2  ] =   1./36.
  
  M_alpha[1, N] = 1./3.
  M_alpha[1, 1] = 1.
  M_alpha[1, 2] = 1./3.
  
  for (i in 2:(N-1))
  {
    M_alpha[i, i-1] = 1./3.
    M_alpha[i, i  ] = 1.
    M_alpha[i, i+1] = 1./3.
  }
  
  M_alpha[N, N-1] = 1./3.
  M_alpha[N, N  ] = 1.
  M_alpha[N, 1  ] = 1./3.
  
  M = - u * solve(M_alpha) %*% (M_a/dx)
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I + omega     * dt * M)
  N_lhs = (I - (1-omega) * dt * M)
  N_inv = solve(N_lhs)
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, state=state))
}
```

```{R cn_fft}
solve_cn_fft = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  # Time stepping variable.
  time = 0.
  
  k = seq(from=0, to=N-1)
  k[(N/2):N] = k[(N/2):N] - length(k)
  k = 2.*pi*k/L
  fac_rhs = omega*dt*u*1i*k
  fac_lhs = (1.-omega)*dt*u*1i*k
  
  state_fft = fft(state)
  
  for (i in (1:n_time))
  {
    # Compute the new state.
    new_state_fft = (1. - fac_rhs) / (1. + fac_lhs) * state_fft
    
    # Update the time and the state.
    time = time + dt
    state_fft = new_state_fft
  }
  
  state = Re(fft(state_fft, inverse=TRUE) / length(state))
  
  return(data.frame(x=x, state=state))
}
```

```{R run_solvers}
cn_2nd      = solve_cn_2nd      (omega=0.5, dx=0.5, dt=0.25)
cn_4th      = solve_cn_4th      (omega=0.5, dx=0.5, dt=0.25)
cn_pade_4th = solve_cn_pade_4th (omega=0.5, dx=0.5, dt=0.25)
cn_pade_6th = solve_cn_pade_6th (omega=0.5, dx=0.5, dt=0.25)
cn_fft      = solve_cn_fft      (omega=0.5, dx=0.5, dt=0.25)
```

```{R error}
print(calc_error(cn_2nd))
print(calc_error(cn_4th))
print(calc_error(cn_pade_4th))
print(calc_error(cn_pade_6th))
print(calc_error(cn_fft))
```

```{r message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = add_trace(p, x=cn_2nd$x, y=cn_2nd$state, name='cn_2nd', mode='lines')
p = add_trace(p, x=cn_4th$x, y=cn_4th$state, name='cn_4th', mode='lines')
p = add_trace(p, x=cn_pade_4th$x, y=cn_pade_4th$state, name='cn_pade_4th', mode='lines')
p = add_trace(p, x=cn_pade_6th$x, y=cn_pade_6th$state, name='cn_pade_6th', mode='lines')
p = add_trace(p, x=cn_fft$x, y=cn_fft$state, name='cn_fft', mode='lines')
p = add_trace(p, x=ref$x, y=ref$state, name='ref', mode='lines', line=init_line)
p
```

## The challenge
The peak needs to have a location between 49.9 and 50.1 and a state magnitude between 0.99 and 1.01.

## The tasks
1. Bla.

**END OF ASSIGNMENT**

