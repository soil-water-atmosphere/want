---
title: "Advanced numerics: advection with high spatial accuracy"
author: "Chiel van Heerwaarden"
date: "1/22/2019"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
library(plotly)
```

## Introduction
Hydrological and meteorological forecasting is often done under time pressure. Therefore, modelling is often done at a coarser grid spacing than one would ideally use. In the lectures, you have learned to derive first- (forward and backward) and second-order accurate discretizations. With more advanced methods that involve more than two grid points, it is possible to derive numerical schemes that are far more accurate than the schemes you have used thus far.

In this assignment, you will work with the linear advection equation

$$
\dfrac{\partial s}{\partial t} = - u \dfrac{\partial s}{\partial x}.
$$

You will work with a system in which a block is placed in the center of the domain and advected to the right. In order to avoid having to deal with boundary discretizations, everything that is advected out of the domain on the right, re-enters the domain on the left. The duration of the simulation will be chosen such that the block ends exactly at the same location as where it started. This we do with the settings below, we have a channel of 100 m, in which we advect the block around with 1 m s$^{-1}$ during 100 s.

```{R problem_definition}
u = 1.
L = 100.
end_time = 100.
```

In order to plot the block, we first define a set of helper functions for the entire assignment and then generate and plot the blob.

```{R ref_functions}
# Generate block in middle of domain.
calc_init_state = function(x)
{
  z = abs(x - L/2)
  1.e4 / (1.e4 + exp(1.4*z))
}

calc_init_state_derivative = function(x)
{
  eps = 0.0001
  (calc_init_state(x + eps) - calc_init_state(x - eps)) / (2.*eps)
}

# # Generate gaussian in middle of domain.
# sigma = 1.5
# 
# calc_init_state = function(x)
# {
#   exp(-(x-L/2)^2 / (2*sigma^2))
# }
# 
# calc_init_state_derivative = function(x)
# {
#   - (x - L/2)/(sigma^2) * exp(-(x-L/2)^2 / (2*sigma^2))
# }

calc_error = function(df, n=1.)
{
  error_vec = abs(df$state - calc_init_state(df$x))^n
  error = (sum(error_vec))^(1./n)
  return(error)
}
```

```{R reference_computation, message=FALSE, warning=FALSE}
# Compute reference line to compare solutions against.
ref = data.frame(x=seq(from=0, to=L, by=0.01))
ref$state = calc_init_state(ref$x)
ref$init_dstatedx = calc_init_state_derivative(ref$x)

init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = layout(p, yaxis=list(range = c(-0.4, 1.4)))
p = add_trace(p, x=ref$x, y=ref$state, name='ref', mode='lines', line=init_line)
p
```

Now, we will integrate the advection equation using the second-order centered discretization in space, combined with the Crank-Nicolson in time. The latter we will not touch in this assignment in order to constrain the degrees of freedom. Study the code below in detail, as this will be your starting point for implemenation of more advanced methods. Note that the code is written as a function, which enables you to call it multiple times with different settings. Also, note that the spatial derivative of the initial state is saved (here in `init_dstatedx`), which allows for evaluation of the spatial scheme alone.

```{R cn_2nd}
solve_cn_2nd = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M = matrix(0., nrow=N, ncol=N)
  
  M[1, N] = -1./2.
  M[1, 2] =  1./2.
  
  for (i in 2:(N-1))
  {
    M[i, i-1] = -1./2.
    M[i, i+1] =  1./2.
  }
  
  M[N, N-1] = -1./2.
  M[N, 1  ] =  1./2.
  
  M = M/dx
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I - omega     * dt * u * M)
  N_lhs = (I + (1-omega) * dt * u * M)
  N_inv = solve(N_lhs)
  
  # Solve the initial derivative for error checking of M
  init_dstatedx = M %*% state
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, init_dstatedx=init_dstatedx, state=state))
}

cn_2nd = solve_cn_2nd(omega=0.5, dx=0.5, dt=0.1)
```



<div class="student_answer">
```{R run_solvers}
cn_2nd = solve_cn_2nd(omega=0.5, dx=1., dt=0.5)
```
</div>

<div class="student_answer">
```{R error}
print(calc_error(cn_2nd, 2.))
```
</div>

<div class="student_answer">
```{R message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = add_trace(p, x=cn_2nd$x, y=cn_2nd$init_dstatedx, name='cn_2nd', mode='lines')
p = add_trace(p, x=ref$x, y=ref$init_dstatedx, name='ref', mode='lines', line=init_line)
p
```
</div>

<div class="student_answer">
```{R message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = layout(p, yaxis=list(range = c(-0.4, 1.4)))
p = add_trace(p, x=cn_2nd$x, y=cn_2nd$state, name='cn_2nd', mode='lines')
p = add_trace(p, x=ref$x, y=ref$state, name='ref', mode='lines', line=init_line)
p
```
</div>

<div class="answer">
```{R cn_4th}
solve_cn_4th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M = matrix(0., nrow=N, ncol=N)
  
  M[1, N-1] =  1./12.
  M[1, N  ] = -2./ 3.
  M[1, 2  ] =  2./ 3.
  M[1, 3  ] = -1./12.
  
  M[2, N] =  1./12.
  M[2, 1] = -2./ 3.
  M[2, 3] =  2./ 3.
  M[2, 4] = -1./12.
  
  for (i in 3:(N-2))
  {
    M[i, i-2] =  1./12.
    M[i, i-1] = -2./ 3.
    M[i, i+1] =  2./ 3.
    M[i, i+2] = -1./12.
  }
  
  M[N-1, N-3] =  1./12.
  M[N-1, N-2] = -2./ 3.
  M[N-1, N  ] =  2./ 3.
  M[N-1, 1  ] = -1./12.
  
  M[N, N-2] =  1./12.
  M[N, N-1] = -2./ 3.
  M[N, 1  ] =  2./ 3.
  M[N, 2  ] = -1./12.
  
  M = M / dx
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I - omega     * dt * u * M)
  N_lhs = (I + (1-omega) * dt * u * M)
  N_inv = solve(N_lhs)
  
  # Solve the initial derivative for error checking of M
  init_dstatedx = M %*% state
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, init_dstatedx=init_dstatedx, state=state))
}
```
</div>

<div class="answer">
```{R cn_pade_4th}
solve_cn_pade_4th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M_a = matrix(0., nrow=N, ncol=N)
  M_alpha = matrix(0., nrow=N, ncol=N)
  
  M_a[1, N] = -3./4.
  M_a[1, 2] =  3./4.
  
  for (i in 2:(N-1))
  {
    M_a[i, i-1] = -3./4.
    M_a[i, i+1] =  3./4.
  }
  
  M_a[N, N-1] = -3./4.
  M_a[N, 1  ] =  3./4.
  
  M_alpha[1, N] = 1./4.
  M_alpha[1, 1] = 1.
  M_alpha[1, 2] = 1./4.
  
  for (i in 2:(N-1))
  {
    M_alpha[i, i-1] = 1./4.
    M_alpha[i, i  ] = 1.
    M_alpha[i, i+1] = 1./4.
  }
  
  M_alpha[N, N-1] = 1./4.
  M_alpha[N, N  ] = 1.
  M_alpha[N, 1  ] = 1./4.
  
  M = solve(M_alpha) %*% (M_a/dx)
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I - omega     * dt * u * M)
  N_lhs = (I + (1-omega) * dt * u * M)
  N_inv = solve(N_lhs)
  
  # Solve the initial derivative for error checking of M
  init_dstatedx = M %*% state
  
  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, init_dstatedx=init_dstatedx, state=state))
}
```
</div>

<div class="answer">
```{R cn_pade_6th}
solve_cn_pade_6th = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  M_a = matrix(0., nrow=N, ncol=N)
  M_alpha = matrix(0., nrow=N, ncol=N)
  
  M_a[1, N-1] =  -1./36.
  M_a[1, N  ] = -14./18.
  M_a[1, 2  ] =  14./18
  M_a[1, 3  ] =   1./36.
  
  M_a[2, N] =  -1./36.
  M_a[2, 1] = -14./18
  M_a[2, 3] =  14./18
  M_a[2, 4] =   1./36.
  
  for (i in 3:(N-2))
  {
    M_a[i, i-2] =  -1./36.
    M_a[i, i-1] = -14./18
    M_a[i, i+1] =  14./18
    M_a[i, i+2] =   1./36.
  }
  
  M_a[N-1, N-3] =  -1./36.
  M_a[N-1, N-2] = -14./18
  M_a[N-1, N  ] =  14./18
  M_a[N-1, 1  ] =   1./36.
  
  M_a[N, N-2] =  -1./36.
  M_a[N, N-1] = -14./18
  M_a[N, 1  ] =  14./18
  M_a[N, 2  ] =   1./36.
  
  M_alpha[1, N] = 1./3.
  M_alpha[1, 1] = 1.
  M_alpha[1, 2] = 1./3.
  
  for (i in 2:(N-1))
  {
    M_alpha[i, i-1] = 1./3.
    M_alpha[i, i  ] = 1.
    M_alpha[i, i+1] = 1./3.
  }
  
  M_alpha[N, N-1] = 1./3.
  M_alpha[N, N  ] = 1.
  M_alpha[N, 1  ] = 1./3.
  
  M = solve(M_alpha) %*% (M_a/dx)
  
  I = diag(N)
  
  # Define the matrices to avoid unnecessary computations.
  N_rhs = (I - omega     * dt * u * M)
  N_lhs = (I + (1-omega) * dt * u * M)
  N_inv = solve(N_lhs)
  
  # Solve the initial derivative for error checking of M
  init_dstatedx = M %*% state

  # Time stepping variable.
  time = 0.
  
  for (i in (1:n_time))
  {
    # Evaluate the righthand side.
    v = N_rhs %*% state
    
    # Compute the new state.
    new_state = N_inv %*% v
    
    # update the time and the state.
    time = time + dt
    state = new_state
  }
  
  return(data.frame(x=x, init_dstatedx=init_dstatedx, state=state))
}
```
</div>

<div class="answer">
```{R cn_fft}
solve_cn_fft = function(omega, dx, dt)
{
  # Calculation preparation
  n_time = round(end_time / dt)
  N = L/dx
  x = seq(from=0, by=dx, length.out=N)
  state = calc_init_state(x)
  
  k = seq(from=0, to=N-1)
  k[(N/2):N] = k[(N/2):N] - length(k)
  k = 2.*pi*k/L
  fac_rhs = omega*dt*u*1i*k
  fac_lhs = (1.-omega)*dt*u*1i*k
  
  # Solve the initial derivative for error checking of fft procedure
  init_dstatedx = Re(fft(1i*k*fft(state), inverse=TRUE)) / length(state)
  
  # Time stepping variable.
  time = 0.

  # Fourier transform the state and solve model in spectral space.
  state_fft = fft(state)
  
  for (i in (1:n_time))
  {
    # Compute the new state.
    new_state_fft = (1. - fac_rhs) / (1. + fac_lhs) * state_fft
    
    # Update the time and the state.
    time = time + dt
    state_fft = new_state_fft
  }
  
  # Inverse Fourier transform the state.
  state = Re(fft(state_fft, inverse=TRUE)) / length(state)
  
  return(data.frame(x=x, init_dstatedx=init_dstatedx, state=state))
}
```
</div>

<div class="answer">
```{R run_solvers_answer}
cn_2nd      = solve_cn_2nd      (omega=0.5, dx=1., dt=0.5)
cn_4th      = solve_cn_4th      (omega=0.5, dx=1., dt=0.5)
cn_pade_4th = solve_cn_pade_4th (omega=0.5, dx=1., dt=0.5)
cn_pade_6th = solve_cn_pade_6th (omega=0.5, dx=1., dt=0.5)
cn_fft      = solve_cn_fft      (omega=0.5, dx=1., dt=0.5)
```
</div>

<div class="answer">
```{R error_answer}
print(calc_error(cn_2nd, 2.))
print(calc_error(cn_4th, 2.))
print(calc_error(cn_pade_4th, 2.))
print(calc_error(cn_pade_6th, 2.))
print(calc_error(cn_fft, 2.))
```
</div>

<div class="answer">
```{R message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = add_trace(p, x=cn_2nd$x, y=cn_2nd$init_dstatedx, name='cn_2nd', mode='lines')
p = add_trace(p, x=cn_4th$x, y=cn_4th$init_dstatedx, name='cn_4th', mode='lines')
p = add_trace(p, x=cn_pade_4th$x, y=cn_pade_4th$init_dstatedx, name='cn_pade_4th', mode='lines')
p = add_trace(p, x=cn_pade_6th$x, y=cn_pade_6th$init_dstatedx, name='cn_pade_6th', mode='lines')
p = add_trace(p, x=cn_fft$x, y=cn_fft$init_dstatedx, name='cn_fft', mode='lines')
p = add_trace(p, x=ref$x, y=ref$init_dstatedx, name='ref', mode='lines', line=init_line)
p
```
</div>

<div class="answer">
```{R message=FALSE, warning=FALSE}
init_line = list(color='black', dash='dot', width=1.5)
p = plot_ly()
p = layout(p, yaxis=list(range = c(-0.4, 1.4)))
p = add_trace(p, x=cn_2nd$x, y=cn_2nd$state, name='cn_2nd', mode='lines')
p = add_trace(p, x=cn_4th$x, y=cn_4th$state, name='cn_4th', mode='lines')
p = add_trace(p, x=cn_pade_4th$x, y=cn_pade_4th$state, name='cn_pade_4th', mode='lines')
p = add_trace(p, x=cn_pade_6th$x, y=cn_pade_6th$state, name='cn_pade_6th', mode='lines')
p = add_trace(p, x=cn_fft$x, y=cn_fft$state, name='cn_fft', mode='lines')
p = add_trace(p, x=ref$x, y=ref$state, name='ref', mode='lines', line=init_line)
p
```
</div>

**END OF ASSIGNMENT**

