---
title: "Finite differences 3"
author: "The WANT team"
date: "24/09/2018"
output:
  html_document:
    css: ../../want.css
    toc: yes
    toc_depth: 2
  pdf_document:
    toc: yes
    toc_depth: '2'
---
<!-- include the hint.js -->
<script src="../../hints.js"></script>

# Introduction
In this you will combine the topics of the previous two tutorials. Until now, you have dealt with system that have a state that is a function of time $s(t)$, as the emptying reservoir, as well as systems that are steady state in time $s(x)$, such as the stationary advection-diffusion equation. Here, you will analyze systems that have a state that is varying in time and space $s(x,t)$.

# Part 1 - Clarifying the last missing parts
## Section 1.1 - Notation
So far we have been using two different notations when talking about discretisation of equations. Namely the following;

$$
s[i]\\
s(x)\ \text{or} \ s(t)
$$
The first notation signifies the location in the corresponding matrix. $i$ is therefore always a positive integer. The second one is a specific value. It describes the state of a system at for example `x = 12.5` meters or the state at a specific time. When talking about space and time at the same time these notations tend to become quite cumbersome as you can see in the following example:

$$
s(x + \Delta x, t + \frac{1}{2}\Delta t)
$$
It's still understandable but with longer equations it can become hard to keep track of. To solve this issue we will use the following notation during this tutorial:

$$
s^{t + \frac{1}{2}\Delta t}_{x + \Delta x}
$$
This equation means exactly the same as the equation above but in a much shorter notation. The convention is to put time above and space below. The same goes for the matrix form:

$$
s^{n + 1}_{i}
$$
This equation means the state at the following time-step `n+1` (current time step: `n`) and at the current location `i`.

## Section 1.2 - Crank-Nicolson
The Crank-Nicolson methodology is another way of solving ODEs in time. What it does in simple words, it averages each time step the solution of an explicit and implicit scheme. In mathematical formulation it would look like this:

$$
\dfrac{ds(t)}{dt} = \frac{1}{2}f(t) + \frac{1}{2}f(t+\Delta t)
$$
A strategy that is often used to be able to solve the explicit, implicit and Crank-Nicolson (CN) scheme at once in an analitical way is to use the omega notation:

$$
\dfrac{ds(t)}{dt} = \omega (f(t)) + (1-\omega)f(t+\Delta t)
$$
This is a trick to solve all three at the same time. If you plug in $\omega = 1$ you get the explicit solution, $\omega = 0$ the implicit solution and $\omega = \frac{1}{2}$ the Crank-Nicolson version. This convention makes programming the three down the line much more convenient.

# Part 2 - The advection-diffusion equation revisited
## Section 2.1 - Setting up the equations
Back to the advection difussion equation, introduced in the second pratical. In the second pratical we worked with this equation only in the stationary case; $\dfrac{ds}{dt} = 0$. This is the full version of the equation.

$$\frac{\partial s}{\partial t} = -u \frac{\partial s}{\partial x} + D\frac{\partial^{2}s}{\partial x^{2}}$$

If you want, you can go to exercise 1 in the extended Rmd to discretise this equation yourself. Otherwise you can follow along in this section. 

### Discretisation
The first step in the discretisation is choosing the differencing scheme for the time and space derivatives. An often used approach is the forward in time and central in space scheme (FTCS scheme). We will follow that scheme here.

First we apply the forward scheme in time (first in the original notation and than in the short notation of section 1.1:
$$
\dfrac{ds}{dt} = \dfrac{s(t+\Delta t) - s(t)}{\Delta t} = f(t,s(t))\\
\dfrac{s^{n+1}_{i} - s^{n}_{i}}{\Delta t} = f(t,s(t))
$$

The second step is the realisation that the omega implementation (as discussed in section 1.2) will change the right-hand side of this equation to:

$$
\dfrac{s^{n+1}_{i} - s^{n}_{i}}{\Delta t} = \omega\ f(t,s(t)) + (1-\omega)\ f(t+\Delta t,s(t+\Delta t))
$$

<span class="question">
2.1.1 Complete the equation above by using the central scheme for both the first and second order derivative in space. 
</span>

<span class="answer">
$$
\dfrac{s^{n+1}_i - s^{n}_{i}}{\Delta t} = \omega\ (-u\dfrac{s^{n}_{i+1}-s^{n}_{i-1}}{2\Delta x} + D\dfrac{s^{n}_{i-1}-2s^{n}_{i}+s^{n}_{i+1}}{\Delta x^2}) + (1-\omega)(-u\dfrac{s^{n+1}_{i+1}-s^{n+1}_{i-1}}{2\Delta x} + D\dfrac{s^{n+1}_{i-1}-2s^{n+1}_{i}+s^{n+1}_{i+1}}{\Delta x^2})
$$ 
</span>

The final result of this discretisation is the matrix equation
$$M*s^{n+1} = V$$
In order to achieve that the answer of question 2.1.1 can be rewritten in the form:

$$
As^{n+1}_{i-1} + Bs^{n+1}_{i} + Cs^{n+1}_{i+1} = E
$$

<span class="question">
2.1.2 Rewrite the equation obtained in question 2.1.1 in the form above. Find the coefficients A,B,C and E. TIP!: move as a first step all states of the next time step to the left-hand side and the states of the current time step to the right-hand side;
$$
f(s^{n+1}) = g(s^{n})
$$
</span>

<span class="answer">
$$
As^{n+1}_{i-1} = -(1-\omega)(-u\dfrac{-s^{n+1}_{i-1}}{2\Delta x} + D\dfrac{s^{n+1}_{i-1}}{\Delta x^2})\\
A = (\omega-1)(\dfrac{u}{2\Delta x} + \dfrac{D}{\Delta x^2})
$$
$$
Bs^{n+1}_{i} = \dfrac{s^{n+1}_{i}}{\Delta t} - (1-\omega)(D\dfrac{-2s^{n+1}_{i}}{\Delta x^2})\\
B = \dfrac{1}{\Delta t} + (\omega-1)(\dfrac{-2D}{\Delta x^2})
$$
$$
Cs^{n+1}_{i+1} = -(1-\omega)(-u\dfrac{s^{n+1}_{i+1}}{2\Delta x} + D\dfrac{s^{n+1}_{i+1}}{\Delta x^2})\\
C = (\omega-1)(\dfrac{-u}{2\Delta x} + \dfrac{D}{\Delta x^2})
$$
$$
E = \dfrac{s^{n}_{i}}{\Delta t} + \omega\ (-u\dfrac{s^{n}_{i+1}-s^{n}_{i-1}}{2\Delta x} + D\dfrac{s^{n}_{i-1}-2s^{n}_{i}+s^{n}_{i+1}}{\Delta x^2})
$$
</span>

The matrix equation will then look like this:
$$
\begin{bmatrix}
1&.&.&.&.\\
A&B&C&.&.\\
.&A&B&C&.\\
.&.&A&B&C\\
.&.&.&.&1
\end{bmatrix} * 
\begin{bmatrix}
s^{n+1}_{1}\\
s^{n+1}_{2}\\
s^{n+1}_{3}\\
s^{n+1}_{4}\\
s^{n+1}_{5}
\end{bmatrix} = 
\begin{bmatrix}
b_l\\
E_2\\
E_3\\
E_4\\
b_r
\end{bmatrix}
$$

## Section 2.2 - Setting up the program
In the time practical, all calculations needed an initial state to calculate the future time-steps. To solve an equation in space and time, exactly the same initial state is needed. The difference is however, that a state on all locations needs to be given. The initial state is therefore a vector. 

A conventient initial state vector for the advection diffusion equation is a guassian distribution. This could be thought of as a wave going through the system.

<span class="question">
2.2.1 Run the following chunk and plot the `init.state` variable. 
```{R}
# Input variables
domain  = c(0,100)
endtime = 20
dx      = 1
dt      = 1
u       = 1
D       = 1
bl      = 0
br      = 0
omega   = 0

# Function that gives the states for the first time-step
initfun = function(x){
  # Gaussian distribution
  exp(-(x-domain[2]/2)^2/2^2)
}

# Calculation preparation
x           = seq(domain[1],domain[2],by=dx)
N           = length(x)
init.state  = initfun(x)
```
</span>

<span class="question">
2.2.2 Construct the matrix and invert it. Make use of the coefficients A,B and C defined in section 2.1.
</span>

<span class="answer">
```{R matrix_construction}
# MATRIX CONSTRUCTION
M = matrix(0,nrow=N,ncol=N)

# for now a dirichlet boundary is used for the solution
M[1,1] = 1
M[N,N] = 1
A      = (omega-1) * ( u/(2*dx) +   D/dx^2 )
B      = (omega-1) * (          - 2*D/dx^2 ) + 1/dt
C      = (omega-1) * (-u/(2*dx) +   D/dx^2 )

for(i in 2:(N-1)){
  M[i,i-1] = A
  M[i,i  ] = B
  M[i,i+1] = C
}

Minv = solve(M)
```
</span>

The hard track can go to exercise 1 in the extended Rmd to implement the time loop themselves. The rest can continue with the following questions.

<span class="question">
2.2.3 Fill in the XXX in the following chunk
</span>

<span class="student_answer">
```{R, eval=F}
# Time stepping variable
time        = 0
new.state   = init.state
plotlim     = c(-0.2,1.2)

while(time<endtime){
    plot(x,new.state,ylim=plotlim,type="l", xlab="x", ylab ="state")
    prev.state = new.state
    
    V    = c()
    V[1] = bl
    
    for(i in 2:(N-1))
    {
      V[i]= XXX
    }
    
    V[N] = br
    new.state = Minv %*% V
    
    time = time + dt
}
```
</span>

<span class="answer">
```{R}
# Time stepping variable
time        = 0
new.state   = init.state
plotlim     = c(-0.2,1.2)

while(time<endtime){
    plot(x,new.state,ylim=plotlim,type="l", xlab="x", ylab ="state")
    prev.state = new.state
    
    V    = c()
    V[1] = bl
    
    for(i in 2:(N-1))
    {
      V[i]= prev.state[i]/dt + omega*(-u*(prev.state[i+1]-prev.state[i-1])/(2*dx) +D*(prev.state[i+1]-2*prev.state[i]+prev.state[i-1])/dx^2)
    }
    
    V[N] = br
    new.state = Minv %*% V
    
    time = time + dt
}
```
</span>

## Section 2.3 - Stability of the solution
The advection-diffusion equation is an equation that tends to get unstable pretty fast. To examine this behaviour before performing the calculations two different parameters are used; the Von Neumann and Courant number. These are defined in the following way:

$$
V = \dfrac{2D\Delta t}{\Delta x^2}\\
C = \dfrac{u\Delta t}{\Delta x}
$$

<span class="question>
2.3.1 Fill in the following table by using the chunk below. Use the filled in part of the table as settings for the model and write the Von Neumann and Courant number down and classify the performence of the model as:

* Good (G)
* Wrong amplitude (A)
* Oscillating (O)
* Unstable (U)

</span>

<span class="student_answer">

u|D|$\Delta t$|$\Delta x$| Scheme|Von Neumann number (V) |Courant number (C)|Classification|
-|-|-|-|-|-|-|-|
1|0|1  |0.2|Implicit|.|.|.|
1|0|1  |0.2|Explicit|.|.|.|
1|0|1  |0.2|CN      |.|.|.|
1|1|1  |1  |Implicit|.|.|.|
1|1|1  |1  |Explicit|.|.|.|
1|1|1  |1  |CN      |.|.|.|
1|1|0.2|1  |Implicit|.|.|.|
1|1|0.2|1  |Explicit|.|.|.|
1|1|1  |0.1|Implicit|.|.|.|
1|1|1  |0.1|Explicit|.|.|.|
1|1|1  |2.5|Implicit|.|.|.|
1|1|1  |2.5|Explicit|.|.|.|

```{R advection_diffusion_app, eval=F,echo=F}
rm(list=ls())
library(plotly)
library(shiny)

### SOLVING THE ADVECTION DIFFUSION EQUATION WITH CN,EXPLICIT OR IMPLICIT SCHEME
# INPUT
solve_ad = function(domain=c(0,100),
                    endtime=20,
                    dx=1,
                    dt=1,
                    u=1,
                    D=1,
                    bl=0,
                    br=0,
                    omega=1,
                    initfun= function(x){
                      exp(-(x-domain[2]/2)^2/2^2)
                    },
                    delay = 200
                    ){
  # omega = 1   , explicit
  # omega = 0   , implicit
  # omega = 0.5 , CN
  
  # CALCULATION PREPARATION
  x           = seq(domain[1],domain[2],by=dx)
  N           = length(x)
  init.state  = initfun(x)
  
  # MATRIX CONSTRUCTION
  M = matrix(0,nrow=N,ncol=N)
  
  # for now a dirichlet boundary is used for the solution
  M[1,1] = 1
  M[N,N] = 1
  
  for(i in 2:(N-1)){
    M[i,i-1] = (omega-1) * ( u/(2*dx) +   D/dx^2 )
    M[i,i  ] = (omega-1) * (          - 2*D/dx^2 ) + 1/dt
    M[i,i+1] = (omega-1) * (-u/(2*dx) +   D/dx^2 )
  }
  
  Minv = solve(M) # this can be done in when the final calculation is done but this means that the inverting of matrix needs to be done over and over again
  
  # SET UP ANALITICAL SOLUTION
  a.x            = seq(domain[1],domain[2],length=500)
  sd0            = (domain[2]-domain[1])/200
  sampleweights  = initfun(a.x)
  a.init.state   = rep(0,length(a.x))  
  state.range    = range(init.state)
  
  for(i in 1:length(a.x))
  {
    a.init.state = a.init.state + 
      sampleweights[i]*dnorm(a.x,mean=a.x[i],sd=sd0)
  }
  
  sampleweights = sampleweights/max(a.init.state)*state.range[2]
  
  # STORE ANALITICAL RESULTS
  a.N           = length(a.x)
  steps         = seq(0,endtime,by=dt)
  Nsteps        = length(steps)-1
  a.steps       = rep(1:Nsteps,each=a.N)
  a.values      = rep(0,length=length(a.steps))
  a.domain      = rep(a.x,length=length(a.steps))
  
  solution = data.frame("step" = a.steps, "t" = a.steps*dt ,"x"= a.domain, "value" = a.values, "tvalue" = a.values)
  
  solution[solution$step == 1,]$tvalue = initfun(a.x)
  solution[solution$step == 1,]$value  = initfun(a.x)
  
  step       = 1
  new.state  = init.state
  time       = 0
  
  while(step<(Nsteps)){
    # analytical solution
    a.state = rep(0,length(a.x))
    for(i in 1:length(a.x))
    {
      a.state = a.state+ 
        sampleweights[i]*dnorm(a.x-u*time,mean=a.x[i],sd=sqrt(sd0^2+2*time*D))
    }
    
    # approximated solution
    prev.state = new.state
    
    V    = c()
    V[1] = bl
    
    for(i in 2:(N-1))
    {
      V[i]= prev.state[i]/dt + omega*(-u*(prev.state[i+1]-prev.state[i-1])/(2*dx)
                                      +D*(prev.state[i+1]-2*prev.state[i]+prev.state[i-1])/dx^2)
    }
    
    V[N] = br
    new.state = Minv %*% V
    
    step = step + 1
    time = time + dt
    
    newstate.fun = approxfun(x,new.state,rule=2)
    solution[solution$step == step,]$tvalue = a.state
    solution[solution$step == step,]$value  = newstate.fun(a.x)
  }
  
  # plotting
  state.length = state.range[2]-state.range[1]
  plotlim      = c(state.range[1]-0.2*state.length,state.range[2]+0.2*state.length)
  
  plot_ly(
    solution,
    x          = ~x,
    y          = ~tvalue,
    frame      = ~t,
    type       = "scatter",
    mode       = "lines",
    name       = "True solution",  
    line = list(
      color = 'lightgrey',
      width = 2
    )
  ) %>% 
    add_trace(
      y          = ~value,
      frame      = ~t,
      type       = "scatter",
      mode       = "lines",
      line = list(
        color = 'blue',
        width = 1
      ),
      name = "Approximation"
    ) %>%
    animation_opts(
      frame      = delay,
      transition = 0,
      easing     = "linear",
      redraw     = FALSE,
      mode       = "immediate"
    ) %>% 
    layout(
      xaxis      = list( title = "space",
                         range=a.x),
      yaxis      = list( title = "state",
                         range=plotlim)
    ) %>% 
    add_annotations(
      xref  = "paper",
      yref  = "paper",
      x     = 1,
      y     = 1,
      text  = paste("D = ", as.character(D) , "\n", "u = " , as.character(u)),
      showarrow = F,
      align = "left"
    ) %>% 
    add_annotations(
      xref  = "paper",
      yref  = "paper",
      x     = 0.05,
      y     = 1,
      align = "left",
      text  = (paste("omega = ", as.character(omega) , "\n", "dx = " , as.character(dx), "\n", "dt = " , as.character(dt), "\n\n", "V = " , as.character(round(2*D*dt/dx^2,3)),"\n", "C = " , as.character(round(u*dt/dx,3)))),
      showarrow = F
    ) %>%
    animation_slider(
      currentvalue = list(prefix = "t = ", font = list(color="darkblue"))
    )
}

#################SHINY###################
ui <- fluidPage(
  tags$head(
    tags$style(HTML("
                    h4 {
                    color: darkblue;
                    }
                    "))
    ),
  # App title ----
  titlePanel("Advection Diffusion Equation"),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    
    # Sidebar panel for inputs ----
    sidebarPanel(
      h4("Equation"),
      sliderInput("u", label = "u:",min = 0, max = 10, value = 1, step = 0.1),
      sliderInput("D", label = "D:",min = 0, max = 10, value = 1, step = 0.1),
      hr(),
      h4("Approximation settings"),
      sliderInput("dt", label = "dt:",min = 0.1, max = 10, value = 1, step = 0.1),
      sliderInput("dx", label = "dx:",min = 0.1, max = 10, value = 1, step = 0.1),
      div("Omega = 1 (Explicit)"         , style = "font-style:italic; font-size:7pt"),
      div("Omega = 0 (Implicit)"         , style = "font-style:italic; font-size:7pt"),
      div("Omega = 0.5 (Crank-Nicolson)" , style = "font-style:italic; font-size:7pt"),
      sliderInput("omega", "Time-integration scheme (omega):", min=0,max=1,value=0,step=0.1),
      hr(),
      h4("Plotting settings"),
      sliderInput("delay", label = "Delay between frames:",min = 0, max = 5000, value = 200, step = 50),
      sliderInput("endtime", label = "Runtime:",min = 1, max = 100, value = 20, step = 1),
      hr(),
      submitButton(text = "Apply Changes", icon = NULL, width = NULL)
      
    ),
    
    # Main panel for displaying outputs ----
    mainPanel(
      
      # Output: Plot of the requested variable against mpg ----
      plotlyOutput("p")
      
    )
  )
)

server <- function(input, output) {
  output$p  = renderPlotly({solve_ad(dt      = input$dt,
                                     dx      = input$dx,
                                     omega   = input$omega,
                                     u       = input$u,
                                     D       = input$D,
                                     delay   = input$delay,
                                     endtime = input$endtime)})
}

shinyApp(ui, server)
```

</span>

<span class="answer">

u|D|$\Delta t$|$\Delta x$| Scheme|Von Neumann number (V) |Courant number (C)|Classification|
-|-|-|-|-|-|-|-|
1|0|1  |0.2|Implicit|0   |5  |A|
1|0|1  |0.2|Explicit|0   |5  |U|
1|0|1  |0.2|CN      |0   |5  |O/A|
1|1|1  |1  |Implicit|2   |1  |A|
1|1|1  |1  |Explicit|2   |1  |U|
1|1|1  |1  |CN      |2   |1  |G|
1|1|0.2|1  |Implicit|0.4 |0.2|G|
1|1|0.2|1  |Explicit|0.4 |0.2|G|
1|1|1  |0.1|Implicit|200 |10 |A|
1|1|1  |0.1|Explicit|200 |10 |U|
1|1|1  |2.5|Implicit|0.32|0.4|G/A|
1|1|1  |2.5|Explicit|0.32|0.4|G/A|

</span>

<span class="question">
2.3.2 Explain the effect of the different values u,D, $\Delta t$,$\Delta x$ and the different schemes on the performance and stability of the solutions. TIP!: use the von Neumann and Courant number
</span>

<span class="answer">
Without diffusion the solutions gets unstable. Decrease $\Delta t$ and the solution gets more stable. Increase $\Delta x$ and the solution gets more stable. Implicit scheme is always stable but the amplitude tends to be too low. Explicit schemes tends to get unstable very fast. CN scheme lies in the middle. It doensn't really get unstable, the amplitude is quite okay, but the tail oscillates pretty easily.
</span>
