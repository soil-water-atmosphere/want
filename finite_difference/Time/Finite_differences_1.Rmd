---
title: "Tutorial 1: Finite differences in time"
author: "The WANT team"
date: "25/11/2018"
output:
  html_document:
    css: ../../want.css
    toc: yes
    toc_depth: 2
---
<!-- include the hint.js -->
<script src="../../hints.js"></script>

# Learning goals
After completing this tutorial you will:

* Understand the use of Taylor series.
* Understand the mathematics of Taylor series.
* Be able to calculate Taylor series for arbitrary functions.
* Derive approximations for first derivatives from Taylor series.
* Integrate ordinary differential equations (ODEs) in time using explicit methods.
* Integrate ordinary differential equations (ODEs) in time using implicit methods.
* Integrate ordinary differential equations (ODEs) in time using midpoint methods.
* Appreciate the concepts of numerical convergence, oscillation, and stability.

# Introduction
In this tutorial, you will analyse and develop models of ordinary differential equations (ODEs) that only depend on time. You will test the influence of parameter values and numerical schemes on the behavior of the solutions for simple 1D models, such as the emptying reservoir model (leaving out the spatial dimensions). This you will learn how to use Taylor series to develop such models using different techniques. You will also use Taylor series to estimate the errors of numerical models in order to judge their quality.

# Part 1 - Simple models in time
## Section 1.1 - Introduction ordinary differential equations
The first model that you will study, is that of an emptying bucket (see Figure). This is a very illustrative example, because this model has an analytical solution against which the outcome of the numerical models, that you will implement, can be compared (and it's intuitively understandable).

![](reservoir_properties.png) 

*Sketch of the emptying bucket*

This system can be represented by the following ODE:
$$ \dfrac{ds}{dt} = -\alpha s(t) \tag{1}$$
This equation shows that change in the state variable $s$, in this case the water level, is proportional to the water level itself, multiplied with a positive constant $\alpha$ that describes the properties of the outlet. The larger $\alpha$, the easier water can flow out of the reservoir. Later in this tutorial, you will derive this model in detail, but first you will learn about its basic properties.

The mathematical definition of a **time derivative of** the function $s(t)$ is as follows

$$\dfrac{ds}{dt} = \lim_{\Delta t\to\ 0}\frac{s(t+\Delta t)-s(t)}{\Delta t} \tag{2}$$
which teaches us that we can approximate the gradient of a function by taking the difference between to adjacant values and dividing it by the step size. If we take a step size that approximates zero, the derivative is exact. In this case, $\Delta t$ is an **infinitesimal difference**.

For most practical applications, it is impossible to take an infinitesimal step size if we want to approximate the derivative. Instead, we mostly use a finite step size such that the approximation is equal to:

$$ \dfrac{ds}{dt} \approx \frac{s(t+\Delta t)-s(t)}{\Delta t} \tag{3}$$
Note that this solution is no longer exact. The difference between $t$ and $\Delta t$ is a **finite difference** and has an associated approximation error (we will come back to this later). Generally, we can state that the larger the step size, the larger the error.

With equation 3, we can build models in which we can approximate the value of the state $s$ at a future time step $t + \Delta t$.

<span class="question">
1.1.1 Combine equations 1 and 3 to find an equation that can give you the value of $s$ at the next time step ($s(t+\Delta t)$)
</span>

<span class="answer">
$$ s(t+\Delta t) = s(t) - \Delta t *\alpha  s(t) \tag{4}$$
$$ s(t+\Delta t) = s(t)(1-\alpha \Delta t) \tag{5}$$
</span>

In order to refresh your mathematics, calculate the analytical solution to equation 1, so we can use it later to validate your models against.

<span class="question">
1.1.2 Derive the exact solution of ordinary differential equation (ODE) of the emptying reservoir (equation 1). 
</span>

<span class = "answer">
$$\begin{align}
ds &= -as \ dt\\
\dfrac{1}{-as} ds &= dt\\
\int \dfrac{1}{-as} ds &= \int dt\\
\dfrac{1}{-a} \int \dfrac{1}{s} ds &= \int dt\\
\dfrac{\ln(s)}{-a} &= t + C_{1}\\
\ln(s) &= -at + C_{2}\\
s &= \mathrm{e}^{-at + C_{2}}\\
s &= C_{3}\mathrm{e}^{-at}\\
s(t) &= s_{0}\mathrm{e}^{-at}
\end{align}$$
</span>

## Section 1.2 - Implementing emptying reservoir model
<span class="question">
1.2.1 Implement the formula derived in question 1.1.1 in the following script to set up a numerical model for the emptying reservoir.
</span>

<span class="student_answer">
```{r chunk1_question}
sys.fun = function(state)
{
    newstate = ...
    return(newstate)
}
```
</span>

<span class="answer">
```{r chunk1_answer}
sys.fun = function(state)
{
    newstate = state*(1-alpha*dt)
    return(newstate)
}
```
</span>

<span class="question">
1.2.2 Run the following chunk to perform the actual simulation and visualize it.
```{r chunk3}
# Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation (50)
dt         = 0.1   # delta t; time discretisation (0.1)
init.state = 3     # state of the system at the beginning of the simulation (3)
alpha      = 0.25  # decay constant (0.25)

# Simulation initialisation
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state

# Simulation
while(time < end.time)
{
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='o', xlab="time", ylab="state")
title(main='Emptying reservoir')
grid()
```
</span>

<span class="question">
1.2.3 Vary the `dt` parameter between 0.001 and 25. Are there any numerical problems arising beyond a certain value for `dt`? What are the problems occurring when choosing a value for `dt` close the high or low end of this range? Can you interpret your results in terms of convergence, oscillations and stability?
</span>

<span class="answer">
In the low end of the spectrum run-time will be significantly higher and can become impractically slow (although the result is very accurate). On the high side; first you will notice that already in the first step the state of the reservoir will be lower than 0, which is physically incorrect. Secondly, when choosing a `dt` that is even higher, the numerical approximation does not converge, oscillates and can even go to positive/negative infinity.
</span>

<span class="question">
1.2.4 Reset `dt` to 0.1 and vary alpha between 0.25 and 25. Describe for `alpha` 0.25, 5, 10, 15, 20, 25 whether the simulation is physically correct, converging (approximation and exact solution advance to the same, or at least roughly the same, solution) and stable, and explain why with the help of the equation that calculates the next state. 

$\alpha$ | physically correct | convergent | stability | explanation 
---------| ------------------ | ---------- | --------- | ----------- 
0.25     | | | |  
5        | | | | 
10       | | | |  
15       | | | |  
20       | | | |  
25       | | | |  
</span>

<span class="answer">

$\alpha$ | physically correct | convergent | stability | explanation 
---------| ------------------ | ---------- | --------- | ----------- 
0.25 | correct | converging | stable |  
5 | correct |  converging | stable | 
10 | correct |  converging | stable |  
15 | incorrect |  converging | stable | solution becomes negative because alpha*dt goes under 1 
20 | incorrect | not converging | (un)stable | solution does not go to zero as it should be continues jumping between -3 and 3
25 | incorrect | not converging | unstable | solution goes to infinity 

</span>

You will now compare the results against the exact analytical solution that you derived. **You can choose here from the assignment below, or from question 1 from the extended tutorial**.

<span class="question">
1.2.5 Two options are available here; either unfold `chunk4` and run the code or go to question 1 in the extended tutorial to add the exact solution to the previous plot yourself.
</span>

<button type="button" onclick="toggle('Q1')">Show chunk</button>
<div id="Q1" style="display: none">
```{r chunk4}
# Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation (50)
dt         = 5     # delta t; time discretisation (0.25)
init.state = 3     # state of the system at the beginning of the simulation (3)
alpha      = 0.25  # decay constant (0.25)

# Simulation initialisation
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state

# Simulation
while(time < end.time)
{
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
}

# Plotting
plot(result.time, result.state, type='o', col="blue", xlab="time", ylab="state")
time.sequence = seq(begin.time,end.time, by=0.1)
analyt.state=init.state * exp(-time.sequence*alpha)
lines(time.sequence, analyt.state, col='grey', lwd=2)
title(main='Numerical and analytical solution compared')
grid()
```
</div>

<br />

<span class="question">
1.2.4 At which `dt` do the numerical approximation and analytical solution start to agree fairly reasonably?
</span>

<span class="answer">
Around `dt = 1` the analytical solution and the numerical approximation come quite close to each other.
</span>

# Part 2 - Taylor series
## Section 2.1 - Introduction Taylor Series 
The previous exercise can also be done in a more formal way, such that the error of the numerical approximation can be calculated. For that we need Taylor series.

Taylor series (https://en.wikipedia.org/wiki/Taylor_series) can be used to make approximations of complex mathematical functions. If you use an infinite series, the approximation is exact. The finite difference approximation that you have derived earlier, can also be derived using a Taylor series. TIP: if you are unfamiliar with this topic or you simply want a refresher you can watch the following video by 3Blue1Brown; https://www.youtube.com/watch?v=3d6DsjIBzJ4

The mathematical definition of a Taylor series is as follows:
$$f(x) = \sum_{n=0}^{\infty} \frac{f^{n}(a)}{n!}(x-a)^{n} \tag{6}$$

Expansion of this function gives:

$$f(x) = f(a) + \frac{f'(a)}{1!}(x-a) + \frac{f''(a)}{2!}(x-a)^{2} + \frac{f'''(a)}{3!}(x-a)^{3} + \frac{f''''(a)}{4!}(x-a)^{4} + \ ... \tag{7}$$

If we use the definitions and notation of exercise 1, we find:

$$s(t + \Delta t) = s(t) + \Delta t \frac{ds}{dt} \bigg\rvert_{t} + \frac{\Delta t^{2}}{2!} \frac{d^{2}s}{dt^{2}} \bigg\rvert_{t} + \frac{\Delta t^{3}}{3!} \frac{d^{3}s}{dt^{3}} \bigg\rvert_{t} + \frac{\Delta t^{4}}{4!} \frac{d^{4}s}{dt^{4}} \bigg\rvert_{t} + \ ...     \tag{8}$$
In simple words, this formula estimates the exponential decay, starting from a specified time $t$ a specific time-step into the future $\Delta t$, using only information that is known at $t$. If enough terms of the above equation are taken into account, only that equation would be needed to evaluate the whole period of the emptying reservoir. However, in a practical situation, only the first two terms are taken into account, because it is easier to work with and because it is most of the time impossible to derive the other terms.

A finite difference approximation of an ordinary differential equations can be set up by using the same principles. The first step is done by defining the balances in the system and determining the physical formulas needed to solve them. A simple example is the emptying bucket model shown above. The first derivative, the rate of change, is simply the amount (water might be a good way to visualise this) going into the system minus the amount leaving it:
$$\frac{ds}{dt} = Q_{in} - Q_{out} \tag{9}$$
In the example above the term $Q_{in}$ is zero. $Q_{out}$ is replaced by it's physical interpretation $-at$, which is simply an exponential decay constant multiplied by the time that the system has a flux going out. The next step in defining the finite difference scheme is an approximation of the derivative for which the Taylor series is used. 

Advanced track can go to exercise 2 of the extended file to derive the error term of the Taylor series. The rest can unfold the derivation here.

<button type="button" onclick="toggle('Q2')">Show derivation</button>
<div id="Q2" style="display: none">

Starting from equation 8:
$$s(t + \Delta t) = s(t) + \frac{\Delta t}{1!} \frac{ds}{dt} \bigg\rvert_{t} + \frac{\Delta t^{2}}{2!} \frac{d^{2}s}{dt^{2}} \bigg\rvert_{t} + \frac{\Delta t^{3}}{3!} \frac{d^{3}s}{dt^{3}} \bigg\rvert_{t} + \frac{\Delta t^{4}}{4!} \frac{d^{4}s}{dt^{4}} \bigg\rvert_{t} + \ ...     \tag{10}$$
Rearranging this equation:

$$\frac{s(t + \Delta t) - s(t)}{\Delta t} =  \frac{ds}{dt} \bigg\rvert_{t} + \frac{\Delta t}{2!} \frac{d^{2}s}{dt^{2}} \bigg\rvert_{t} + \frac{\Delta t^{2}}{3!} \frac{d^{3}s}{dt^{3}} \bigg\rvert_{t} + \frac{\Delta t^{3}}{4!} \frac{d^{4}s}{dt^{4}} \bigg\rvert_{t} + \ ... \tag{11}$$
Comparing this with the implementation in exercise 1 leads to the quantification of the error:

$$\frac{s(t + \Delta t) - s(t)}{\Delta t} =  \frac{ds}{dt} \bigg\rvert_{t} + error    \tag{12}$$
$$ error = \frac{\Delta t}{2!} \frac{d^{2}s}{dt^{2}} \bigg\rvert_{t} + \frac{\Delta t^{2}}{3!} \frac{d^{3}s}{dt^{3}} \bigg\rvert_{t} + \frac{\Delta t^{3}}{4!} \frac{d^{4}s}{dt^{4}} \bigg\rvert_{t} + \ ... \tag{13}$$
</div>

##Section 2.2 - Error of estimation
The hard track goes to exercise 3 in the extended file and will calculate the error term by hand. The rest proceeds with the following exercise.

<span class="question">
2.1.1 Run the chunk below that will open a new window. Use the arrows to change the number of terms of the Taylor series that are implemented and write down the error between the Taylor series implementation and the true emptying bucket.

terms | error 
----- | ----- 
1 |  
2 |
3 |
4 | 
5 | 
6 |

```{r chunk5, eval=FALSE, echo=FALSE}
rm(list=ls())
library(shiny)
error = function(taylor){
  
  # System function
  sys.fun = function(state)
  {
    newstate = state*(1-alpha*dt)
    return(newstate)
  }
  
  # Initial parameter values
  begin.time = 0     # usually this variable is set to 0
  end.time   = 50    # end time of the simulation (50)
  dt         = 5     # delta t; time discretisation (0.25)
  init.state = 3     # state of the system at the beginning of the simulation (3)
  alpha      = 0.25  # decay constant (0.25)
  
  # Simulation initialisation
  time = begin.time
  result.state= c(init.state)
  result.time = c(time)
  current.state = init.state
  
  # Simulation
  while(time < end.time)
  {
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
  }
  
  # Taylor series approximation
  derivative.list = c(paste(toString(init.state),"*DT^0"))
  f = expression(init.state*exp(-alpha*t))
  t = 0
  if(taylor>1){
    for(i in 1:(taylor-1)){
      f = D(f,'t')
      derivative.list = c(derivative.list,paste(toString(eval(f)),"*DT^",toString(i),"/",toString(factorial(i))))
      #print(f)
    }
  }
  g = parse(text = substitute(expression(f),list(f=paste(derivative.list,collapse = "+"))))
  
  
  DT = seq(begin.time,end.time,by=0.1)
  p  = eval(g)
  
  # Plotting
  plot(result.time,result.state,type='o', xlab="time",ylab="state")
  time.sequence = seq(begin.time,end.time,by=0.1)
  analyt.state=init.state * exp(-time.sequence*alpha)
  lines(time.sequence,analyt.state,col='blue',lwd=2)
  lines(DT,p, lwd=2, col="green")
  
  DT = dt
  correct.state = init.state*exp(-dt*alpha)
  error = round(abs(correct.state-eval(g)),3)
  points(dt,eval(g),col="green",pch=19)
  points(dt,correct.state,pch=19)
  segments(dt,correct.state,dt,eval(g),col="red",lwd=2)
  title(main=paste('Numerical and analytical solution compared. Error: ',error))
  
  grid()
}

#########################################
ui <- fluidPage(
  
  # App title ----
  titlePanel("Calculate the error"),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    
    # Sidebar panel for inputs ----
    sidebarPanel(
      
      numericInput("taylor", label  = "Terms of the taylor series:" , value=1, min = 1, max = 40, step = 1)
      
    ),
    
    # Main panel for displaying outputs ----
    mainPanel(
      
      # Output: Plot of the requested variable against mpg ----
      plotOutput("p")
      
      
      
    )
  )
)

server <- function(input, output) {
  output$p = renderPlot({error(input$taylor)})
}

shinyApp(ui, server)
```

</span

<span class="answer">

terms | error 
----- | ----- 
1 | 2.140
2 | 1.609 
3 | 0.242 
4 | 0.063 
5 | 0.013 
6 | 0.002 

</span>

#Part 3 - Input and output
##Section 3.1 - Introducing input
In this part of the assignments on the finite differences methodology, an input will be introduced into the simulations. The numerical approximations (methods) discussed during the lectures will be implemented and are assessed for their performance.

A simple, but effective input could be a $\sin(time)+1$ function representing for example the daily varying latent heat flux or precipitation:

```{r chunk6}
time = seq(0,50,by=0.5)
plot(time,sin(time)+1,type='o', xlab="time",ylab="state")
```

Coming back the the mathematics of the implementation. The first step was to set up the balance equation in the system. For an emptying bucket with a variable input: 

$$\frac{dV}{dt} = Q_{in} - Q_{out} \tag{14}$$
Said simply, the change in the volume inside the bucket is the amount going in the bucket minus the amount leaving the bucket. The volume of the bucket, $V$, can be replaced by the area times the height: $A\,s(t)$. $Q_{out}$ is still the reservoir constant times the height of the volume in the bucket $a*s(t)$. The situation we dealt with in Part 1 and 2 was more or less the same except that $Q_{in}$ was equal to 0 and and A was 1. 

<span class="question">
3.1.1 Replace $Q_{in}$ and $Q_{out}$ with their physical counterparts and derive the finite differences approximation for $s(t+\Delta t)$.
</span>

<span class="answer">
$$
\begin{matrix}
\dfrac {dV}{dt} &=& Q_{in} - Q_{out}\\
Q_{in} &=& \sin(t) + 1 \\
Q_{out} &=& a\,s(t) \\
V &=& A\,s(t) \\
A\dfrac{ds}{dt} &=& {(\sin(t)+1)} - as(t) \\
\dfrac {s(t+\Delta t)-s(t)} {\Delta t} &=& \dfrac 1 A((\sin(t)+1) - as(t)) \\
s(t+\Delta t) &=& s(t) + \dfrac{\Delta t}{A} ((\sin(t)+1) - as(t))
\end{matrix}
$$
</span>

<span class="question"> 
3.1.2 Copy chunk three here and add a new, updated **sys.fun** reflecting the equation derived in question 3.1.1, using these parameter values:

```{r chunk7}
rm(list=ls())
# Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation
dt         = 0.1   # delta t; time discretisation
init.state = 3     # state of the system at the beginning of the simulation
alpha      = 1     # decay constant
A          = 4     # surface of the bucket
```
</span>

<span class="answer">
```{r chunk8}
# Simulation initialisation
time             = begin.time
result.state     = c(init.state)
result.time      = c(time)
current.state    = init.state

# System function
sys.fun = function(state)
{
  newstate = state + dt/A*((sin(time)+1)-alpha*state)
  return(newstate)
}

# Simulation
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='o',xlab="time",ylab="state")
title(main='Emptying reservoir with input')
grid()
```
</span>

This system is technically still analytically solvable, but this is far from trivial. For simplicity we will not go into the details here and use another way to compare the quality of the simulation with the "real" solution. For that, we run the last simulation twice with different values for `dt`. One very low value that we will assume is a good approximation of the analital solution.

<span class="question">
3.1.3 Copy the last chunk here. Then copy the following lines of code into the end of the chunk.

```{}
dt = 2.0 # a new dt value to evaluate current scheme
time = begin.time
result.state= c(init.state)
result.time =c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue')
```

Replace the already existing plot command with the lines:
```{}
plot(result.time,result.state,type='l', col="grey",lwd=2,xlab="time",ylab="state")
```
</span>

<span class="answer">
```{r Explicit}
rm(list=ls())
#Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation
dt         = 0.1   # delta t; time discretisation
init.state = 3     # state of the system at the beginning of the simulation
alpha      = 1     # decay constant
A          = 4     # surface of the bucket

# Simulation initialisation
time             = begin.time
result.state     = c(init.state)
result.time      = c(time)
current.state    = init.state

# System function
sys.fun = function(state)
{
  newstate = state + dt/A*((sin(time)+1)-alpha*state)
  return(newstate)
}

# Simulation
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='l', col="grey",lwd=2,xlab="time",ylab="state")
title(main='Emptying reservoir with input, Explicit')
grid()

dt = 2.0 # a new dt value to evaluate current scheme
time = begin.time
result.state= c(init.state)
result.time =c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue')
```
</span>

If everything went well, there are two lines in the graph. The grey line is the 'true' solution and the blue line is the approximation. The 'true' solution here is the same finite differences approximation, but with such a small `dt`, that it approximates the analytical solution very well. 

<span class="question">
3.1.4 Play a bit around with the second `dt` variable to see how well the approximation is doing for a slightly more complex system. Does your answer of 1.2.3 still hold here?
</span>

# Part 4 - Different integration methods
So far, you have used the *explicit* integration scheme. This means that  values of the current time step are used to calculate the future. In mathematical notation, this sentence can be formulated as:

$$\frac{ds(t)}{dt} = f(t)$$
However, other possibilities do exist. In the following sections, you will encounter the implicit, midpoint, and Runge-Kutta time-integration methods.

## Section 4.1 - Implicit method
The implicit integration scheme is based on taking the derivative not with the current information, but with the information from the following time-step. In mathematical formulation it looks like this:

$$\frac{ds(t)}{dt} = f(t+\Delta t)$$
For the exercise with the emptying reservoir with variable input, this results in the following equation:

$$\frac{ds(t)}{dt} = \frac{1}{A}(\sin(t+\Delta t)+1) - \alpha s(t + \Delta t))$$
The sense of working this way is explained best with a couple of graphs. The first graph shows the explicit methodology. The grey arrows show the derivative field, the rate of change. In the explicit solution you following the arrow found at the current point for one time-step. This will overshoot the answer in this case but with the second time-step the approximation comes close to the real solution given in red.

![](vectorfield_explicit.png)
The implicit method works in a different way. It evaluates the gradient found at the next time-step and works back to the current point. 

![](vectorfield_implicit.png)
The methodologies behave very differently. The explicit scheme has oscillatory behavior and has outliers far from the correct solution. The implicit methodology is a bit more conservative. It is more stable and is more likely to keep within physical limitations. However, it is computationally more expensive to run and is generally harder to implement.

<span class="question">
4.1.1 Derive a new equation for $s(t+\Delta t)$ for the emptying reservoir with variable input using the implicit time-integration method.
</span>

<span class="answer">
$$\begin{matrix}
\frac{ds(t)}{dt} &=& f(t+\Delta t)\\
f(t) &=& (sin(t)+1) - \alpha s(t)\\
\frac{ds(t)}{dt} &=& \frac{1}{A}((sin(t+\Delta t)+1) - \alpha s(t + \Delta t))\\
\frac{ds(t)}{dt} &=& \dfrac {s(t+\Delta t)-s(t)} {\Delta t}\\
s(t+\Delta t) &=& s(t) + \frac{\Delta t}{A}(sin(t+\Delta t)+1) - \frac{\Delta t}{A}\alpha s(t + \Delta t))\\
s(t+\Delta t) + \frac{\Delta t}{A}\alpha s(t + \Delta t)) &=& s(t) + \frac{\Delta t}{A}(sin(t+\Delta t)+1)\\
s(t+\Delta t)(1 + \alpha\frac{\Delta t}{A}) &=& s(t) + \frac{\Delta t}{A}(sin(t+\Delta t)+1)\\
s(t+\Delta t) &=& \frac{1}{1 + \alpha\frac{\Delta t}{A}}(s(t) + \frac{\Delta t}{A}(sin(t+\Delta t)+1))\\
\end{matrix}$$
</span>

<span class="question"> 
4.1.2 Copy the previous chunk with the explicit scheme and replace the **sys.fun** with the implicit version.
</span>

<span class="answer">
```{r Implicit}
rm(list=ls())
#Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation
dt         = 0.1   # delta t; time discretisation
init.state = 3     # state of the system at the beginning of the simulation
alpha      = 1     # decay constant
A          = 4     # surface of the bucket

# Simulation initialisation
time             = begin.time
result.state     = c(init.state)
result.time      = c(time)
current.state    = init.state

# System function
sys.fun = function(state)
{
  newstate = 1/(1+alpha*dt/A)*(state + dt/A*(sin(time+dt)+1))
  return(newstate)
}

# Simulation
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='l', col="grey",lwd=2,xlab="time",ylab="state")
title(main='Emptying reservoir with input, Implicit')
grid()

dt = 2.0 # a new dt value to evaluate current scheme
time = begin.time
result.state= c(init.state)
result.time =c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue')
```
</span>

## Section 4.2 - Midpoint method
As you can see in the implementation of the both the explicit and the implicit integration scheme, the results look quite good with a low `dt` but for a larger time-step the results worsen. By closely examining the differences in the the implementation of the explicit and the implicit scheme you can see a phase-shift. 

<span class="question">
4.2.1 The implicit scheme has a tendency to lie slightly to the left of the true solution, while the explicit scheme lies slightly to the right. Explain why
</span>

The midpoint method, discussed here, tries to combine both methods and to keep the good aspects of both. What the midpoint method does is basically to add an extra point to the calculation. There are many ways of constructing midpoint methods, but here we will do the following; the first half a time-step an explicit scheme will be implemented and the second half will have an implicit scheme. In mathematical formulation it looks like this:

$$\widetilde{s} = s(t) + \frac{\Delta t}{2} \ f(t,s(t)) $$
$\tilde{s}$ is the midpoint

$$s(t+\Delta t) = \widetilde{s} + \frac{\Delta t}{2} \ f(t+\Delta t,s(t+\Delta t))$$

![](vectorfield_midpoint.png)

In comparison with the implicit and explicit schemes, the midpoint method converges faster. It is also about twice as expensive to run since it creates a temporary midpoint for calculation. It is, however, often worth the investment in time and effort.

<span class="question"> 
4.2.1 Copy the chunk with the implicit scheme here. To make the code more readable the following function can be added to the code (before the while loop). This function is the $f(t,s(t))$ as used above. In the emptying bucket with input this formula looks as follows:

$$ f(t,s(t)) = \dfrac{ds(t)}{dt} = \frac{(\sin(t) + 1) - as}{A}$$
```{}
f = function(time, state){
  return(((sin(time)+1)-alpha*state)/A)
}
```
</span>

<span class="question">
4.2.2 Update the **sys.fun** function to implement the midpoint method. Use the function given in question 4.2.1 as a starting point.
</span>

<span class="answer">
```{r Midpoint}
rm(list=ls())
#Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation
dt         = 0.1   # delta t; time discretisation
init.state = 3     # state of the system at the beginning of the simulation
alpha      = 1     # decay constant
A          = 4     # surface of the bucket

# Simulation initialisation
time             = begin.time
result.state     = c(init.state)
result.time      = c(time)
current.state    = init.state

# System function

f = function(time, state){
  return(((sin(time)+1)-alpha*state)/A)
}

sys.fun = function(state)
{
  s.aux    = state + dt/2*f(time,state)
  newstate = s.aux + dt/2*f(time+dt/2,s.aux)
  return(newstate)
}

# Simulation
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='l', col="grey",lwd=2,xlab="time",ylab="state")
title(main='Emptying reservoir with input, Midpoint')
grid()

dt = 2.0 # a new dt value to evaluate current scheme
time = begin.time
result.state= c(init.state)
result.time =c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue')
```
</span>

<span class="question">
Does this midpoint method converge faster or slower than the previous explicit and implicit methodologies?
</span>

<span class="answer">
faster
</span>

This can be proven mathematically. The hard track can do this in exercise 4 of the extended Rmd.

## Section 4.3 - Runge-Kutta method
For many applications, the best compromise between programming, calculation time and numerical accuracy is the Runge-Kutta numerical approximation. Instead of calculating one intermediate or auxiliary state value (Midpoint), four intermediate function evaluations are calculated:

$$
\begin{matrix}
\kappa_1 &=& \Delta t\:f(t,s(t))\\
\kappa_2 &=& \Delta t\:f(t + \frac{1}{2} \Delta t,\: s(t) + \frac{1}{2} \kappa_1)\\
\kappa_3 &=& \Delta t\:f(t + \frac{1}{2} \Delta t,\: s(t) + \frac{1}{2} \kappa_2)\\
\kappa_4 &=& \Delta t\:f(t + \Delta t,\:s(t) + \kappa_3)\\
s(t+\Delta t) &=& s(t)+\dfrac{\kappa_1+2\kappa_2+2\kappa_3+\kappa_4}{6}
\end{matrix}
$$
<span class="question">
4.3.1 Create a new chunk and copy the Midpoint approximation chunk into it
</span>

<span class="question">
4.3.2 Rewrite the **sys.fun** with the intermediate values and states shown above.
</span>

<span class="answer">
```{r Runge-Kutta}
rm(list=ls())
#Initial parameter values
begin.time = 0     # usually this variable is set to 0
end.time   = 50    # end time of the simulation
dt         = 0.1   # delta t; time discretisation
init.state = 3     # state of the system at the beginning of the simulation
alpha      = 1     # decay constant
A          = 4     # surface of the bucket

# Simulation initialisation
time             = begin.time
result.state     = c(init.state)
result.time      = c(time)
current.state    = init.state

# System function

f = function(time, state){
  return(((sin(time)+1)-alpha*state)/A)
}

sys.fun = function(state)
{
  k1       = dt*f(time       , state         )
  k2       = dt*f(time+0.5*dt, state + 0.5*k1)
  k3       = dt*f(time+0.5*dt, state + 0.5*k2)
  k4       = dt*f(time+    dt, state +     k3)
  newstate = state + (k1 + 2*k2 + 2*k3 + k4)/6
  return(newstate)
}

# Simulation
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}

# Plotting
plot(result.time,result.state,type='l', col="grey",lwd=2,xlab="time",ylab="state")
title(main='Emptying reservoir with input, Runge-Kutta')
grid()

dt = 2.0 # a new dt value to evaluate current scheme
time = begin.time
result.state = c(init.state)
result.time = c(time)
current.state = init.state
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state = c(result.state,current.state)
  time = time + dt
  result.time = c(result.time,time)
}
lines(result.time,result.state,type='o',col='blue')
```
</span>

# Part 5 - Comparing the different integration schemes

<span class="question">
5.1 Fill out the following table with the following options:
+ good (g)
+ phase shift (ps)
+ wrong amplitude (wa)
+ oscillates (osc)
+ unstable (uns)

This can be done either by running the applet below or by recycling the code of the different integration methods.

dt|Explicit|Implicit|Midpoint|Runge-Kutta
---|---|---|---|---|
0.1|-|-|-|-|
1|-|-|-|-|
2.5|-|-|-|-|
5|-|-|-|-|
10|-|-|-|-|
15|-|-|-|-|
20|-|-|-|-|
</span>

```{r Compare_integration_methods,eval=FALSE, echo=FALSE}
library(shiny)
compare = function(dt,runge_kutta,midpoint,explicit,implicit){
  if(!any(runge_kutta,midpoint,explicit,implicit)){
    plot.new()
    return()
  }
  
  # Other model parameters
  begin.time = 0     # usually this variable is set to 0
  end.time   = 50    # end time of the simulation
  init.state = 3     # state of the system at the beginning of the simulation
  alpha      = 1     # decay constant
  A          = 4     # surface of the bucket
  l          = c()   # empty list for legend entries
  lines_l    = c()   # empty list for legend lines
  
  f = function(time,state)
  {
    return(((sin(time)+1)-alpha*state)/A)
  }
  
  ## Background plot (based on Runge-Kutta)
  
  sys.fun = function(state)
  {
    k1       = dt*f(time       , state         )
    k2       = dt*f(time+0.5*dt, state + 0.5*k1)
    k3       = dt*f(time+0.5*dt, state + 0.5*k2)
    k4       = dt*f(time+    dt, state +     k3)
    newstate = state + (k1 + 2*k2 + 2*k3 + k4)/6
    return(newstate)
  }
  
  time = begin.time
  result.state= c(init.state)
  result.time =c(time)
  current.state = init.state
  dt_temp = dt
  dt = 0.1
  while(time < end.time)
  {
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
  }
  
  plot(result.time,result.state,type='l',col='darkgrey',lwd=3, xlab="time",ylab="state")
  
  # resetting dt
  dt = dt_temp   
  
  ##########SETTINGS#############
  ########Runge Kutta############
  time = begin.time  
  result.state= c(init.state)  
  result.time =c(time)  
  current.state = init.state  
  while(time < end.time)  
  {  
    current.state = sys.fun(current.state)  
    result.state = c(result.state,current.state)  
    time = time + dt  
    result.time = c(result.time,time)  
  }  
  if(runge_kutta){
    lines(result.time,result.state,type='o',col='black')
    l       = c(l,'Runge Kutta')
    lines_l = c(lines_l,"black")
  }
  
  ###########Midpoint##################
  sys.fun = function(state)
  {
    s.aux    = state + dt/2*f(time,state)
    newstate = s.aux + dt/2*f(time+dt/2,s.aux)
    return(newstate)
  }
  
  time = begin.time
  result.state= c(init.state)
  result.time = c(time)
  current.state = init.state
  while(time < end.time)
  {
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
  }
  if(midpoint){
    lines(result.time,result.state,type='o',col='red')
    l       = c(l,'Midpoint')
    lines_l = c(lines_l,"red")
  }
  
  ###########Implicit##################
  sys.fun = function(state)
  {
    newstate = 1/(1+alpha*dt/A)*(state + dt/A*(sin(time+dt)+1))
    return(newstate)
  }
  
  time = begin.time
  result.state= c(init.state)
  result.time =c(time)
  current.state = init.state
  while(time < end.time)
  {
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
  }
  if(implicit){
    lines(result.time,result.state,type='o',col='blue')
    l       = c(l,'Implicit')
    lines_l = c(lines_l,"blue")
  }
  
  ###########Explicit##################
  sys.fun = function(state)
  {
    newstate = state + dt/A*((sin(time)+1)-alpha*state)
    return(newstate)
  }
  
  time = begin.time
  result.state= c(init.state)
  result.time = c(time)
  current.state = init.state
  while(time < end.time)
  {
    current.state = sys.fun(current.state)
    result.state = c(result.state,current.state)
    time = time + dt
    result.time = c(result.time,time)
  }
  if(explicit){
    lines(result.time,result.state,type='o',col='green')
    l       = c(l,'Explicit')
    lines_l = c(lines_l,"green")
  }
  
  lty_l = rep(1  ,length(lines_l))
  lwd_l = rep(2.5,length(lines_l))
  
  legend('topright', l, lty=lty_l, lwd=lwd_l, col=lines_l)
  title(main=paste("Comparing quality integration schemes,",' dt :' ,dt))
  
  grid()
}



#################SHINY###################
ui <- fluidPage(
  
  # App title ----
  titlePanel("Compare integration schemes"),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    
    # Sidebar panel for inputs ----
    sidebarPanel(
      
      sliderInput("dt", label = "dt:",min = 0.2, max = 20, value = 1, step = 0.2),
      checkboxInput("runge_kutta", "Runge-Kutta", FALSE),
      checkboxInput("midpoint"   , "Moidpoint"  , FALSE),
      checkboxInput("explicit"   , "Explicit"   , FALSE),
      checkboxInput("implicit"   , "Implicit"   , FALSE)
      
    ),
    
    # Main panel for displaying outputs ----
    mainPanel(
      
      # Output: Plot of the requested variable against mpg ----
      plotOutput("p")
      
    )
  )
)

server <- function(input, output) {
  output$p = renderPlot({compare(input$dt,input$runge_kutta,input$midpoint,input$explicit,input$implicit)})
}

shinyApp(ui, server)
```

<span class="comment">
Maybe it is a nice idea to let the hard track solve the *coupled reservoir* and the *non-linear* reservoir here.
**[CvH: We can leave this option open. I think there are already quite some exercises.]**
</span>

# Part 6 - Real world example
The reservoir models up till now consider one outlet only. This entails a constant and linear relation between volume change and state change (for the linear reservoirs). For some environmental flow problems a reservoir model with a slow and fast acting component would be the most applicable model.

Its practical use may be found in meteorology like a reservoir containing thermal energy which can be released at different rates or in rainfall runoff models, simulating base flow and after a storm event a quick discharge (e.g. due to surface runoff).
In the graph below, the principle and workings of such a reservoir model is illustrated: 

![](double_pipe-reservoir.png)

*Double piped reservoir with both outlets active (left) and with lower outlet active (right).*  

***   

Depending on the state of the reservoir, the discharge out of the upper outlet is active or inactive and depends on the datum(reference) of the upper outlet. In simple terms this means that if the water-level is high enough it can come out at the upper outlet (left image). If the water level is lower than the outlet the outlet becomes inactive (right image)

<span class="question">6.1 Set up a new ordinary differential equation including the input flux ($Q_{in}$), volume change over time and the output fluxes (discharges). Next, derive a numerical approximation for the state using the explicit integration scheme</span>  

<span class="answer">
$$
\begin{matrix}
\text{Explicit scheme :}\\
\dfrac{\partial V}{\partial t} &=& Q_{in}-Q_{out}^{upper}-Q_{out}^{lower}\\[10pt]
A\dfrac{s(t + \Delta t)-s(t)}{\Delta t} &=& Q_{in}-Q_{out}^{upper}-Q_{out}^{lower}\\[10pt]
Q_{out}^{upper}&=&\alpha_{res.up}\:(s(t)-level_{res.up})\\[10pt]
Q_{out}^{lower}&=&\alpha_{res.lw}\:s(t)\\[10pt]
\dfrac{s(t + \Delta t) -s(t)}{\Delta t} &=& \dfrac{1}{A}\left( Q_{in}-\alpha_{res.up}(s(t)-level_{res.up})-\alpha_{res.lw}\:s(t)\right)\\[20pt]
s\le level_{res.up}\\
s(t + \Delta t)&=&s(t)+\dfrac{\Delta t}{A} \left(Q_{in}-\alpha_{res.lw}\:s(t) \right)\\
s> level_{res.up}\\
s(t + \Delta t)&=&s(t)+\dfrac{\Delta t}{A} \left(Q_{in}-\alpha_{res.up}(s(t)-level_{res.up})-\alpha_{res.lw}\:s(t) \right)\\
\end{matrix}
$$
</span>

The script below contains different items of this type of reservoir model. With this example the discharge of the Hupselse Beek (Gelderland) is simulated. The input is based on the recharge in the catchment of the Hupselse Beek. The output is observed at the weir downstream of the brook. The time series in 'hupsel.dat' contains 500 days of data (daily time steps)  
This script creates two different plots containing:
*   the modeled balance
*   the observed and calculated discharge of the brook including a statistic on the performance  


<span class="question">6.2 Implement the numerical approximation in the __sys.fun__ function and run the model.   

```{R, eval=FALSE}
##loading input and observed data
hupsel = read.table(file='hupsel.dat')
hupsel.time = hupsel$V1
hupsel.Qin = hupsel$V2
hupsel.Qobs = hupsel$V3
#to make data continuous for al dt
Qin.fun = approxfun(x=hupsel.time,y=hupsel.Qin,rule=2:2) 
Qobs.fun = approxfun(x=hupsel.time,y=hupsel.Qobs,rule = 2:2)

##time aspects
begin.time = 0              #begin time of the simulation
end.time = hupsel.time[length(hupsel.time)] #end time of the simulation
dt = 0.5                    #1.0#.5 #delta t; time discretisation

#reservoir parameters
res.alpha.lw = 0.10543215 
res.alpha.up = 0.75
res.lvl.up= 0.4             #1.7
res.A = 1.45 

init.state = 1.4            #the initial state of the linear reservoir

sys.fun = function(state)
{
  #
}

time          = begin.time
result.state  = c(init.state)
result.time   = c(time)
current.state = init.state
result.Qout1  = c()
result.Qout2  = c()
result.Qin    = c()
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state  = c(result.state,current.state)
  time          = time + dt
  result.time   = c(result.time,time)
}

#####Calculation of the Qout fluxes
##first a function (state.above.up) to determine which states are above the upper outlet
state.above.up = function()
{
  state.up = c()
  for (i in 1:length(result.time))
  {
    this.state = result.state[i]
   if(this.state>res.lvl.up)
   {
     state.up=c(state.up,this.state)
   }else{
     state.up=c(state.up,0)
   }
  }
  return(state.up)
}


  state.above =state.above.up()  
  Qout.up = state.above
  IQout = which(state.above>0)
  Qout.up[IQout] = res.alpha.up*(Qout.up[IQout]-res.lvl.up) 
 
  
#   Qout.up = res.alpha.up*(state.above[state.above>0]-res.lvl.up)

Qout.lw = c()
Qout.lw = res.alpha.lw*result.state
# Qout.lw = res.A*res.k.lw*result.state

##balance
##dV/dt = Qin - Qout.lw - Qout.up
##dV/dt = state*res.A/dt
nrsteps = length(result.state)-1
dVdt = diff(result.state)*res.A/dt
Qin = Qin.fun(result.time)
error = Qin[1:nrsteps] - Qout.lw[1:nrsteps] - Qout.up[1:nrsteps] - dVdt
 
plot(result.time,Qin,type = 'l',
     ylim=c(min(Qin,Qout.lw,Qout.up,dVdt),max(Qin,Qout.lw,Qout.up,dVdt)),
     ylab = 'L^3/T',xlab = 'time')
legend('topleft',c('Qin : black',
                 'Qout.lw : blue',
                 'Qout.up : green',
                 'dVdt: red',
                 'error : dashed'))

     
lines(result.time[1:nrsteps],dVdt,col='red')
lines(result.time[1:nrsteps],Qout.lw[1:nrsteps],col='blue')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps],col='green')
lines(result.time[1:nrsteps],error,lty='dashed')

##results observed vs computed
plot(result.time[1:nrsteps],Qobs.fun(result.time[1:nrsteps]),type='l',
     lwd=2,col='grey',ylim=c(min(hupsel.Qobs,Qout.lw,Qout.up),max(hupsel.Qobs,Qout.lw,Qout.up)),
     ylab = 'Qout.obs/Qout.calc',xlab = 'time')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps]+Qout.lw[1:nrsteps],col='blue')

Sumsquares = sum((Qobs.fun(result.time)-(Qout.up+Qout.lw))^2)
title(main=paste('Observed (grey) vs. calculated discharges ','SS = ',Sumsquares))



```
</span>

<span class="answer"> 
code chunk with if construct evaluating if level is above `res.lvl.up`;
```{R}
##loading input and observed data
hupsel = read.table(file='hupsel.dat')
hupsel.time = hupsel$V1
hupsel.Qin = hupsel$V2
hupsel.Qobs = hupsel$V3
#to make data continuous for al dt
Qin.fun =approxfun(x=hupsel.time,y=hupsel.Qin,rule=2:2) 
Qobs.fun = approxfun(x=hupsel.time,y=hupsel.Qobs,rule = 2:2)

##time aspects
begin.time   = 0              #begin time of the simulation
end.time = hupsel.time[length(hupsel.time)] #end time of the simulation
dt           = 0.5            #1.0#.5 #delta t; time discretisation

#reservoir parameters
res.alpha.lw = 0.10543215 
res.alpha.up = 0.75
res.lvl.up   = 0.4            #1.7
res.A        = 1.45 

init.state   = 1.4            #the initial state of the linear reservoir

sys.fun = function(state)
{
  if(state<= res.lvl.up)
  {
    state = state +dt/res.A*(Qin.fun(time)- res.alpha.lw*state)
  }else{
    state = state + dt/res.A*(Qin.fun(time)-res.alpha.up*(state-res.lvl.up)-res.alpha.lw*state)
  }
  return(state)
}

time            = begin.time
result.state    = c(init.state)
result.time     = c(time)
current.state   = init.state
result.Qout1    = c()
result.Qout2    = c()
result.Qin      = c()
while(time < end.time)
{
  current.state = sys.fun(current.state)
  result.state  = c(result.state,current.state)
  time          = time + dt
  result.time   = c(result.time,time)
}

#####Calculation of the Qout fluxes
##first a function (state.above.up) to determine which states are above the upper outlet
state.above.up = function()
{
  state.up = c()
  for (i in 1:length(result.time))
  {
    this.state = result.state[i]
   if(this.state>res.lvl.up)
   {
     state.up=c(state.up,this.state)
   }else{
     state.up=c(state.up,0)
   }
  }
  return(state.up)
}


  state.above =state.above.up()  
  Qout.up = state.above
  IQout = which(state.above>0)
  Qout.up[IQout] = res.alpha.up*(Qout.up[IQout]-res.lvl.up) 
 
  
#   Qout.up = res.alpha.up*(state.above[state.above>0]-res.lvl.up)

Qout.lw = c()
Qout.lw = res.alpha.lw*result.state
# Qout.lw = res.A*res.k.lw*result.state

##balance
##dV/dt = Qin - Qout.lw - Qout.up
##dV/dt = state*res.A/dt
nrsteps = length(result.state)-1
dVdt = diff(result.state)*res.A/dt
Qin = Qin.fun(result.time)
error = Qin[1:nrsteps] - Qout.lw[1:nrsteps] - Qout.up[1:nrsteps] - dVdt
 
plot(result.time,Qin,type = 'l',
     ylim=c(min(Qin,Qout.lw,Qout.up,dVdt),max(Qin,Qout.lw,Qout.up,dVdt)),
     ylab = 'L^3/T',xlab = 'time')
legend('topleft',c('Qin : black',
                 'Qout.lw : blue',
                 'Qout.up : green',
                 'dVdt: red',
                 'error : dashed'))

     
lines(result.time[1:nrsteps],dVdt,col='red')
lines(result.time[1:nrsteps],Qout.lw[1:nrsteps],col='blue')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps],col='green')
lines(result.time[1:nrsteps],error,lty='dashed')

##results observed vs computed
plot(result.time[1:nrsteps],Qobs.fun(result.time[1:nrsteps]),type='l',
     lwd=2,col='grey',ylim=c(min(hupsel.Qobs,Qout.lw,Qout.up),max(hupsel.Qobs,Qout.lw,Qout.up)),
     ylab = 'Qout.obs/Qout.calc',xlab = 'time')
lines(result.time[1:nrsteps],Qout.up[1:nrsteps]+Qout.lw[1:nrsteps],col='blue')

Sumsquares = sum((Qobs.fun(result.time)-(Qout.up+Qout.lw))^2)
title(main=paste('Observed (grey) vs. calculated discharges ','SS = ',Sumsquares))
```
</span>

<span class="question">
6.3  Analyse the effect of the different reservoir parameters on the behavior of the model.
</span>

<span class="answer">The four reservoir parameters: 

* `res.A`:  With the area the total volume in the reservoir is controlled. Small A results in less volume of water resulting in a peaky-er discharge.
* `res.alpha.lw`:   the lower outlet of the reservoir regulates the dynamics of the discharge; the larger $\alpha$ the directer the discharge occur. Base flow (the tails after the peaks) is reduced.
* `res.alpha.up/res.lvl.up`:  the activity is regulated with the height of the upper outlet. If the state is below this level, the upper outlet is inactive. If the state is higher than the upper outlet it acts similar as with `res.alpha.lw` 

</span>
