
#' Create a copy of a model
#' @description Makes a (deep)copy of an two dimensional flow object (the
#' usual assignment operators "=" and "<-" only generate a new name to an
#' existing model)
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return a copy of the same class
#' @export copy.model
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M0 = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' M1 = copy.model(M0)
#' set.name(M1,"a copy")
#' summary(M0)
#' summary(M1)
copy.model = function(model)
{
  newmodel= new.env()
  for(n in ls(model, all.names=TRUE)) assign(n, get(n, model), newmodel)
  attr(newmodel,"class")=class(model)
  return(newmodel)
}


zeroflux = function()
{
  return(0)
}

alwaysacceptable2D = function(x,y,S)
{
  return(TRUE)
}

winddirname = function(x,y)
{
  names = c("E","NE","N","NW","W","SW","S","SE","E")
  a = atan2(y,x)+pi/8
  if(a<0) a = a+2*pi
  return(names[1+a/pi*4])
}

test.collinearity = function(M)
{
  result = matrix(0,nrow=0,ncol=3)
  N = nrow(M)
  if(N<3) return(TRUE)
  M2 = cbind(M,rep(1,N))
  for(i in 1:(N-2))
  {
    for(j in (i+1):(N-1))
    {
      for(k in (j+1):N)
      {
        Det = det(M2[c(i,j,k),])
        if(abs(Det)<1e-9)
        {
          result=rbind(result,c(i,j,k))
        }
      }
    }
  }
  return(result)
}


#' jitter the points in a matrix
#' @description jitter (randomly) points to avoid collinearity
#' @param M a matrix of two columns (x and y) who's rows are
#' points in the plane
#' @param tojitter a vector of row numbers corresponding to
#' the points to be jittered; if empty (=default) all points
#' are jittered
#' @param eps a measure for the jitter, default 1e-6
#' @export jitter.points
#' @examples
#' D = matrix(c(0,0,5,0,10,0,10,5,10,10,5,10,0,10,0,5),ncol=2,byrow=TRUE)
#' print(D)
#' plot(D)
#' D = jitter.points(D)
#' print(D)
#' points(D,pch=20,col="red")
jitter.points = function(M, eps=1e-6,tojitter = c())
{
  if(length(tojitter)==0) {tojitter = 1:nrow(M)}
  M[tojitter,] = M[tojitter,]+matrix(rnorm(length(tojitter)*2,sd=eps),ncol=2)
  return(M)
}


setytoxratiowithscales = function(model,ytoxratio)
{
  model$ytoxratio = ytoxratio
  xscale = (model$xrange[2]-model$xrange[1])
  yscale = (model$yrange[2]-model$yrange[1])*model$ytoxratio

  model$scale = max(xscale, yscale)

  model$xscale = model$scale
  model$yscale = model$scale/model$ytoxratio
  model$sydomain = model$doscale(model$domain)
}

#' Construct a new FLOW2D model
#' @description generates a new object of the class FLOW2D:
#' the base of a two dimensional flow
#' @param domain a matrix with two columns containing respectively the
#' x and y coordinates of the cornerpoints that define the polygonal domain
#' on which the model is to be solved
#' @param systemfluxfunction a function of four arugments:
#' coordinates  x and y defining a point withtin the domain,
#' the state s at this point and the
#' gradient ds of the state at that point; it has to return a number that
#' gives the flux in the direction of the gradient based on these four arguments
#' @param name an optional name of the new object
#' @return an object of the class FLOW2D
#' @export
#' @examples
#' kvalues = data.frame(x=c(3,6),y=c(2,7),k=c(3,10))
#' kfun = nearestneighbour.fun(kvalues,zname="k")
#' invgradflux = function(x,y,s,grads) { return(-kfun(x,y)*s*grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' summary(M)
newFLOW2D = function(domain=NULL,
                     systemfluxfunction=NULL,
                     name="")
{
  is.valid("m","+x2",domain,
           "first (domain) argument of newFLOW2D should be a matrix with two columns")
  domain = matrix(as.numeric(domain),ncol=2)
  if(nrow(domain)<3){
    stop("Thee domain should have at least three different points.\n",call. = FALSE)
  }
  coll = test.collinearity(domain)
  if(nrow(coll)>0)
  {
    cat("There do exist collinear points in the boundary of the domain.\n")
    cat("This may generate problems during node generation.\n")
    cat("You may consider to remove this collinearity by the jitter.points function.\n")
    cat("List of collinear points:\n")
    for(i in 1:nrow(coll))
    {
      cat(paste("points",coll[i,1],coll[i,2],coll[i,3],"\n"))
    }
    stop("No model created",call.=FALSE)
  }
  is.valid("g",4,systemfluxfunction,
           "second (systemfluxfunction) argument of newFLOW2D should be a function with four
  formal arguments")
  is.valid("s","*",name,
           "third (name) argument of newFLOW2D should be a string")


  result = new.env()

  if(name=="")
  {
    result$name=paste("FLOW2D",gsub(" ","_",date()),sep="")
  } else {
    result$name = name
  }
  result$domain = domain
  result$xrange = range(domain[,1])
  result$yrange = range(domain[,2])
  result$xmin = result$xrange[1]
  result$ymin = result$yrange[1]



  result$doscale = function(P)
  {
    if(is.null(dim(P)))
    {
      c((P[1]-result$xmin)/result$xscale,(P[2]-result$ymin)/result$yscale)
    } else {
      t(apply(P,1,function(r){c((r[1]-result$xmin)/result$xscale,
                                (r[2]-result$ymin)/result$yscale)}))
    }
  }

  result$dounscale = function(P)
  {
    if(is.null(dim(P)))
    {
      c(result$xmin+P[1]*result$xscale,result$ymin+P[2]*result$yscale)
    } else {
      t(apply(P,1,function(r){c(result$xmin+r[1]*result$xscale,
                                result$ymin+r[2]*result$yscale)}))
    }
  }

  setytoxratiowithscales(result,1.0)
  result$sydomain = result$doscale(result$domain)


  result$systemflux = Vectorize(systemfluxfunction)
  result$sdepspatxflux = list()
  result$sindepspatxflux = list()
  result$sdeppntxflux = list()
  result$sindeppntxflux = list()
  result$linexflux= list()

  result$isacceptable = alwaysacceptable2D
  # calculating some geometrical interesting quantities
  N = dim(domain)[1]

  D = (domain[N,1]*domain[1,2]-domain[1,1]*domain[N,2])
  area = D/2
  centerx = (domain[N,1]+domain[1,1])*D
  centery = (domain[N,2]+domain[1,2])*D
  for(i in 1:(N-1))
  {
    D = (domain[i,1]*domain[i+1,2]-domain[i+1,1]*domain[i,2])
    area = area + D/2
    centerx = centerx + (domain[i,1]+domain[i+1,1])*D
    centery = centery + (domain[i,2]+domain[i+1,2])*D
  }
  result$area = abs(area)
  result$center=c(centerx/(6*area),centery/(6*area))
  # creating boundaries
  result$BC = list()
  centerx = mean(domain[,1])
  centery = mean(domain[,2])
  for(i in 1:N)
  {
    beginp = domain[i,]
    if(i<N) endp = domain[i+1,] else endp=domain[1,]
    midp=(beginp+endp)/2
    name = winddirname(midp[1]-result$center[1],result$ytoxratio*(midp[2]-result$center[2]))
    normal = endp-beginp
    lnormal = sqrt(normal[1]^2+normal[2]^2)
    normal = c(-normal[2]/lnormal,normal[1]/lnormal)
    if(!GEO$inside.poly(result$sydomain,result$doscale(midp)+1e-6*4*normal))
    {
      normal = -normal
    }
    result$BC[[i]] = list(beginp = beginp, endp = endp,
                          normal = normal,name=name,
                          type="fixedflux",func=zeroflux)
  }

  attr(result,"class")="FLOW2D"
  return(result)
}


#' Add spatial flux
#'
#' Adds an external spatial flux to an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param rate the intensity of the flux. Its physical dimension is that of the internal
#' flux divided by length. It can be given by either
#' \itemize{
#' \item  a number,
#' \item a string giving a variable name (at every evalution later the value of that variable
#' at that time will be used)
#' \item or a function  of space (x,y) and state (s) returning the intensity
#' of the spatial flux at that point with that state value.}
#' @param name an optional name for the flux
#' @rdname add.spatialflux
#' @export add.spatialflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' # add a constant rate and give name
#' add.spatialflux(M,0.1,"s1")
#' # add a string as a reference to a variable
#' F=0.1
#' add.spatialflux(M,"F")
#' # add a function
#' sfunc = function(x,y,s){return(-2+sin(x+y)+s)}
#' add.spatialflux(M,sfunc)
#' summary(M)
add.spatialflux = function(model,rate,name="")
  UseMethod("add.spatialflux")

#' @export add.spatialflux.FLOW2D
add.spatialflux.FLOW2D = function(model,rate,name="")
{
  c= is.valid(c("n","s","g","g"),c(1,"+",2,3),rate,
              "second argument of add.spatialflux should either be:
              - a number,
              - a variable name
              - a function of two argument: x and y
              - or a function of three arguments: x,y and state")
  is.valid("s","*",name,
           "third argument of add.spatialflux should be a string")
  if(c==1)
  {
    constantfunc = function(xarg,yarg)
    {
      return(rate)
    }
    if(name=="")
    {
      name = paste("spatialflux",
                   length(model$sindepspatxflux)+length(model$sdepspatxflux)+1,
                   sep="")
    }
    model$sindepspatxflux[[name]]=constantfunc

  }
  if(c==2)
  {
    s=rate
    constantfunc = function(xarg,yarg)
    {
      return(get(s))
    }
    if(name=="")
    {
      name = rate
    }
    model$sindepspatxflux[[name]]=constantfunc
  }
  if(c==3)
  {
    if(name=="")
    {
      name  = deparse(substitute(rate))
    }
    model$sindepspatxflux[[name]]=rate
  }
  if(c==4)
  {
    if(name=="")
    {
      name  = deparse(substitute(rate))
    }
    model$sdepspatxflux[[name]]=Vectorize(rate)
  }
}

#' Remove spatial flux
#'
#' Removes an external spatial flux from an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param fluxname is a string giving the name of the flux to be removed
#' (use \code{summary} to see the names)
#' @rdname rem.spatialflux
#' @export rem.spatialflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux)
#' add.spatialflux(M,0.1,"s1")
#' F=0.1
#' add.spatialflux(M,"F")
#' sfunc = function(x,y,s){return(-2+sin(x+y)+s)}
#' add.spatialflux(M,sfunc)
#' summary(M)
#' rem.spatialflux(M,"sfunc")
#' summary(M)

rem.spatialflux = function(model,name)
  UseMethod("rem.spatialflux")

#' @export rem.spatialflux.FLOW2D
rem.spatialflux.FLOW2D = function(model,name)
{
  is.valid("s","*",name,
           "second argument of rem.spatialflux should be a string")
  model$sindepspatxflux[[name]] = NULL
  model$sdepspatxflux[[name]] = NULL
}


#' Add a point flux
#'
#' Adds an external point flux to an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param at a vector containing two number being the x and y coordinate of the
#' place in the domain where to add the point flux
#' @param rate is the magnitue of the flux. Its physical dimension is that of the internal
#' flux multiplied by length. It can be given by either
#' \itemize{
#' \item a number,
#' \item a string giving a variable name (at every evalution later the value of that variable
#' at that time will be used)
#' \item or a function of  one argument (the state s) that
#'  returns the rate of the point flux
#' as a function of the state argument}
#' @param name optional name for the flux
#' @rdname add.pointflux
#' @export add.pointflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' # add a rate and give a name
#' add.pointflux(M,c(3,3),-1,"p1")
#' # add a string as a reference to a variable
#' p2 = -2
#' add.pointflux(M,c(4,4),"p2")
#' # add a function
#' pfunc = function(s){return(-2+s)}
#' add.pointflux(M,c(5,5),pfunc)
#' summary(M)

add.pointflux = function(model,at,rate,name)
  UseMethod("add.pointflux")

#' @export add.pointflux.FLOW2D
add.pointflux.FLOW2D = function(model,at,rate,name="")
{
  is.valid("n",2,at,
           "at=second argument of add.pointflux should be a vector c(atx,aty)")

  c= is.valid(c("n","s","g"),c(1,"+",1),rate,
              "third argument of add.pointflux should either be a number, a variable name or a
              function of one argument")
  is.valid("s","*",name,
           "fourth argument of add.pointflux should be a string")

  if(c==1)
  {
    if(name=="")
    {
      name = paste("pointflux",
                   length(model$sindeppntxflux)+length(model$sdeppntxflux)+1,
                   sep="")
    }
    constantfunc = function()
    {
      return(rate)
    }
    model$sindeppntxflux[[name]]=list(at=at,func=constantfunc)
  }
  if(c==2)
  {
    if(name=="")
    {
      name = rate
    }
    s=rate
    constantfunc = function()
    {
      return(get(s))
    }
    model$sindeppntxflux[[name]]=list(at=at,func=constantfunc)
  }
  if(c==3)
  {
    if(name=="")
    {
      name = deparse(substitute(rate))
    }
    model$sdeppntxflux[[name]]=
      list(at=at,func=Vectorize(rate))
  }
}

#' Remove point flux
#'
#' Removes an external point flux from an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param fluxname is a string giving the name of the flux to be removed
#' (use \code{summary} to see the names)
#' @rdname rem.pointflux
#' @export rem.pointflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux)
#' add.pointflux(M,at=c(3,3),-1,"p1")
#' p2 = -2
#' add.pointflux(M,at=c(4,4),"p2")
#' pfunc = function(s){return(-2+s)}
#' add.pointflux(M,at=c(5,5),pfunc)
#' summary(M)
#' rem.pointflux(M,"p1")
#' summary(M)
#' rem.pointflux(M,"pfunc")
#' summary(M)

rem.pointflux = function(model,name)
  UseMethod("rem.pointflux")

#' @export rem.pointflux.FLOW2D
rem.pointflux.FLOW2D = function(model,name)
{
  is.valid("s","*",name,
           "second argument of rem.pointflux should be a string")
  model$sindeppntxflux[[name]] = NULL
  model$sdeppntxflux[[name]] = NULL
}

#' Set name
#'
#' @description Set a new name to an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param newname the new name for the model
#' @rdname set.name
#' @export set.name
set.name = function(model,newname)
  UseMethod("set.name")

#' @export set.name.FLOW2D
set.name.FLOW2D = function(model,newname)
{
  is.valid("s","*",newname,
           "second argument of set.modelname should be a string")
  model$name=newname
}


#' @export set.name.FV2D
set.name.FV2D = set.name.FLOW2D


#' @export set.name.FElinear2D
set.name.FElinear2D = set.name.FLOW2D


#' @export set.name.FEquadratic2D
set.name.FEquadratic2D = set.name.FLOW2D


#' @export set.name.FEcubic2D
set.name.FEcubic2D = set.name.FLOW2D

#' @export set.name.FEquartic2D
set.name.FEquartic2D = set.name.FLOW2D

#' plot BC identifiers
#'
#' Makes a plot of the domain containing the boundary segment identifiers
#' (both as winddirections and numbers) of the domain.
#' These identifiers are needed as argument for the \code{set.BC} functions
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @rdname plot.BC.id
#' @export plot.BC.id
plot.BC.id = function(model)
  UseMethod("plot.BC.id")


#' @export plot.BC.id.FLOW2D
plot.BC.id.FLOW2D = function(model)
{
  xlim = c(1.1*model$xrange[1]-0.1*model$xrange[2],
           1.1*model$xrange[2]-0.1*model$xrange[1])
  ylim = c(1.1*model$yrange[1]-0.1*model$yrange[2],
           1.1*model$yrange[2]-0.1*model$yrange[1])
  plot(model$domain,pch=20,xlim=xlim,ylim=ylim,
       cex=0.8,col="blue",xlab="x",ylab="y")
  polygon(model$domain,col=rgb(0.1,0.1,0.1,0.25),border=NA)
  N = length(model$BC)
  collines = rep(c(rgb(0.9,0,0),rgb(0,0,0.7),rgb(0,0.3,0)),length=N)
  if(collines[N]==collines[1]) collines[N] = collines[2]
  for(i in 1:N)
  {
    bp = model$BC[[i]]$beginp
    ep = model$BC[[i]]$endp
    no = model$BC[[i]]$normal
    at = (bp+ep)/2
    lines(c(bp[1],ep[1]),c(bp[2],ep[2]),lwd=2,col=collines[i])
    name = paste(i,"-",model$BC[[i]]$name,sep="")
    mp = at-model$scale/40*no
    angle = atan(model$ytoxratio*(ep[2]-bp[2])/(ep[1]-bp[1]))*360/(3.1415*2)
    text(mp[1],mp[2],name,col=collines[i],srt=angle)
    Arrows(at[1],at[2],at[1]+model$scale/20*no[1],at[2]+model$scale/20*no[2])
  }
  grid(col="black")
}


findBCtoset = function(model,where,W)
{
  toset = c()
  IBC = seq(along=model$BC)
  if(W==1)
  {
    checkwinddir(where)
    for(i in IBC)
    {
      if(model$BC[[i]]$name==where)  toset=c(toset,i)
    }
  }
  else if(W==2)
  {
    if(is.element(where,IBC)) toset=c(toset,where)
  }
  return(toset)
}

checkwinddir = function(s) {
  if(!is.element(s,c("N","NE","E","SE","S","SW","W","NW")))
  {
    stop("Wind direction argument has to be one of:  'N','NE','E','SE','S','SW','W','NW',
             please read help of set.BC for more information",
         call.=FALSE)
  }
}

#' Set a fixed state boundary condition
#'
#' Set a fixed state boundary condition to one of the sides  of the polygon
#' forming the domain of an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param where either
#' \itemize{
#'  \item  a wind direction ("N","NE","E","SE","S","SW","W","NW")
#'   or a number identifying the side of the domain,
#'   as shown by \code{plot.BC.id}
#'  \item or a vector of two numbers: all the sides between these two
#'   numbers will be affected by the boundary condition
#' }
#' @param value either
#' \itemize{
#'  \item one number
#'  \item a string giving a variable name. At every evaluation of the boundary condition
#'  that follows  the value of that variable at evaluation time  will be used.
#'  \item a vector of two numbers. The boundary values will be linearly interpolated
#'  between these two numbers over the range given by the  \code{where} argument.
#'  The order of the points follows the number of the boundary segments.
#'  \item a vector of two strings. At every evaluation of the boundary condition
#'  that follows the values of these strings at evaluation time will be linearly
#'  interpolated  over the range given by the  \code{where} argument.
#'  The order of the points follows the number of the boundary segments.
#'  }
#' @seealso \code{dataframe.boundaries, plot.BC.id}
#' @rdname set.BC.fixedstate
#' @export set.BC.fixedstate
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' BCSW = 0.5
#' set.BC.fixedstate(M,"SW","BCSW")
#' control = solve.steps(M)
#' plot(M,fill="state")
set.BC.fixedstate = function(model,where,value)
  UseMethod("set.BC.fixedstate")


#' @export set.BC.fixedstate.FLOW2D

set.BC.fixedstate.FLOW2D = function(model,where,value)
{
  cw = is.valid(c("s","n","n"),c("*",1,2),where,
                "second argument of set.BC.fixedstate should either be string N,NE,E,SE,S,SW,W,NW,
                the number of the domain segment or a vector of two segment numbers")
  if(cw==1)
  {
    # print(paste("where is string = ",where))
    checkwinddir(where)
    toset=findBCtoset(model,where,1)
  } else if(cw==2)
  {
    # print(paste("where is number = ",where))
    toset=c(where)
  } else if(cw==3)
  {
    cw1 = is.valid(c("n"),c(1),where[1],
                   "the first number of where should be a number")
    cw2 = is.valid(c("n"),c(1),where[2],
                   "the second number of where should be a number")
    # print(paste("where are two number = ",where[1],where[2]))
    where[where<1]=1
    NumBC = length(model$BC)
    where[where>NumBC]= NumBC
    if(where[1]>where[2])
    {
      toset = c(seq(where[1],NumBC,by=1),seq(1,where[2],by=1))
    } else
    {
      toset = seq(from=where[1],to=where[2],by=1)
    }
  }
  if(length(toset)>1)
  {
    cat("Setting BC for #",length(toset)," number of segments.\n")
  }
  # print(paste("toset=",toString(toset)))
  fracL = c(0)
  sumL = 0
  for(i in toset)
  {
    L = sqrt(sum((model$BC[[i]]$beginp-model$BC[[i]]$endp)^2))
    sumL = sumL + L
    fracL = c(fracL,L)
  }
  fracL = cumsum(fracL)/sumL
  # print(paste("Ltoset=",toString(fracL)))
  cv=is.valid(c("n","s","n","s"),c(1,1,2,2),value,
              "third argument of set.BC.fixedstate should be a number, a vector of two numbers,
              a string or a vector of two strings")
  VF = c()
  if(cv==1)
  {
    # print(paste("value is one number ", value))
    valuefunc =  function(f=0.5){return(value)}
    environment(valuefunc)=new.env()
    assign("value",value,environment(valuefunc))
    for(i in toset)
    {
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedstate",
             value = valuefunc)
    }
  } else if (cv==2)
  {
    # print(paste("value is one string ", value))
    valuefunc = function(f=0.5){return(get(valuename))}
    environment(valuefunc)=new.env()
    assign("valuename",value,environment(valuefunc))
    for(i in toset)
    {
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedstate",
             value = valuefunc)
    }
  } else if(cv==3)
  {
    # print(paste("value are two numbers ", value[1],value[2]))
    for(k in 1:length(toset))
    {
      value1 = value[1]
      value2 = value[2]
      sf = fracL[k]
      ef = fracL[k+1]
      valuefunc = function(f=0.5)
      {
        startvalue = (1-sf)*value1+sf*value2
        endvalue =   (1-ef)*value1+ef*value2
        return((1-f)*startvalue+f*endvalue)
      }
      environment(valuefunc)=new.env()
      assign("value1",value[1],environment(valuefunc))
      assign("value2",value[2],environment(valuefunc))
      assign("sf",sf,environment(valuefunc))
      assign("ef",ef,environment(valuefunc))
      # print(paste("tst",valuefunc(0.5)))
      i = toset[k]
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedstate",
             value = valuefunc)
    }
  } else if(cv==4)
  {
    print(paste("value are two strings ", value[1],value[2]))
    for(k in 1:length(toset))
    {
      valuename1 = value[1]
      valuename2 = value[2]
      sf = fracL[k]
      ef = fracL[k+1]
      valuefunc = function(f=0.5)
      {
        value1 = get(valuename1)
        value2 = get(valuename2)
        startvalue = (1-sf)*value1+sf*value2
        endvalue =   (1-ef)*value1+ef*value2
        return((1-f)*startvalue+f*endvalue)
      }
      environment(valuefunc)=new.env()
      assign("valuename1",value[1],environment(valuefunc))
      assign("valuename2",value[2],environment(valuefunc))
      assign("sf",sf,environment(valuefunc))
      assign("ef",ef,environment(valuefunc))
      i = toset[k]
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedstate",
             value = valuefunc)
    }
  }
}


#' Set a fixed flux boundary condition
#'
#' Set a fixed flux boundary condition to one of the sides  of the polygon
#' forming the domain of an existing model. A fixed flux of zero is the default
#' boundary condition set to all boundaries on creation of a flow model.
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param where either a wind direction or a number identifying the side of the domain,
#' as shown by \code{plot.BC.id}
#' @param value either a number or a string giving a variable name
#' (at every evaluation later the value of that variable
#' the value of that variable at that time will be used)
#' for the fluxintensity orthognal to the given side of the boundary,
#' a postive sign indicating a flux into the domain, a negative sign a flux
#' leaving the domain
#' @seealso \code{dataframe.boundaries, plot.BC.id}
#' @rdname set.BC.fixedflux
#' @export set.BC.fixedflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.fixedflux(M,"SW",-0.3)
#' control = solve.steps(M)
#' plot(M,fill="state")
set.BC.fixedflux = function(model,where,value)
  UseMethod("set.BC.fixedflux")

#' @export set.BC.fixedflux.FLOW2D
set.BC.fixedflux.FLOW2D = function(model,where,value)
{
  W = is.valid(c("s","n"),c("*",1),where,
               "second argument (where) of set.BC.fixedstate should either be string N,NE,E,SE,S,SW,W,NW
           or the number of the domain segment")
  cv = is.valid(c("n","s"),c(1,"+"),value,
                "third argument (value) of set.BC.fixedflux should be a number or a string")
  if(cv==1)
  {
    valuefunc = function(){return(value)}
  } else if(cv==2)
  {
    s = value
    valuefunc = function(){return(get(s))}
  }
  toset = findBCtoset(model,where,W)
  if(length(toset)>1)
  {
    cat("Setting BC for #",length(toset)," number of segments.\n")
  }
  if(length(toset)>0)
  {
    for(i in toset)
    {
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedflux",
             func = valuefunc)
    }
  }
}

#' Set a fixed vector flux boundary condition
#'
#' Set a fixed vector flux boundary condition to one of the sides  of the polygon
#' forming the domain of an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param where either a wind direaction or a number identifying the side of the domain,
#' as shown by \code{plot.BC.id}
#' @param value a vector of two numbers giving fluxintensity vector crossing
#' the boundary at the given side,
#' @seealso \code{dataframe.boundaries, plot.BC.id}
#' @rdname set.BC.fixedvectorflux
#' @export set.BC.fixedvectorflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.fixedvectorflux(M,"SW",c(0,-0.4))
#' control = solve.steps(M)
#' plot(M,fill="state")
set.BC.fixedvectorflux = function(model,where,value)
  UseMethod("set.BC.fixedvectorflux")


#' @export set.BC.fixedvectorflux.FLOW2D
set.BC.fixedvectorflux.FLOW2D = function(model,where,value)
{
  W = is.valid(c("s","n"),c("*",1),where,
               "second argument of set.BC.fixedstate should either be string N,NE,E,SE,S,SW,W,NW
               or the number of the domain segment")
  is.valid("n",2,value,
           "third argument of set.BC.fixedvectorflux should be a vector of two numbers")
  toset = findBCtoset(model,where,W)
  if(length(toset)>1)
  {
    cat("Setting BC for #",length(toset)," number of segments.\n")
  }
  if(length(toset)>0)
  {
    for(i in toset)
    {
      constflux = function(S)
      {
        return(model$BC[[i]]$normal[1]*value[1]+
                 model$BC[[i]]$normal[2]*value[2])
      }
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fixedflux",
             func = constflux)
    }
  }
}


#' Set a flux-state boundary condition
#'
#' Set a flux-state boundary condition to one of the sides  of the polygon
#' forming the domain of an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param where either a wind direaction or a number identifying the side of the domain,
#' as shown by \code{plot.BC.id}
#' @param value a function of state given the fluxintensity orthogonal to the given
#' side, a postive sign indicating a flux into the domain, a negative sign a flux
#' leaving the domain
#' @seealso \code{dataframe.boundaries, plot.BC.id}
#' @rdname set.BC.fluxstate
#' @export set.BC.fluxstate
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.fluxstate(M,"SW",function(s){return(s-0.5)})
#' control=solve.steps(M)
#' plot(M,fill="state")
set.BC.fluxstate = function(model,where,value)
  UseMethod("set.BC.fluxstate")


#' @export set.BC.fluxstate.FLOW2D
set.BC.fluxstate.FLOW2D = function(model,where,value)
{

  W = is.valid(c("s","n"),c("*",1),where,
               "second argument of set.BC.fixedstate should either be string N,NE,E,SE,S,SW,W,NW
               or the number of the domain segment")
  is.valid("g",1,value,
           "third argument of set.BC.fluxstate should be a function of 1 argument")
  toset = findBCtoset(model,where,W)
  if(length(toset)>0)
  {
    for(i in toset)
    {
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fluxstate",
             func = Vectorize(value))
    }
  }
}


#' Set a vectorial flux-state boundary condition
#'
#' Set a vectorial flux-state boundary condition to one of the sides  of the polygon
#' forming the domain of an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param where either a wind direaction or a number identifying the side of the domain,
#' as shown by \code{plot.BC.id}
#' @param value a function of state returning a vector giving the fluxentsity at the given
#' the given side
#' @seealso \code{dataframe.boundaries, plot.BC.id}
#' @rdname set.BC.vectorfluxstate
#' @export set.BC.vectorfluxstate
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.vectorfluxstate(M,"SW",function(s){return(c(0.1*s,s-0.5))})
#' control=solve.steps(M)
#' plot(M,fill="state")
set.BC.vectorfluxstate = function(model,where,value)
  UseMethod("set.BC.vectorfluxstate")


#' @export set.BC.vectorfluxstate.FLOW2D
set.BC.vectorfluxstate.FLOW2D = function(model,where,value)
{
  W = is.valid(c("s","n"),c("*",1),where,
               "second argument of set.BC.vectorfluxstate should either be string N,NE,E,SE,S,SW,W,NW
               or the number of the domain segment")
  is.valid("g",1,value,
           "third argument of set.BC.vectorfluxstate should be a function of 1 argument")
  toset = findBCtoset(model,where,W)
  if(length(toset)>0)
  {
    for(i in toset)
    {
      flux = function(S)
      {
        result = c()
        for(j in 1:length(S))
        {
          vf = value(S[j])
          result = c(result,-model$BC[[i]]$normal[1]*vf[1]-
                       model$BC[[i]]$normal[2]*vf[2])
        }
        return(result)
      }
      model$BC[[i]] =
        list(beginp = model$BC[[i]]$beginp,
             endp  = model$BC[[i]]$endp,
             normal  = model$BC[[i]]$normal,
             name = model$BC[[i]]$name,
             type = "fluxstate",
             func = flux)
    }
  }
}

#' Set a state-acceptability function
#'
#' @description Set a state-acceptability function to an existing model,
#' to limit the possible values of states to (physcical) acceptable values, as
#' often implicetely assumed in flux definitions.
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param newisaccfunc a function of three arguments: an x and y giving the place and state return TRUE
#' if the state is acceptable at that position in the domain and FALSE
#' if not
#' @rdname set.isacceptable
#' @export set.isacceptable
#' @examples
#' sposgradflux = function(x,y,s,grads) { return(-sqrt(s)*grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=sposgradflux,name="example")
#' set.isacceptable(M,function(x,y,s){return(s>=0)})
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0.1)
#' control = solve.steps(M)
#' plot(M,fill="state")
set.isacceptable = function(model,newisaccfunc)
  UseMethod("set.isacceptable")


#' @export set.isacceptable.FLOW2D
set.isacceptable.FLOW2D = function(model,newisaccfunc)
{
  is.valid("g",3,newisaccfunc,
           "second argument of set.isacceptable should be a function of 3 arguments: x,y,s")
  model$isacceptable = Vectorize(newisaccfunc)
}

# #
# # end of mathematical model building
# #


# #
# # start of numerical model building
# #

discretizationwarning = function()
{
  stop("This function can not be called before discretisation",call.=FALSE)
}

#' @export set.isacceptable.FElinear2D
set.isacceptable.FElinear2D = set.isacceptable.FLOW2D


#' @export set.isacceptable.FEquadratic2D
set.isacceptable.FEquadratic2D = set.isacceptable.FLOW2D

#' @export set.isacceptable.FEcubic2D
set.isacceptable.FEcubic2D = set.isacceptable.FLOW2D

#' @export set.isacceptable.FEquartic2D
set.isacceptable.FEquartic2D = set.isacceptable.FLOW2D

#' @export set.isacceptable.FV2D
set.isacceptable.FV2D = set.isacceptable.FLOW2D



defaultcreatefactor = function(iter)
{
  if(iter<3) return(5)
  return(10) # a large number does not create new nodes
}
defaultremovefactor = function(iter)
{
  if(iter<3) return(0)
  return(0.01)
}
defaultmovefactor = function(iter)
{
  if(iter<3) return(1.25)
  return(1.25)
}

#' Set a discretisation of a two dimensional flow problem
#'
#' @description Set discretisation nodes and discretisation method for
#' a two dimensional flow problem
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param nodes Either a matrix  or a list specifying the way by which the nodes are generated. The fist entry
#' should be called type and has as value a string identifying the method by which the
#' nodes are generated. Choices are:
#' \itemize{
#' \item In the simpliest case a matrix with two columns, giving the x and
#' y coordinates respectively of the nodes. Such a matrix can for instance
#' come from another model or from file.
#' \item \code{nodes=list(type="rectregular",dx= ,dy= )} \cr
#' Generates a rectangular regulare grid. \cr
#' The entries \code{dx} and \code{dy} should be numbers that give
#' the distance of gridlines in the x and y direction respectively.
#' \item \code{nodes=list(type="rectgeneral", x= , y=)}\cr
#' Generates a rectangular grid with gridlines with varying distances.\cr
#' \code{x} and \code{y} should be vectors containing respectively the x-coordinates
#' for the vertical gridlines and the y-coordinates for the horizontal gridlines
#' \item  \code{nodes=list(type="hexagonal",side= )}\cr
#' Generates a hexagonal grid with a the value of \code{side} as distance between the nodes
#' \item  \code{nodes=list(type="randgen",minist= )}\cr
#' Generates points in the domain by a random process, but does not use points
#' closer (with a distance controlled by the ytoxratio, see below)
#' than \code{mindist} to points already constructed.
#' As this method uses random points, the value
#' of the ranomd seed (see help on \code{set.seed}) may influence the result.\cr
#' \code{mindist} can be either a number or a function of two
#' arguments returning the minist at the x-y place given by the arguments.
#' Such functions can be e.g. generated by \code{func.dist.to.point},
#' \code{func.dist.to.line} and \code{func.dist.to.poly}. \cr
#' The list may contain the following optional arguments:\cr
#' \itemize{
#' \item  \code{maxfails} (default set to 30): if the node generator generates more than
#' maxfails number of rejected random points from a given node, that node is decleared inactive \cr
#' \item  \code{startnodes} (default empty) a matrix with two columns (for the x and y coordinates respectively)
#' giving points that are included to the nodes before the random points are added\cr
#' \item \code{verbose} (default \code{FALSE}), if \code{TRUE} shows graphically the progress
#' of the node generation
#' \item \code{sleeptime} (default \code{0}), if \code{verbose} is \code{TRUE}, plots showing intermediate
#' steps are shown; if this goes to fast for the screen updating, a positive number for
#' (e.g. 0.1) generates some extrea time needed for screen updating.
#' \item \code{ytoxratio} (default=1) gives the ratio between the x and y direction e.g for the
#' calculation of distances:
#'            d((x0,y0),(x1,y1)) = sqrt((x0-x1)^2+ytoxratio^2*(y0-y1)^2)
#' }
#' \item  \code{nodes=list(type="geomgen", optdist=)}\cr
#' Generates points in the domain by a geometrical method which iteratively
#' creates new points, removes bad points and moves points to better positions
#' in an attempt to optimally position nodes with a distance
#' (with a distance controlled by the ytoxratio, see below) to each other
#' given by \code{optdist}.\cr
#' \code{optdist} can be either a number or a function of two
#' arguments returning the optimal distance at the x-y place given by the arguments.
#' Such functions can be e.g. generated by \code{func.dist.to.point},
#' \code{func.dist.to.line} and \code{func.dist.to.poly}. \cr
#' The list may contain the following optional arguments:\cr
#' \itemize{
#' \item \code{startnodes}  (default empty) a matrix with two columns (for the x and y coordinates respectively)
#' giving points that are included to the nodes before the random points are adde\cr
#' \item \code{maxiter} the maximum number of iterations after which the node generation stops
#' anyway (default set to 20)\cr
#' \item \code{stopcrit} the node generation calculates a criterion that measures how
#' far the nodes generated are form an optimal position, the smaller this number the
#' better the nodes are positioned (default set to 0.005),\cr
#' For an insight into values of  criterion in a particular case, the field \code{verbose=TRUE}
#' may be set.  \cr
#' \item \code{movefactor} Nodes can be moved inside the domain in an attempt to approach the optimal
#' distance better. During any iteration step this is a constant. From iteration to iteration
#' this constant can change. Default this constant is calculated by \cr
#' \code{function(iter){if(iter<5) return(0) else return(1.0)}}\cr
#' A larger number generates larger moves.
#' A too large \code{movefactor} may generate instability: points kicked out of the domain
#' too fast. The value is  by defualt set to \code{1.25}.
#' If another value or function (see also examples for other factors) is needed
#' (generated for instance by inspection of the process
#' setting \code{verbose=TRUE}), a new function may be assigned to the \code{movefactor}
#' entry in the list.\cr
#' \item \code{createfactor} New nodes can be created inside the domain in an attempt to approach the optimal
#' distance better. During any iteration this rate of creation is a constant.
#' From iteration to iteration this constant can change.
#' Default this constant is set to
#' \code{function(iter){if(iter<3) return(5) return(10)}}\cr
#' The larger the returned value, the less nodes are created.\cr
#' If another function is needed (generated for instance by inspection of the process
#' setting \code{verbose=TRUE}), a new function may be assigned to the \code{createfactor}
#' entry in the list.\cr
#' \item  \code{removefactor} Nodes can be removed in an attempt to approach the optimal
#' distance better. During any iteration this rate of removal  is a constant.
#' From iteration to iteration this constant can change.
#' Default this constant is calculated by \cr
#' \code{function(iter){if(iter<3) return(0)return(0.01)}}\cr
#' The larger the returned value, the less nodes are removed.\cr
#' If another function is needed (generated for instance by inspection of the process
#' setting \code{verbose=TRUE}), a new function may be assigned to the \code{createfactor}
#' entry in the list.\cr
#' \item \code{verbose} if \code{TRUE} (default is set to \code{FALSE}) shows graphically the progress
#' of the node generation. In this plot blue-ish cirlces give an indication of optimal distances,
#' new created nodes are marked green, removed nodes are marked yellow and the moves of points
#' are show by arrows. The iteration number and criterion value (which may be used to stop the
#' node generation) are given in the title. The subtitle gives the current values of the movefactor
#' (m), createfactor (c) and removefactor (r).
#' \item \code{sleeptime} (default \code{0}), if \code{verbose} is \code{TRUE}, plots showing intermediate
#' steps are shown; if this goes to fast for the screen updating, a positive number for
#' (e.g. 0.1) generates some extrea time needed for screen updating.
#' \item \code{ytoxratio} (default=1) gives the ratio between the x and y direction e.g for the
#' calculation of distances:
#'            d((x0,y0),(x1,y1)) = sqrt((x0-x1)^2+ytoxratio^2*(y0-y1)^2)
#' So if in the domain the range of y values  is f times smaller than the range of x values on can set
#' ytoxratio = f to compensate the distributions of the nodes for this.
#' }
#' }
#' @param method A string, giving the choice of discretisation method, the following choices are implemented:
#' "FE" for the Finite Element technique (is actually equal to "FElinear"),
#' "FElinear" (integration done by just taking the midpoint),
#' "FEquadratic" (i.e. FE with a intergration technique based on
#' three points),"FEcubic" (intergration based on four points),
#' "FEquartic" (integration based on 6 points), "FV" for the Finite Volume technique.
#' @return a two dimensional flow model according to the method chosen:
#' \code{[A]FElinear2D}, \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D}
#'
#' @rdname set.discretisation
#' @export set.discretisation
#' @examples
#'  invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="rectregular",dx=1,dy=0.5),method="FV")
#' plot(M,fill="random")
#' set.discretisation(M,nodes=list(type="rectgeneral",x=seq(0,10,length=10),
#'                                 y=seq(0,sqrt(10),length=20)^2),method="FE")
#' plot(M,fill="random")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' plot(M,fill="random")
#' set.discretisation(M,nodes=list(type="randgen",mindist=1),method="FE")
#' plot(M,fill="random")
#' fd = func.dist.to.point(c(5,5),width=2,atvalue=0.1,farvalue=1)
#' set.discretisation(M,nodes=list(type="geomgen",optdist=fd,verbose=TRUE),
#'                    method="FV")
#' plot(M,fill="random")
#' Mnodes = dataframe.nodes(M)
#' M2 = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M2,as.matrix(Mnodes),method="FE")
#' plot(M2,fill="random")

set.discretisation  = function(model,nodes,method)
  UseMethod("set.discretisation")

#' @export set.discretisation.FLOW2D
set.discretisation.FLOW2D = function(model,nodes,method)
{
  nchoice = is.valid(c("m","l"),c("+x2","+"),nodes,
                     "second argument of set.discretisation should be a vector or a list")
  is.valid("s","*",method,
           "third argument of set.discretisation should be string")
  if(!is.element(method,c("FE","FElinear","FEquadratic",
                          "FEcubic","FEquartic",
                          "FV")))

  {
    stop(paste("discretisation method",method,"not implemented"))
  }
  if(nchoice==1)
  {
    setytoxratiowithscales(model,1)
    if(method=="FV")
    {
      add2DFVdiscr_unstructured(model,nodes)
    } else {
      add2DFEdiscr_unstructured(model,nodes)
    }
  } else if(nchoice==2)
  {
    is.valid("s","*",nodes$type,"node list should contain a field type that is a string")
    alltypes = c("rectregular","rectgeneral","hexagonal","randgen","geomgen")
    typechoice = which(nodes$type==alltypes)
    if(length(typechoice)==0)
    {
      stop(paste("onlye available types are",paste(alltypes,collapse=" ")),call.=FALSE)
    }
    if(typechoice==1)
    {
      is.valid("n","1",nodes$dx,"node list should contain a field dx that is a number")
      is.valid("n","1",nodes$dy,"node list should contain a field dy that is a number")
      setytoxratiowithscales(model,1)
      if(method=="FV")
      {
        add2DFVdiscr_rectregular(model,nodes$dx,nodes$dy)
      } else if(substr(method,1,2)=="FE")
      {
        add2DFEdiscr_rectregular(model,nodes$dx,nodes$dy)
      }

    } else if(typechoice==2)
    {
      is.valid("n","+",nodes$x,"node list should contain a field x that is a vector")
      is.valid("n","+",nodes$y,"node list should contain a field y that is a vector")
      setytoxratiowithscales(model,1)
      if(method=="FV")
      {
        add2DFVdiscr_rectgeneral(model,nodes$x,nodes$y)
      } else if(substr(method,1,2)=="FE")
      {
        add2DFEdiscr_rectgeneral(model,nodes$x,nodes$y)
      }
    } else if(typechoice==3)
    {
      is.valid("n","1",nodes$side,"node list should contain a field side that is a number")
      setytoxratiowithscales(model,1)
      if(method=="FV")
      {
        add2DFVdiscr_hexagonal(model,nodes$side)
      } else if(substr(method,1,2)=="FE")
      {
        add2DFEdiscr_hexagonal(model,nodes$side)
      }
    } else if(typechoice==4)
    {
      is.valid(c("n","g"),c("1","1"),nodes$mindist,
               "field mindist of nodes list should be either a number or a function of one argument")
      unknown = setdiff(names(nodes),c("type","mindist","maxfails","verbose","startnodes",
                                       "sleeptime","ytoxratio"))
      if(length(unknown>0))
      {
        stop(paste("unapplicable fields of nodes:",paste(unknown,collapse=" ")),call.=FALSE)
      }
      if(!is.null(nodes$maxfails))
      {
        is.valid("n","1",nodes$maxfails,"the field maxfails of nodes list should be a number")
        maxfails = nodes$maxfails
      } else {
        maxfails = 30
      }
      if(!is.null(nodes$startnodes))
      {
        is.valid("m","+x2",nodes$startnodes,
                 "the field startnodes of nodes list should be a matrix of two columns")
        startnodes = nodes$startnodes
      } else
      {
        startnodes = NULL
      }
      if(!is.null(nodes$verbose))
      {
        is.valid("b","1",nodes$verbose,
                 "the field verbose of nodes list should be a logical")
        verbose = nodes$verbose
      } else
      {
        verbose = FALSE
      }
      if(!is.null(nodes$sleeptime))
      {
        is.valid("n","1",nodes$sleeptime,"the field sleeptime of nodes list should be a number")
        sleeptime = nodes$sleeptime
      } else {
        sleeptime = 0
      }
      if(!is.null(nodes$ytoxratio))
      {
        is.valid("n","1",nodes$ytoxratio,"the field ytoxratio of nodes list should be a number")
        setytoxratiowithscales(model,nodes$ytoxratio)
      } else {
        setytoxratiowithscales(model,1)
      }
      if(method=="FV")
      {
        add2DFVdiscr_unstructured(model,
                                  randomnodes(model,nodes$mindist,
                                              maxfails=maxfails,
                                              startnodes= startnodes,
                                              graphverbose = verbose,
                                              sleeptime=sleeptime))
      } else if(substr(method,1,2)=="FE")
      {
        add2DFEdiscr_unstructured(model,
                                  randomnodes(model,nodes$mindist,
                                              maxfails=maxfails,
                                              startnodes= startnodes,
                                              graphverbose = verbose,
                                              sleeptime=sleeptime))
      }
    } else if(typechoice==5)
    {
      is.valid(c("n","g"),c("1","1"),nodes$optdist,
               "field optdist of nodes list should be either a number or a function of one argument")


      unknown = setdiff(names(nodes),c("type","optdist","maxiter","movefactor","startnodes",
                                       "removefactor","createfactor","stopcrit","verbose",
                                       "sleeptime","ytoxratio"))
      if(length(unknown>0))
      {
        stop(paste("unapplicable fields of nodes:",paste(unknown,collapse=" ")),call.=FALSE)
      }
      if(!is.null(nodes$maxiter))
      {
        is.valid("n","1",nodes$maxiter,"the field maxiter of nodes list should be a number")
        maxiter = nodes$maxiter
      } else {
        maxiter = 20
      }
      if(!is.null(nodes$movefactor))
      {
        is.valid(c("n","g"),c("1","1"),nodes$movefactor,
                 "field movefactor of nodes list should be either a number or a function of one argument")
        movefactor = nodes$movefactor
      } else {
        movefactor = defaultmovefactor
      }
      if(!is.null(nodes$removefactor))
      {
        is.valid(c("n","g"),c("1","1"),nodes$removefactor,
                 "field removefactor of nodes list should be either a number or a function of one argument")
        removefactor = nodes$removefactor
      } else {
        removefactor = defaultremovefactor
      }
      if(!is.null(nodes$createfactor))
      {
        is.valid(c("n","g"),c("1","1"),nodes$createfactor,
                 "field removefactor of nodes list should be either a number or a function of one argument")
        createfactor = nodes$createfactor
      } else {
        createfactor = defaultcreatefactor
      }
      if(!is.null(nodes$stopcrit))
      {
        is.valid("n","1",nodes$stopcrit,"the field stopcrit of nodes list should be a number")
        stopcrit = nodes$stopcrit
      } else {
        stopcrit = 0.005
      }
      if(!is.null(nodes$startnodes))
      {
        is.valid("m","+x2",nodes$startnodes,
                 "the field startnodes of nodes list should be a matrix of two columns")
        startnodes = nodes$startnodes
      } else
      {
        startnodes = NULL
      }
      if(!is.null(nodes$verbose))
      {
        is.valid("b","1",nodes$verbose,
                 "the field verbose of nodes list should be a logical")
        verbose = nodes$verbose
      } else
      {
        verbose = FALSE
      }
      if(!is.null(nodes$sleeptime))
      {
        is.valid("n","1",nodes$sleeptime,"the field sleeptime of nodes list should be a number")
        sleeptime = nodes$sleeptime
      } else {
        sleeptime = 0
      }
      if(!is.null(nodes$ytoxratio))
      {
        is.valid("n","1",nodes$ytoxratio,"the field ytoxratio of nodes list should be a number")
        setytoxratiowithscales(model,nodes$ytoxratio)
      } else {
        setytoxratiowithscales(model,1)
      }
      if(method=="FV")
      {
        add2DFVdiscr_unstructured(model,
                                  geomnodes(model,
                                            nodes$optdist,
                                            maxiter=maxiter,
                                            movefactor= movefactor,
                                            removefactor = removefactor,
                                            createfactor = createfactor,
                                            stopcrit = stopcrit,
                                            startnodes = startnodes,
                                            graphverbose=verbose,
                                            sleeptime=sleeptime))
      } else if(substr(method,1,2)=="FE")
      {
        add2DFEdiscr_unstructured(model,
                                  geomnodes(model,
                                            nodes$optdist,
                                            maxiter=maxiter,
                                            movefactor= movefactor,
                                            removefactor = removefactor,
                                            createfactor = createfactor,
                                            stopcrit = stopcrit,
                                            startnodes = startnodes,
                                            graphverbose=verbose,
                                            sleeptime=sleeptime))
      }
    }
  }
  if(method == "FV")
  {
    model$cellarea = c()
    for(i in 1:length(model$cellgeo))
    {
      if(nrow(model$cellgeo[[i]])>2)
      {
        model$cellarea[i] = GEO$area.of.poly(model$cellgeo[[i]])
      } else {
        model$cellarea[i]=0
      }
    }

    model$boundarypart = cbind(model$boundarypart,
                               matrix(0,nrow=nrow(model$boundarypart),ncol=2))
    colnames(model$boundarypart)[12]="domainlength"
    colnames(model$boundarypart)[13]="frac"
    for(i in 1:nrow(model$boundarypart))
    {
      bp = model$boundarypart[i,]
      sBC = model$BC[[bp["domainsegid"]]]
      model$boundarypart[i,"domainlength"]= bp["length"] *
        (bp["normalx"]*sBC$normal[1]+bp["normaly"]*sBC$normal[2])
      model$boundarypart[i,"frac"] =
        GEO$frac.with.polyisegnum(model$domain,bp["domainsegid"],c(bp["atx"],bp["aty"]))
    }
    model$Numnodes = nrow(model$nodes)
    model$Numinterfaces = nrow(model$cellinterfaces)
    model$states = rep(0,length=model$Numnodes)
    model$activenodes = 1:model$Numnodes
    attr(model,"class")="FV2D"
    do.numericalbc.FV2D(model)
  } else if (substr(method,1,2)=="FE")
  {
    model$Numnodes = nrow(model$nodes)
    model$states = rep(0,length=model$Numnodes)
    model$activenodes = 1:model$Numnodes
    model$Numelements = nrow(model$elements)
    model$boundarypart = cbind(model$boundarypart,
                               matrix(0,nrow=nrow(model$boundarypart),ncol=8))
    colnames(model$boundarypart) = c("nid1","nid2","domainsegid",
                                     "length","atx","aty",
                                     "normalx","normaly","domainlength","frac1","frac2")
    for(k in 1:nrow(model$boundarypart))
    {
      node1 = model$nodes[model$boundarypart[k,"nid1"],]
      node2 = model$nodes[model$boundarypart[k,"nid2"],]
      segid = model$boundarypart[k,"domainsegid"]
      model$boundarypart[k,"frac1"] =
        GEO$frac.with.polyisegnum(model$domain,segid,node1)
      model$boundarypart[k,"frac2"] =
        GEO$frac.with.polyisegnum(model$domain,segid,node2)
      length = sqrt((node1[1]-node2[1])^2+(node1[2]-node2[2])^2)
      model$boundarypart[k,"length"] = length
      atx = (node1[1]+node2[1])/2
      aty = (node1[2]+node2[2])/2
      model$boundarypart[k,"atx"] = atx
      model$boundarypart[k,"aty"] = aty
      normalx = -(node1[2]-node2[2])/length
      normaly = (node1[1]-node2[1])/length
      testp = model$doscale(c(atx,aty))+5*GEO$eps*c(normalx,normaly)
      if(!GEO$inside.poly(model$sydomain,testp))
      {
        normalx = - normalx
        normaly = - normaly
      }
      model$boundarypart[k,"normalx"] = normalx
      model$boundarypart[k,"normaly"] = normaly
      sBC = model$BC[[model$boundarypart[k,"domainsegid"]]]
      model$boundarypart[k,"domainlength"]= length *
        (normalx*sBC$normal[1]+normaly*sBC$normal[2])
    }
    if((method=="FElinear")|(method=="FE"))
    {
      model$Numgp=1
      model$gamma = matrix(0,nrow=1,ncol=3)
      model$weight = numeric(1)
      model$gamma[1,1] = 1/3
      model$gamma[1,2] = 1/3
      model$gamma[1,3] = 1/3
      model$weight[1] = 1.0
    } else if(method=="FEquadratic")
    {
      model$Numgp=3
      gamma1 = 0.6511
      gamma2 = 0.1745
      model$gamma = matrix(0,nrow=3,ncol=3)
      model$weight = numeric(3)
      model$gamma[1,1] = gamma1
      model$gamma[1,2] = gamma2
      model$gamma[1,3] = gamma2
      model$weight[1] = 1/3
      model$gamma[2,1] = gamma2
      model$gamma[2,2] = gamma1
      model$gamma[2,3] = gamma2
      model$weight[2] = 1/3
      model$gamma[3,1] = gamma2
      model$gamma[3,2] = gamma2
      model$gamma[3,3] = gamma1
      model$weight[3] = 1/3
    } else if (method=="FEcubic")
    {
      model$Numgp=4
      gamma1 = 1/3
      gamma2 = 0.797427
      gamma3 = 0.101287
      model$gamma = matrix(0,nrow=4,ncol=3)
      model$weight = numeric(4)
      model$gamma[1,1] = gamma1
      model$gamma[1,2] = gamma1
      model$gamma[1,3] = gamma1
      model$weight[1] = 0.444444
      model$gamma[2,1] = gamma2
      model$gamma[2,2] = gamma3
      model$gamma[2,3] = gamma3
      model$weight[2] = 0.185185
      model$gamma[3,1] = gamma3
      model$gamma[3,2] = gamma2
      model$gamma[3,3] = gamma3
      model$weight[3] = 0.185185
      model$gamma[4,1] = gamma3
      model$gamma[4,2] = gamma3
      model$gamma[4,3] = gamma2
      model$weight[4] = 0.185185
    } else if (method=="FEquartic")
    {
      model$Numgp=6
      gamma1 = 0.870152
      gamma2 = 0.064924
      gamma3 = 0.503749
      gamma4 = 0.248126
      model$gamma = matrix(0,nrow=6,ncol=3)
      model$weight = numeric(6)
      model$gamma[1,1] = gamma1
      model$gamma[1,2] = gamma2
      model$gamma[1,3] = gamma2
      model$weight[1] = 0.115952
      model$gamma[2,1] = gamma2
      model$gamma[2,2] = gamma1
      model$gamma[2,3] = gamma2
      model$weight[2] = 0.115952
      model$gamma[3,1] = gamma2
      model$gamma[3,2] = gamma2
      model$gamma[3,3] = gamma1
      model$weight[3] = 0.115952
      model$gamma[4,1] = gamma3
      model$gamma[4,2] = gamma4
      model$gamma[4,3] = gamma4
      model$weight[4] = 0.217382
      model$gamma[5,1] = gamma4
      model$gamma[5,2] = gamma3
      model$gamma[5,3] = gamma4
      model$weight[5] = 0.217382
      model$gamma[6,1] = gamma4
      model$gamma[6,2] = gamma4
      model$gamma[6,3] = gamma3
      model$weight[6] = 0.217382
    }
    model$elements = cbind(model$elements,
                           matrix(0,nrow=nrow(model$elements),ncol=17))
    colnames(model$elements) = c("nid1","nid2","nid3",
                                 "x1","x2","x3","y1","y2","y3",
                                 "area","dg11","dg12","dg21","dg22",
                                 "n1x","n1y","n2x","n2y","n3x","n3y")
    rownames(model$elements)=NULL
    # dsdx = dg11*(s2-s1)+dg12*(s3-s2)
    # dsdy = dg21*(s2-s1)+dg22*(s3-s2)
    for(k in 1:nrow(model$elements))
    {
      x1 = model$nodes[model$elements[k,1],1]
      y1 = model$nodes[model$elements[k,1],2]
      x2 = model$nodes[model$elements[k,2],1]
      y2 = model$nodes[model$elements[k,2],2]
      x3 = model$nodes[model$elements[k,3],1]
      y3 = model$nodes[model$elements[k,3],2]
      model$elements[k,"x1"]=x1
      model$elements[k,"y1"]=y1
      model$elements[k,"x2"]=x2
      model$elements[k,"y2"]=y2
      model$elements[k,"x3"]=x3
      model$elements[k,"y3"]=y3
      det = x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2
      model$elements[k,"area"] = 0.5*abs(det)
      model$elements[k,"dg11"] = (y3-y1)/det
      model$elements[k,"dg12"] = (y1-y2)/det
      model$elements[k,"dg21"] = (x1-x3)/det
      model$elements[k,"dg22"] = (x2-x1)/det
      mfactor = sign(det)/2 #sqrt(2) # was /2
      m1 = mfactor*c(y2-y3,x3-x2)
      #m1 = m1/sqrt(m1[1]^2+m1[2]^2)
      model$elements[k,"n1x"] = m1[1]
      model$elements[k,"n1y"] = m1[2]
      m2 = mfactor*c(y3-y1,x1-x3)
      #m2 = m2/sqrt(m2[1]^2+m2[2]^2)
      model$elements[k,"n2x"] = m2[1]
      model$elements[k,"n2y"] = m2[2]
      m3 = mfactor*c(y1-y2,x2-x1)
      #m3 = m3/sqrt(m3[1]^2+m3[2]^2)
      model$elements[k,"n3x"] = m3[1]
      model$elements[k,"n3y"] = m3[2]
    }
    model$gpointelx = matrix(0,nrow=model$Numelements,ncol=model$Numgp)
    model$gpointely = matrix(0,nrow=model$Numelements,ncol=model$Numgp)
    for(i in 1:model$Numelements)
    {
      for(j in 1:model$Numgp)
      {
        model$gpointelx[i,j]=
          model$gamma[j,1]*model$nodes[model$elements[i,"nid1"],1]+
          model$gamma[j,2]*model$nodes[model$elements[i,"nid2"],1]+
          model$gamma[j,3]*model$nodes[model$elements[i,"nid3"],1]
        model$gpointely[i,j]=
          model$gamma[j,1]*model$nodes[model$elements[i,"nid1"],2]+
          model$gamma[j,2]*model$nodes[model$elements[i,"nid2"],2]+
          model$gamma[j,3]*model$nodes[model$elements[i,"nid3"],2]
      }
    }
    attr(model,"class")="FElinear2D"
    do.numericalbc.GENFE2D(model)
  }
  do.numericalpointfluxes(model)
  do.numericallinefluxes(model)
  make.Jacobstore(model)
  model$sindepmisfits = rep(0,model$Numnodes)
  model$misfits = rep(0,model$Numnodes)
}

#' @export set.discretisation.FV2D
set.discretisation.FV2D = set.discretisation.FLOW2D

#' @export set.discretisation.FElinear2D
set.discretisation.FElinear2D = set.discretisation.FLOW2D

#' @export set.discretisation.FEquadratic2D
set.discretisation.FEquadratic2D = set.discretisation.FLOW2D

#' @export set.discretisation.FEcubic2D
set.discretisation.FEcubic2D = set.discretisation.FLOW2D

#' @export set.discretisation.FEquartic2D
set.discretisation.FEquartic2D = set.discretisation.FLOW2D




#
#numerical boundary condition
#

check.acceptability.fixedstates = function(model)
{
  result = TRUE
  for(i in 1:model$Numnodes)
  {
    if(!is.element(i,model$activenodes))
    {
      if(!model$isacceptable(model$nodes[i,1],model$nodes[i,2],model$states[i]))
      {
        result=FALSE
        warning(paste("fixed state BC at (",model$nodes[i,1],
                      ",",model$nodes[i,2],") has value",
                      model$states[i],"wich is unacceptable"),call.=FALSE)
      }
    }
  }
  return(result)
}

do.numericalbc = function(model,where,value)
  UseMethod("do.numericalbc")

do.numericalbc.FV2D = function(model)
{
  model$activenodes = 1:model$Numnodes
  for(i in 1:nrow(model$boundarypart))
  {
    bp = model$boundarypart[i,]
    segBC = model$BC[[bp["domainsegid"]]]
    if(segBC$type=="fixedstate")
    {
      model$activenodes = setdiff(model$activenodes,bp["nid"])
      model$states[bp["nid"]]=segBC$value(bp["frac"])
    }
  }
  model$activenodes = sort(model$activenodes)
  return(check.acceptability.fixedstates(model))
}

do.numericalbc.GENFE2D = function(model)
{
  model$activenodes = 1:model$Numnodes
  for(i in 1:nrow(model$boundarypart))
  {
    bp = model$boundarypart[i,]
    segBC = model$BC[[bp["domainsegid"]]]
    if(segBC$type=="fixedstate")
    {
      model$activenodes = setdiff(model$activenodes,bp[c("nid1","nid2")])
      model$states[bp["nid1"]]=segBC$value(bp["frac1"])
      model$states[bp["nid2"]]=segBC$value(bp["frac2"])
    }
  }
  model$activenodes = sort(model$activenodes)
  return(check.acceptability.fixedstates(model))
}
do.numericalbc.FElinear2D = do.numericalbc.GENFE2D
do.numericalbc.FEquadratic2D = do.numericalbc.GENFE2D
do.numericalbc.FEcubic2D = do.numericalbc.GENFE2D
do.numericalbc.FEquartic2D = do.numericalbc.GENFE2D

#' @export plot.BC.id.FV2D
plot.BC.id.FV2D = plot.BC.id.FLOW2D

#' @export plot.BC.id.FElinear2D
plot.BC.id.FElinear2D = plot.BC.id.FLOW2D

#' @export plot.BC.id.FEquadratic2D
plot.BC.id.FEquadratic2D = plot.BC.id.FLOW2D

#' @export plot.BC.id.FEcubic2D
plot.BC.id.FEcubic2D = plot.BC.id.FLOW2D

#' @export plot.BC.id.FEquartic2D
plot.BC.id.FEquartic2D = plot.BC.id.FLOW2D

set.BC.fixedstate.GENFVFE2D= function(model,where,value)
{
  set.BC.fixedstate.FLOW2D(model,where,value)
  if(!do.numericalbc(model))
  {
    print("unacceptable fixed state set")
  }
}

#' @export set.BC.fixedstate.FElinear2D
set.BC.fixedstate.FElinear2D = set.BC.fixedstate.GENFVFE2D

#' @export set.BC.fixedstate.FEquadratic2D
set.BC.fixedstate.FEquadratic2D = set.BC.fixedstate.GENFVFE2D

#' @export set.BC.fixedstate.FEcubic2D
set.BC.fixedstate.FEcubic2D = set.BC.fixedstate.GENFVFE2D

#' @export set.BC.fixedstate.FEquartic2D
set.BC.fixedstate.FEquartic2D = set.BC.fixedstate.GENFVFE2D

#' @export set.BC.fixedstate.FV2D
set.BC.fixedstate.FV2D = set.BC.fixedstate.GENFVFE2D


set.BC.fixedflux.GENFVFE2D= function(model,where,value)
{
  set.BC.fixedflux.FLOW2D(model,where,value)
  do.numericalbc(model)
}

#' @export set.BC.fixedflux.FElinear2D
set.BC.fixedflux.FElinear2D = set.BC.fixedflux.GENFVFE2D

#' @export set.BC.fixedflux.FEquadratic2D
set.BC.fixedflux.FEquadratic2D = set.BC.fixedflux.GENFVFE2D

#' @export set.BC.fixedflux.FEcubic2D
set.BC.fixedflux.FEcubic2D = set.BC.fixedflux.GENFVFE2D

#' @export set.BC.fixedflux.FEquartic2D
set.BC.fixedflux.FEquartic2D = set.BC.fixedflux.GENFVFE2D

#' @export set.BC.fixedflux.FV2D
set.BC.fixedflux.FV2D = set.BC.fixedflux.GENFVFE2D

set.BC.fluxstate.GENFVFE2D = function(model,where,value)
{
  set.BC.fluxstate.FLOW2D(model,where,value)
  dummy = do.numericalbc(model)
}

#' @export set.BC.fluxstate.FElinear2D
set.BC.fluxstate.FElinear2D = set.BC.fluxstate.GENFVFE2D

#' @export set.BC.fluxstate.FEquadratic2D
set.BC.fluxstate.FEquadratic2D = set.BC.fluxstate.GENFVFE2D

#' @export set.BC.fluxstate.FEcubic2D
set.BC.fluxstate.FEcubic2D = set.BC.fluxstate.GENFVFE2D

#' @export set.BC.fluxstate.FEquartic2D
set.BC.fluxstate.FEquartic2D = set.BC.fluxstate.GENFVFE2D

#' @export set.BC.fluxstate.FV2D
set.BC.fluxstate.FV2D = set.BC.fluxstate.GENFVFE2D


set.BC.fixedvectorflux.GENFVFE2D = function(model,where,value)
{
  set.BC.fixedvectorflux.FLOW2D(model,where,value)
  do.numericalbc(model)
}

#' @export set.BC.fixedvectorflux.FElinear2D
set.BC.fixedvectorflux.FElinear2D = set.BC.fixedvectorflux.GENFVFE2D

#' @export set.BC.fixedvectorflux.FEquadratic2D
set.BC.fixedvectorflux.FEquadratic2D = set.BC.fixedvectorflux.GENFVFE2D

#' @export set.BC.fixedvectorflux.FEcubic2D
set.BC.fixedvectorflux.FEcubic2D = set.BC.fixedvectorflux.GENFVFE2D

#' @export set.BC.fixedvectorflux.FEquartic2D
set.BC.fixedvectorflux.FEquartic2D = set.BC.fixedvectorflux.GENFVFE2D

#' @export set.BC.fixedvectorflux.FV2D
set.BC.fixedvectorflux.FV2D = set.BC.fixedvectorflux.GENFVFE2D


set.BC.vectorfluxstate.GENFVFE2D = function(model,where,value)
{
  set.BC.vectorfluxstate.FLOW2D(model,where,value)
  do.numericalbc(model)
}

#' @export set.BC.vectorfluxstate.FElinear2D
set.BC.vectorfluxstate.FElinear2D = set.BC.vectorfluxstate.GENFVFE2D

#' @export set.BC.vectorfluxstate.FEquadratic2D
set.BC.vectorfluxstate.FEquadratic2D = set.BC.vectorfluxstate.GENFVFE2D

#' @export set.BC.vectorfluxstate.FEcubic2D
set.BC.vectorfluxstate.FEcubic2D = set.BC.vectorfluxstate.GENFVFE2D

#' @export set.BC.vectorfluxstate.FEquartic2D
set.BC.vectorfluxstate.FEquartic2D = set.BC.vectorfluxstate.GENFVFE2D

#' @export set.BC.vectorfluxstate.FV2D
set.BC.vectorfluxstate.FV2D = set.BC.vectorfluxstate.GENFVFE2D

#
# # allow also new spatialfluxes in FE FV part
#

#' @export add.spatialflux.FElinear2D
add.spatialflux.FElinear2D = add.spatialflux.FLOW2D

#' @export add.spatialflux.FEquadratic2D
add.spatialflux.FEquadratic2D = add.spatialflux.FLOW2D

#' @export add.spatialflux.FEcubic2D
add.spatialflux.FEcubic2D = add.spatialflux.FLOW2D

#' @export add.spatialflux.FEquartic2D
add.spatialflux.FEquartic2D = add.spatialflux.FLOW2D

#' @export add.spatialflux.FV2D
add.spatialflux.FV2D = add.spatialflux.FLOW2D


# allow also removal of spatial fluxes in FE FV part

#' @export rem.spatialflux.FElinear2D
rem.spatialflux.FElinear2D = rem.spatialflux.FLOW2D

#' @export rem.spatialflux.FEquadratic2D
rem.spatialflux.FEquadratic2D = rem.spatialflux.FLOW2D

#' @export rem.spatialflux.FEcubic2D
rem.spatialflux.FEcubic2D = rem.spatialflux.FLOW2D

#' @export rem.spatialflux.FEquartic2D
rem.spatialflux.FEquartic2D = rem.spatialflux.FLOW2D

#' @export rem.spatialflux.FV2D
rem.spatialflux.FV2D = rem.spatialflux.FLOW2D

#
# numerical pointflux localisation
#
do.numericalpointfluxes = function(model)
  UseMethod("do.numericalpointfluxes")
#
do.numericalpointfluxes.GENFE2D = function(model)
{
  for(i in seq(along=model$sindeppntxflux))
  {
    ax = model$sindeppntxflux[[i]]$at[1]
    ay = model$sindeppntxflux[[i]]$at[2]
    found = FALSE
    for(j in 1:model$Numelements)
    {
      e = model$elements[j,]
      p2 = e[["dg11"]]*(ax-e[["x1"]])+e[["dg21"]]*(ay-e[["y1"]])
      p3 = e[["dg12"]]*(ax-e[["x1"]])+e[["dg22"]]*(ay-e[["y1"]])
      p1 = 1-p2-p3
      if((p1 >= 0)&(p2 >= 0)&(p3 >= 0))
      {
        found = TRUE
        model$sindeppntxflux[[i]]$indelem = j
        model$sindeppntxflux[[i]]$p1 = p1
        model$sindeppntxflux[[i]]$p2 = p2
        model$sindeppntxflux[[i]]$p3 = p3
      }
      if(found) break
    }
    if(!found)
    {
      # point flux outside of discrete domain, take nearest node
      nodeid = which.min((model$nodes[,1]-model$sindeppntxflux[[i]]$at[1])^2+
                           (model$nodes[,2]-model$sindeppntxflux[[i]]$at[2])^2)
      # now find any element in which this node lies
      k = which(model$elements[,"nid1"]==nodeid)
      if(length(k)>0)
      {
        model$sindeppntxflux[[i]]$indelem = k[1]
        model$sindeppntxflux[[i]]$p1 = 1
        model$sindeppntxflux[[i]]$p2 = 0
        model$sindeppntxflux[[i]]$p3 = 0
        found = TRUE
      }
      if(!found)
      {
        k = which(model$elements[,"nid2"]==nodeid)
        if(length(k)>0)
        {
          model$sindeppntxflux[[i]]$indelem = k[1]
          model$sindeppntxflux[[i]]$p1 = 0
          model$sindeppntxflux[[i]]$p2 = 1
          model$sindeppntxflux[[i]]$p3 = 0
          found = TRUE
        }
      }
      if(!found)
      {
        k = which(model$elements[,"nid3"]==nodeid)
        if(length(k)>0)
        {
          model$sindeppntxflux[[i]]$indelem = k[1]
          model$sindeppntxflux[[i]]$p1 = 0
          model$sindeppntxflux[[i]]$p2 = 0
          model$sindeppntxflux[[i]]$p3 = 1
        }
      }
    }
  }
  for(i in seq(along=model$sdeppntxflux))
  {
    ax = model$sdeppntxflux[[i]]$at[1]
    ay = model$sdeppntxflux[[i]]$at[2]
    found = FALSE
    for(j in 1:model$Numelements)
    {
      e = model$elements[j,]
      p2 = e[["dg11"]]*(ax-e[["x1"]])+e[["dg21"]]*(ay-e[["y1"]])
      p3 = e[["dg12"]]*(ax-e[["x1"]])+e[["dg22"]]*(ay-e[["y1"]])
      p1 = 1-p2-p3
      if((p1 >= 0)&(p2 >= 0)&(p3 >= 0))
      {
        found=TRUE
        model$sdeppntxflux[[i]]$indelem = j
        model$sdeppntxflux[[i]]$p1 = p1
        model$sdeppntxflux[[i]]$p2 = p2
        model$sdeppntxflux[[i]]$p3 = p3
      }
      if(found) break
    }
    if(!found)
    {
      # point flux outside of discrete domain, take nearest node
      nodeid = which.min((model$nodes[,1]-model$sdeppntxflux[[i]]$at[1])^2+
                           (model$nodes[,2]-model$sdeppntxflux[[i]]$at[2])^2)
      # now find any element in which this node lies
      k = which(model$elements[,"nid1"]==nodeid)
      if(length(k)>0)
      {
        model$sdeppntxflux[[i]]$indelem = k[1]
        model$sdeppntxflux[[i]]$p1 = 1
        model$sdeppntxflux[[i]]$p2 = 0
        model$sdeppntxflux[[i]]$p3 = 0
        found = TRUE
      }
      if(!found)
      {
        k = which(model$elements[,"nid2"]==nodeid)
        if(length(k)>0)
        {
          model$sdeppntxflux[[i]]$indelem = k[1]
          model$sdeppntxflux[[i]]$p1 = 0
          model$sdeppntxflux[[i]]$p2 = 1
          model$sdeppntxflux[[i]]$p3 = 0
          found = TRUE
        }
      }
      if(!found)
      {
        k = which(model$elements[,"nid3"]==nodeid)
        if(length(k)>0)
        {
          model$sdeppntxflux[[i]]$indelem = k[1]
          model$sdeppntxflux[[i]]$p1 = 0
          model$sdeppntxflux[[i]]$p2 = 0
          model$sdeppntxflux[[i]]$p3 = 1
        }
      }
    }
  }
}
#
#
do.numericalpointfluxes.FElinear2D = do.numericalpointfluxes.GENFE2D
do.numericalpointfluxes.FEquadratic2D = do.numericalpointfluxes.GENFE2D
do.numericalpointfluxes.FEcubic2D = do.numericalpointfluxes.GENFE2D
do.numericalpointfluxes.FEquartic2D = do.numericalpointfluxes.GENFE2D
#
do.numericalpointfluxes.FV2D = function(model)
{
  for(i in seq(along=model$sindeppntxflux))
  {
    model$sindeppntxflux[[i]]$nodeid =
      which.min((model$nodes[,1]-model$sindeppntxflux[[i]]$at[1])^2+
                  (model$nodes[,2]-model$sindeppntxflux[[i]]$at[2])^2)
  }
  for(i in seq(along=model$sdeppntxflux))
  {
    model$sdeppntxflux[[i]]$nodeid =
      which.min((model$nodes[,1]-model$sdeppntxflux[[i]]$at[1])^2+
                  (model$nodes[,2]-model$sdeppntxflux[[i]]$at[2])^2)
  }
}

#
# # allow to add point fluxes to numerical models
#
add.pointflux.GENFVFE2D = function(model,at,rate,name="")
{
  add.pointflux.FLOW2D(model,at,rate,name)
  do.numericalpointfluxes(model)
}
#
#' @export add.pointflux.FElinear2D
add.pointflux.FElinear2D = add.pointflux.GENFVFE2D

#' @export add.pointflux.FEquadratic2D
add.pointflux.FEquadratic2D = add.pointflux.GENFVFE2D

#' @export add.pointflux.FEcubic2D
add.pointflux.FEcubic2D = add.pointflux.GENFVFE2D

#' @export add.pointflux.FEquartic2D
add.pointflux.FEquartic2D = add.pointflux.GENFVFE2D

#' @export add.pointflux.FV2D
add.pointflux.FV2D = add.pointflux.GENFVFE2D

# allow also removal of point fluxes in FE FV part

#' @export rem.pointflux.FElinear2D
rem.pointflux.FElinear2D = rem.pointflux.FLOW2D

#' @export rem.pointflux.FEquadratic2D
rem.pointflux.FEquadratic2D = rem.pointflux.FLOW2D

#' @export rem.pointflux.FEcubic2D
rem.pointflux.FEcubic2D = rem.pointflux.FLOW2D

#' @export rem.pointflux.FEquartic2D
rem.pointflux.FEquartic2D = rem.pointflux.FLOW2D

#' @export rem.pointflux.FV2D
rem.pointflux.FV2D = rem.pointflux.FLOW2D


# initialisation

#' Initialize a discrete model
#' @description
#' With the help of the argument \code{init} all the state values
#' for the active nodes (i.e. nodes which where not given a fixed state
#' boundary condition) the model receive a value. As in general the solution method is
#' iterative, a good initialization may be important.
#' @param model a two dimensional flow model of the class  \code{[A]FElinear2D},
#'  \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param init can be either be either
#' \itemize{
#' \item a number: all the states will be initialized to this constant
#' \item a vector of numbers, whose values (in the order of the nodes) will
#' be asigned to the states
#' \item a function of two arguments (x,y); for each node the state value is
#' calculated by applying this function to its nodal coordinates
#' }
#' @rdname do.initialize
#' @export do.initialize
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedstate(M,"SW",1)
#' set.discretisation(M,nodes=list(type="geomgen",optdist=2),method="FV")
#' do.initialize(M,1.5)
#' plot(M,fill="state")

do.initialize =  function(model,init)
  UseMethod("do.initialize")

do.initialize.GENFVFE2D = function(model,init)
{
  c= is.valid(c("n","g"),c("+",2),init,
              "init argument should be a constant, a vector or a function of two arguments:(x,y)")
  if(c==1)
  {
    if(length(init)>1)
    {
      if(length(init)!= model$Numnodes)
      {
        stopmessage = paste(model$Numnodes, "= num nodes is not equal to the length of init vector =",
                            length(init))
        stop(stopmessage,call.=FALSE)
      }
      for(i in model$activenodes)
      {
        model$states[i] = init[i]
      }
    } else {
      for(i in model$activenodes)
      {
        model$states[i] = init
      }
    }
  } else {
    for(i in model$activenodes)
    {
      model$states[i] = init(model$nodes[i,1],model$nodes[i,2])
    }
  }
}

#' @export do.initialize.FLOW2D
do.initialize.FLOW2D = function(model,...){
  discretizationwarning();
}

#' @export do.initialize.FElinear2D
do.initialize.FElinear2D = do.initialize.GENFVFE2D

#' @export do.initialize.FEquadratic2D
do.initialize.FEquadratic2D = do.initialize.GENFVFE2D

#' @export do.initialize.FEcubic2D
do.initialize.FEcubic2D = do.initialize.GENFVFE2D

#' @export do.initialize.FEquartic2D
do.initialize.FEquartic2D = do.initialize.GENFVFE2D

#' @export do.initialize.FV2D
do.initialize.FV2D = do.initialize.GENFVFE2D
#
# checking for acceptability

statesareacceptable =  function(model)
  UseMethod("statesareacceptable")

statesareacceptable.FV2D = function(model)
{
  for(i in seq(along=model$states))
  {
    if(!model$isacceptable(model$nodes[i,1],model$nodes[i,2],
                           model$states[i]))
    {
      message = paste("node=",model$nodes[i],"state=",model$states[i],
                      "is unacceptable")
      return(message)
    }
  }
  return("")
}

statesareacceptable.GENFE2D = function(model)
{
  # first the states in the nodes
  mn = statesareacceptable.FV2D(model)
  if(length(mn)>0)
  {
    return(mn)
  }
  # now in the integrationpoints
  for(i in seq(along=model$elements))
  {
    for(k in 1:model$Numgp)
    {
      ints = model$gamma[k,1]*model$states[model$elements[i,"nid1"]]+
        model$gamma[k,2]*model$states[model$elements[i,"nid2"]]+
        model$gamma[k,3]*model$states[model$elements[i,"nid3"]]
      if(!model$isacceptable(model$gpointelx[i,k],model$gpointely[i,k],ints))
      {
        message = paste("integration node=",
                        model$gpointelx[i,k],model$gpointely[i,k],
                        model$nodes[i],"state=",ints,
                        "is unacceptable")
        return(message)
      }
    }
  }
  return("")
}

statesareacceptable.FElinear2D = statesareacceptable.GENFE2D
statesareacceptable.FEquadratic2D = statesareacceptable.GENFE2D
statesareacceptable.FEcubic2D = statesareacceptable.GENFE2D
statesareacceptable.FEquartic2D = statesareacceptable.GENFE2D

#
# calculation of state independent misfits
#

calc.sindepmisfits =  function(model)
  UseMethod("calc.sindepmisfits")

calc.sindepmisfits.GENFE2D = function(model)
{
  model$sindepmisfits[] = 0

  isef = seq(along=model$sindepspatxflux)

  for(i in 1:model$Numelements)
  {
    nid1 = model$elements[i,"nid1"]
    nid2 = model$elements[i,"nid2"]
    nid3 = model$elements[i,"nid3"]
    A = model$elements[i,"area"]
    for(k in 1:model$Numgp)
    {
      for(j in isef)
      {
        value =  model$sindepspatxflux[[j]](model$gpointelx[i,k],
                                            model$gpointely[i,k])
        model$sindepmisfits[nid1] =
          model$sindepmisfits[nid1]+model$weight[k]*A*model$gamma[k,1]*value
        model$sindepmisfits[nid2] =
          model$sindepmisfits[nid2]+model$weight[k]*A*model$gamma[k,2]*value
        model$sindepmisfits[nid3] =
          model$sindepmisfits[nid3]+model$weight[k]*A*model$gamma[k,3]*value
      }
    }

  }

  # now doing point external fluxes

  ipef = seq(along=model$sindeppntxflux)
  for(i in ipef)
  {
    pef = model$sindeppntxflux[[i]]
    el = model$elements[pef$indelem,]
    nid1 = el[["nid1"]]
    nid2 = el[["nid2"]]
    nid3 = el[["nid3"]]
    value = pef$func()
    model$sindepmisfits[nid1] =
      model$sindepmisfits[nid1] + pef$p1 * value
    model$sindepmisfits[nid2] =
      model$sindepmisfits[nid2]+ pef$p2 * value
    model$sindepmisfits[nid3] =
      model$sindepmisfits[nid3]+ pef$p3 * value
  }

  # now doing line external fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sindep = lineflux$sindep
    for(j in seq(along=sindep[,1]))
    {
      v = eval.sindep.lineflux(lineflux,sindep[j,"pointnum"])*
        sindep[j,"weight"]
      model$sindepmisfits[sindep[j,"n1"]] =
        model$sindepmisfits[sindep[j,"n1"]]+v*sindep[j,"p1"]
      model$sindepmisfits[sindep[j,"n2"]] =
        model$sindepmisfits[sindep[j,"n2"]]+v*sindep[j,"p2"]
      model$sindepmisfits[sindep[j,"n3"]] =
        model$sindepmisfits[sindep[j,"n3"]]+v*sindep[j,"p3"]
    }
  }

  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nodeid1 = model$boundarypart[i,"nid1"]
    nodeid2 = model$boundarypart[i,"nid2"]
    segBC = model$BC[[segid]]
    if(segBC$type=="fixedflux")
    {
      value = model$boundarypart[i,"domainlength"]*segBC$func()
      model$sindepmisfits[nodeid1] =
        model$sindepmisfits[nodeid1]+0.5*value
      model$sindepmisfits[nodeid2] =
        model$sindepmisfits[nodeid2]+0.5*value
    }
  }
}

calc.sindepmisfits.FElinear2D =  calc.sindepmisfits.GENFE2D
calc.sindepmisfits.FEquadratic2D =  calc.sindepmisfits.GENFE2D
calc.sindepmisfits.FEcubic2D =  calc.sindepmisfits.GENFE2D
calc.sindepmisfits.FEquartic2D =  calc.sindepmisfits.GENFE2D

calc.sindepmisfits.FV2D = function(model)
{
  model$sindepmisfits[] = 0
  # now doing spatial external fluxes
  isef = seq(along=model$sindepspatxflux)
  for(i in 1:model$Numnodes)
  {
    A = model$cellarea[i]
    for(j in isef)
    {
      model$sindepmisfits[i] = model$sindepmisfits[i]+
        A*model$sindepspatxflux[[j]](model$nodes[i,1],model$nodes[i,2])
    }
  }
  # now doing point external fluxes
  ipef = seq(along=model$sindeppntxflux)
  for(i in ipef)
  {
    pef = model$sindeppntxflux[[i]]
    j = pef$nodeid
    model$sindepmisfits[j] = model$sindepmisfits[j]+
      pef$func()
  }
  # now doing line external fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sindep = lineflux$sindep
    for(j in seq(along=sindep[,1]))
    {
      v = eval.sindep.lineflux(lineflux,sindep[j,"pointnum"])*
        sindep[j,"weight"]
      model$sindepmisfits[sindep[j,"nodenum"]] =
        model$sindepmisfits[sindep[j,"nodenum"]]+v
    }
  }
  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nodeid = model$boundarypart[i,"nid"]
    segBC = model$BC[[segid]]
    if(segBC$type=="fixedflux")
    {
      value = model$boundarypart[i,"domainlength"]*segBC$func()
      model$sindepmisfits[nodeid] = model$sindepmisfits[nodeid]+value
    }
  }
}
#
# calculation of state dependent misfits
#

calc.modmisfits =  function(model)
  UseMethod("calc.modmisfits")

calc.modmisfits.GENFE2D = function(model)
{
  model$misfits[] = model$sindepmisfits[]

  isef = seq(along=model$sdepspatxflux)

  for(i in 1:model$Numelements)
  {
    nid1 = model$elements[i,"nid1"]
    nid2 = model$elements[i,"nid2"]
    nid3 = model$elements[i,"nid3"]
    A = model$elements[i,"area"]


    gradx = model$elements[i,"dg11"]*(model$states[nid2]-model$states[nid1])+
      model$elements[i,"dg12"]*(model$states[nid3]-model$states[nid1])

    grady = model$elements[i,"dg21"]*(model$states[nid2]-model$states[nid1])+
      model$elements[i,"dg22"]*(model$states[nid3]-model$states[nid1])

    gradsize = sqrt(gradx^2+grady^2)
    if(gradsize>0)
    {
      flowdist1 = (gradx*model$elements[i,"n1x"]+
                     grady*model$elements[i,"n1y"])/gradsize
      flowdist2 = (gradx*model$elements[i,"n2x"]+
                     grady*model$elements[i,"n2y"])/gradsize
      flowdist3 = (gradx*model$elements[i,"n3x"]+
                     grady*model$elements[i,"n3y"])/gradsize
    } else {
      # should no happen
      flowdist1 = 1/3
      flowdist2 = 1/3
      flowdist3 = 1/3
    }
    fluxint1 = 0
    fluxint2 = 0
    fluxint3 = 0
    for(k in 1:model$Numgp)
    {
      ints = model$gamma[k,1]*model$states[nid1]+
        model$gamma[k,2]*model$states[nid2]+  model$gamma[k,3]*model$states[nid3]

      fluxsize = model$weight[k]*model$systemflux(model$gpointelx[i,k],
                                                  model$gpointely[i,k],
                                                  ints,gradsize)
      fluxint1 = flowdist1*fluxsize
      fluxint2 = flowdist2*fluxsize
      fluxint3 = flowdist3*fluxsize

      for(j in isef)
      {
        value =  model$sdepspatxflux[[j]](model$gpointelx[i,k],
                                          model$gpointely[i,k],ints)
        fluxint1 = fluxint1+model$weight[k]*A*model$gamma[k,1]*value
        fluxint2 = fluxint2+model$weight[k]*A*model$gamma[k,2]*value
        fluxint3 = fluxint3+model$weight[k]*A*model$gamma[k,3]*value
      }
    }
    model$misfits[nid1] = model$misfits[nid1] + fluxint1
    model$misfits[nid2] = model$misfits[nid2] + fluxint2
    model$misfits[nid3] = model$misfits[nid3] + fluxint3
  }
  # now doing point external fluxes
  ipef = seq(along=model$sdeppntxflux)
  for(i in ipef)
  {
    pef = model$sdeppntxflux[[i]]
    el = model$elements[pef$indelem,]
    nid1 = el[["nid1"]]
    nid2 = el[["nid2"]]
    nid3 = el[["nid3"]]
    sint = pef$p1 * model$states[nid1]+
      pef$p2 * model$states[nid2]+
      pef$p3 * model$states[nid3]
    value = pef$func(sint)

    model$misfits[nid1] = model$misfits[nid1]+ pef$p1 * value
    model$misfits[nid2] = model$misfits[nid2]+ pef$p2 * value
    model$misfits[nid3] = model$misfits[nid3]+ pef$p3 * value
  }
  # now doing line external fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      svalue = sdep[j,"p1"] * model$states[sdep[j,"n1"]]+
        sdep[j,"p2"] * model$states[sdep[j,"n2"]]+
        sdep[j,"p3"] * model$states[sdep[j,"n3"]]
      nodesvalue = sdep[j,"p1"] * model$nodes[sdep[j,"n1"],]+
        sdep[j,"p2"] * model$nodes[sdep[j,"n2"],]+
        sdep[j,"p3"] * model$nodes[sdep[j,"n3"],]
      v = lineflux$rates[[ sdep[j,"pointnum"] ]](
        nodesvalue[1],nodesvalue[2],svalue)*
        sdep[j,"weight"]
      model$misfits[sdep[j,"n1"]] =
        model$misfits[sdep[j,"n1"]]+v*sdep[j,"p1"]
      model$misfits[sdep[j,"n2"]] =
        model$misfits[sdep[j,"n2"]]+v*sdep[j,"p2"]
      model$misfits[sdep[j,"n3"]] =
        model$misfits[sdep[j,"n3"]]+v*sdep[j,"p3"]
    }
  }
  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nodeid1 = model$boundarypart[i,"nid1"]
    nodeid2 = model$boundarypart[i,"nid2"]
    segBC = model$BC[[segid]]
    if(segBC$type=="fluxstate") {
      statemid = (model$states[nodeid1]+model$states[nodeid2])/2
      value = model$boundarypart[i,"domainlength"]*segBC$func(statemid)
      model$misfits[nodeid1] = model$misfits[nodeid1]+ 0.5 * value
      model$misfits[nodeid2] = model$misfits[nodeid2]+ 0.5 * value
    }
  }
}

calc.modmisfits.FElinear2D =  calc.modmisfits.GENFE2D
calc.modmisfits.FEquadratic2D =  calc.modmisfits.GENFE2D
calc.modmisfits.FEcubic2D =  calc.modmisfits.GENFE2D
calc.modmisfits.FEquartic2D =  calc.modmisfits.GENFE2D
#
calc.modmisfits.FV2D = function(model)
{
  model$misfits[] = model$sindepmisfits[]
  for(i in 1:model$Numinterfaces)
  {
    x = model$cellinterfaces[[i,"x"]]
    y = model$cellinterfaces[[i,"y"]]
    ni1 = model$cellinterfaces[[i,"ni1"]]
    ni2 = model$cellinterfaces[[i,"ni2"]]
    l = model$cellinterfaces[[i,"facelength"]]
    L = model$cellinterfaces[[i,"nodedistance"]]
    grad = (model$states[ni2]-model$states[ni1])/L
    mids = (model$states[ni2]+model$states[ni1])/2
    flux = l*model$systemflux(x,y,mids,grad)
    model$misfits[ni1] = model$misfits[ni1]-flux
    model$misfits[ni2] = model$misfits[ni2]+flux
  }
  # now doing spatial external fluxes
  isef = seq(along=model$sdepspatxflux)
  for(i in 1:model$Numnodes)
  {
    A = model$cellarea[i]
    for(j in isef)
    {
      model$misfits[i] = model$misfits[i]+
        A*model$sdepspatxflux[[j]](model$nodes[i,1],model$nodes[i,2],model$states[i])
    }
  }

  # now doing point external fluxes
  ipef = seq(along=model$sdeppntxflux)
  for(i in ipef)
  {
    pef = model$sdeppntxflux[[i]]
    j = pef$nodeid
    model$misfits[j] = model$misfits[j]+
      pef$func(model$states[j])
  }
  # now doing line external fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      nn = sdep[j,"nodenum"]
      v = lineflux$rates[[ sdep[j,"pointnum"] ]](
        model$nodes[nn,1],
        model$nodes[nn,2],
        model$states[nn])*
        sdep[j,"weight"]
      model$misfits[nn] = model$misfits[nn]+v
    }
  }
  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nodeid = model$boundarypart[i,"nid"]
    segBC = model$BC[[segid]]
    if(segBC$type=="fluxstate")
    {
      value = model$boundarypart[i,"domainlength"]*segBC$func(model$states[nodeid])
      model$misfits[nodeid] = model$misfits[nodeid]+value
    }
  }
}

#' Calculate misfits
#'
#' Calculates the misfits, i.e. how much the balances calculated for each node
#' with the current state values differ from zero. If the states are close to the
#' solution of the flow problem, these numbers should be small.
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a vector with for each node the calculated misfit
#' @rdname calc.misfits
#' @export calc.misfits
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' hist(calc.misfits(M))
calc.misfits =  function(model)
  UseMethod("calc.misfits")


calc.misfits.GENFEFV2D= function(model)
{
  calc.sindepmisfits(model)
  calc.modmisfits(model)
  result = rep(0,model$Numnodes)
  result[model$activenodes] = model$misfits[model$activenodes]
  return(model$misfits)
}

#' @export calc.misfits.FLOW2D
calc.misfits.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export calc.misfits.FElinear2D
calc.misfits.FElinear2D = calc.misfits.GENFEFV2D

#' @export calc.misfits.FEquadratic2D
calc.misfits.FEquadratic2D = calc.misfits.GENFEFV2D

#' @export calc.misfits.FEcubic2D
calc.misfits.FEcubic2D = calc.misfits.GENFEFV2D

#' @export calc.misfits.FEquartic2D
calc.misfits.FEquartic2D = calc.misfits.GENFEFV2D

#' @export calc.misfits.FV2D
calc.misfits.FV2D = calc.misfits.GENFEFV2D


# RMSM
#' Calculate RMSM
#'
#' Calculates the root mean square error of  the misfits in the active nodes
#' (=nodes where no given state boundary condition).
#' If the states are close to the
#' solution of the flow problem, this number should be small.
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns the Root Mean Square Misfit
#' @seealso \code{calc.misfits}, \code{calc.MAM}
#' @rdname calc.RMSM
#' @export calc.RMSM
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' calc.RMSM(M)
calc.RMSM =  function(model)
  UseMethod("calc.RMSM")

calc.RMSM.GENFEFV2D= function(model)
{
  calc.sindepmisfits(model)
  calc.modmisfits(model)
  return(sqrt(mean(model$misfits[model$activenodes]^2)))
}

#' @export calc.RMSM.FLOW2D
calc.RMSM.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export calc.RMSM.FElinear2D
calc.RMSM.FElinear2D = calc.RMSM.GENFEFV2D

#' @export calc.RMSM.FEquadratic2D
calc.RMSM.FEquadratic2D = calc.RMSM.GENFEFV2D

#' @export calc.RMSM.FEcubic2D
calc.RMSM.FEcubic2D = calc.RMSM.GENFEFV2D

#' @export calc.RMSM.FEquartic2D
calc.RMSM.FEquartic2D = calc.RMSM.GENFEFV2D

#' @export calc.RMSM.FV2D
calc.RMSM.FV2D = calc.RMSM.GENFEFV2D

# MAM

#' Calculate MAM
#'
#' Calculates the maximum absolute misfits in the active nodes
#' (=nodes where no given state boundary condition)
#' This number gives gives an assesment of how close the current state
#' values are to the solution of the (numerical) flow problem.
#' If the states are close to the
#' solution of the flow problem, this numbers should be small.
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns the Maximum Absolute Misfit
#' @seealso \code{calc.misfits}, \code{calc.RMSM}
#' @rdname calc.MAM
#' @export calc.MAM
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' calc.MAM(M)
calc.MAM =  function(model)
  UseMethod("calc.MAM")

calc.MAM.GENFEFV2D = function(model)
{
  calc.sindepmisfits(model)
  calc.modmisfits(model)
  return(max(abs(model$misfits[model$activenodes])))
}

#' @export calc.MAM.FLOW2D
calc.MAM.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export calc.MAM.FElinear2D
calc.MAM.FElinear2D = calc.MAM.GENFEFV2D

#' @export calc.MAM.FEquadratic2D
calc.MAM.FEquadratic2D = calc.MAM.GENFEFV2D

#' @export calc.MAM.FEcubic2D
calc.MAM.FEcubic2D = calc.MAM.GENFEFV2D

#' @export calc.MAM.FEquartic2D
calc.MAM.FEquartic2D = calc.MAM.GENFEFV2D

#' @export calc.MAM.FV2D
calc.MAM.FV2D = calc.MAM.GENFEFV2D


#
# calculation of numerical Jacobian
# this is done UNDER THE ASSUMPTION THAT THE MISFITS
# ARE ALREADY CALCULATED
#

calc.alleps = function(model)
{
  eps = rep(1e-5,model$Numnodes)
  I = !model$isacceptable(model$nodes[,1],model$nodes[,2],model$states+eps)
  iter = 1
  while(sum(I)>0)
  {
    eps[I] = -0.5*eps[I]
    I = !model$isacceptable(model$nodes[,1],model$nodes[,2],model$states+eps)
    iter= iter+1
    if(iter>500)
    {
      stop("unable to determine acceptable state change",call.=FALSE)
    }
  }
  return(eps)
}

#
# for Jacobian storage
#
make.Jacobstore = function(model)
  UseMethod("make.Jacobstore")

make.Jacobstore.FV2D = function(model)
{
  rIndex = 1:model$Numnodes
  cIndex = 1:model$Numnodes
  model$cellinterfaces=cbind(model$cellinterfaces,matrix(0,nrow=model$Numinterfaces,ncol=2))
  colnames(model$cellinterfaces)[11:12]=c("Ji1i2","Ji2i1")
  for(k in 1:nrow(model$cellinterfaces))
  {
    rIndex=c(rIndex,model$cellinterfaces[[k,"ni1"]])
    cIndex=c(cIndex,model$cellinterfaces[[k,"ni2"]])
    model$cellinterfaces[k,"Ji1i2"] = length(rIndex)
    rIndex=c(rIndex,model$cellinterfaces[[k,"ni2"]])
    cIndex=c(cIndex,model$cellinterfaces[[k,"ni1"]])
    model$cellinterfaces[k,"Ji2i1"] = length(rIndex)
  }
  #   model$Jindex  = data.table(rIndex=rIndex,cIndex=cIndex,
  #                              xIndex=1:length(rIndex))
  #
  #   setkey(model$Jindex,rIndex,cIndex)
  model$Jacob = sparseMatrix(i=rIndex,j=cIndex,
                             x=rep(0,length(rIndex)),
                             giveCsparse=FALSE)
}

make.Jacobstore.GENFE2D = function(model)
{
  nels = model$elements[,c("nid1","nid2","nid3")]
  rIndex = 1:model$Numnodes
  cIndex = 1:model$Numnodes
  model$elements = cbind(model$elements,matrix(0,nrow(model$elements),ncol=6))
  colnames(model$elements)[21:26] = c("Ji1i2","Ji1i3","Ji2i1","Ji2i3","Ji3i1","Ji3i2")

  for(k in 1:nrow(nels))
  {
    na = nels[[k,"nid1"]]
    nb = nels[[k,"nid2"]]
    found = which((rIndex==na)&(cIndex==nb))
    if(length(found)==0)
    {
      rIndex=c(rIndex,na)
      cIndex=c(cIndex,nb)
      model$elements[k,"Ji1i2"] = length(rIndex)
    } else {
      model$elements[k,"Ji1i2"] = found
    }
    found = which((rIndex==nb)&(cIndex==na))
    if(length(found)==0)
    {
      rIndex=c(rIndex,nb)
      cIndex=c(cIndex,na)
      model$elements[k,"Ji2i1"] = length(rIndex)
    } else {
      model$elements[k,"Ji2i1"] = found
    }

    na = nels[[k,"nid2"]]
    nb = nels[[k,"nid3"]]
    found = which((rIndex==na)&(cIndex==nb))
    if(length(found)==0)
    {
      rIndex=c(rIndex,na)
      cIndex=c(cIndex,nb)
      model$elements[k,"Ji2i3"] = length(rIndex)
    } else {
      model$elements[k,"Ji2i3"] = found
    }
    found = which((rIndex==nb)&(cIndex==na))
    if(length(found)==0)
    {
      rIndex=c(rIndex,nb)
      cIndex=c(cIndex,na)
      model$elements[k,"Ji3i2"] = length(rIndex)
    } else {
      model$elements[k,"Ji3i2"] = found
    }

    na = nels[[k,"nid1"]]
    nb = nels[[k,"nid3"]]
    found = which((rIndex==na)&(cIndex==nb))
    if(length(found)==0)
    {
      rIndex=c(rIndex,na)
      cIndex=c(cIndex,nb)
      model$elements[k,"Ji1i3"] = length(rIndex)
    } else {
      model$elements[k,"Ji1i3"] = found
    }
    found = which((rIndex==nb)&(cIndex==na))
    if(length(found)==0)
    {
      rIndex=c(rIndex,nb)
      cIndex=c(cIndex,na)
      model$elements[k,"Ji3i1"] = length(rIndex)
    } else {
      model$elements[k,"Ji3i1"] = found
    }
  }
  #   model$Jindex  = data.table(rIndex=rIndex,cIndex=cIndex,
  #                              xIndex=1:length(rIndex))
  #
  #   setkey(model$Jindex,rIndex,cIndex)
  model$Jacob = sparseMatrix(i=rIndex,j=cIndex,
                             x=rep(0,length(rIndex)),
                             giveCsparse=FALSE)
  # now bring in the J's in the boundarypart
  model$boundarypart = cbind(model$boundarypart,matrix(0,nrow(model$boundarypart),ncol=2))
  colnames(model$boundarypart)[12:13] = c("Ji1i2","Ji2i1")
  for(k in 1:nrow(model$boundarypart))
  {
    n1 = model$boundarypart[[k,"nid1"]]
    n2 = model$boundarypart[[k,"nid2"]]
    model$boundarypart[[k,"Ji1i2"]] = which((rIndex==n1)&(cIndex==n2))
    model$boundarypart[[k,"Ji2i1"]] = which((rIndex==n2)&(cIndex==n1))
  }
}
make.Jacobstore.FElinear2D = make.Jacobstore.GENFE2D
make.Jacobstore.FEquadratic2D = make.Jacobstore.GENFE2D
make.Jacobstore.FEcubic2D = make.Jacobstore.GENFE2D
make.Jacobstore.FEquartic2D = make.Jacobstore.GENFE2D



#assignInNamespace("cedta.override", c("gWidgetsWWW","FVFE2D"), "data.table")



calc.NumJacobian =  function(model)
  UseMethod("calc.NumJacobian")

calc.NumJacobian.GENFE2D = function(model)
{
  tmpJ = rep(0,length(model$Jacob@x))
  #model$Jacob@x[] = 0
  eps = calc.alleps(model)
  isef = seq(along=model$sdepspatxflux)

  for(ei in 1:model$Numelements)
  {
    nid1 = model$elements[ei,"nid1"]
    nid2 = model$elements[ei,"nid2"]
    nid3 = model$elements[ei,"nid3"]
    A = model$elements[ei,"area"]

    eps1 = eps[nid1]
    eps2 = eps[nid2]
    eps3 = eps[nid3]

    states1 = model$states[nid1]+c(0,eps1,0,0)
    states2 = model$states[nid2]+c(0,0,eps2,0)
    states3 = model$states[nid3]+c(0,0,0,eps3)

    gradx = model$elements[ei,"dg11"]*(states2-states1)+
      model$elements[ei,"dg12"]*(states3-states1)

    grady = model$elements[ei,"dg21"]*(states2-states1)+
      model$elements[ei,"dg22"]*(states3-states1)

    gradsize = sqrt(gradx^2+grady^2)

    flowdist1 = c()
    flowdist2 = c()
    flowdist3 = c()
    for(k in 1:4)
    {
      if(gradsize[k]>0)
      {
        flowdist1[k] = (gradx[k]*model$elements[ei,"n1x"]+
                          grady[k]*model$elements[ei,"n1y"])/gradsize[k]
        flowdist2[k] = (gradx[k]*model$elements[ei,"n2x"]+
                          grady[k]*model$elements[ei,"n2y"])/gradsize[k]
        flowdist3[k] = (gradx[k]*model$elements[ei,"n3x"]+
                          grady[k]*model$elements[ei,"n3y"])/gradsize[k]
      } else {
        # should no happen
        flowdist1[k] = 1/3
        flowdist2[k] = 1/3
        flowdist3[k] = 1/3
      }
    }
    fluxint1 = rep(0,4)
    fluxint2 = rep(0,4)
    fluxint3 = rep(0,4)

    for(k in 1:model$Numgp)
    {
      ints = model$gamma[k,1]*states1+
        model$gamma[k,2]*states2+  model$gamma[k,3]*states3

      fluxsize = model$weight[k]*model$systemflux(model$gpointelx[ei,k],
                                                  model$gpointely[ei,k],
                                                  ints,gradsize)
      fluxint1 = flowdist1*fluxsize
      fluxint2 = flowdist2*fluxsize
      fluxint3 = flowdist3*fluxsize

      for(j in isef)
      {
        value =   model$sdepspatxflux[[j]](model$gpointelx[ei,k],
                                           model$gpointely[ei,k],ints)

        fluxint1 = fluxint1+model$weight[k]*A*model$gamma[k,1]*value
        fluxint2 = fluxint2+model$weight[k]*A*model$gamma[k,2]*value
        fluxint3 = fluxint3+model$weight[k]*A*model$gamma[k,3]*value
      }

      tmpJ[nid1] = tmpJ[nid1]  + (fluxint1[2]-fluxint1[1])/eps1

      Jii =  model$elements[[ei,"Ji1i2"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint1[3]-fluxint1[1])/eps2

      Jii =  model$elements[[ei,"Ji1i3"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint1[4]-fluxint1[1])/eps3

      Jii =  model$elements[[ei,"Ji2i1"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint2[2]-fluxint2[1])/eps1

      tmpJ[nid2] = tmpJ[nid2] + (fluxint2[3]-fluxint2[1])/eps2

      Jii =  model$elements[[ei,"Ji2i3"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint2[4]-fluxint2[1])/eps3

      Jii =  model$elements[[ei,"Ji3i1"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint3[2]-fluxint3[1])/eps1

      Jii = model$elements[[ei,"Ji3i2"]]
      tmpJ[Jii] = tmpJ[Jii]  + (fluxint3[3]-fluxint3[1])/eps2

      tmpJ[nid3] = tmpJ[nid3] + (fluxint3[4]-fluxint3[1])/eps3
    }
  }
  #now doing point external fluxes
  ipef = seq(along=model$sdeppntxflux)
  for(i in ipef)
  {
    pef = model$sdeppntxflux[[i]]
    el = model$elements[pef$indelem,]
    nid1 = el[["nid1"]]
    nid2 = el[["nid2"]]
    nid3 = el[["nid3"]]

    eps1 = eps[nid1]
    eps2 = eps[nid2]
    eps3 = eps[nid3]

    states1 = model$states[nid1]+c(0,eps1,0,0)
    states2 = model$states[nid2]+c(0,0,eps2,0)
    states3 = model$states[nid3]+c(0,0,0,eps3)

    sint = pef$p1 * states1+
      pef$p2 * states2+
      pef$p3 * states3

    value = pef$func(sint)

    tmpJ[nid1] = tmpJ[nid1] + pef$p1*(value[2]-value[1])/eps1

    Jii  = el[["Ji1i2"]]
    tmpJ[Jii] = tmpJ[Jii] + pef$p1*(value[3]-value[1])/eps2

    Jii = el[["Ji1i3"]]
    tmpJ[Jii] =  tmpJ[Jii] +  pef$p1*(value[4]-value[1])/eps3

    Jii = el[["Ji2i1"]]
    tmpJ[Jii] =  tmpJ[Jii] + pef$p2*(value[2]-value[1])/eps1

    tmpJ[nid2] = tmpJ[nid2] +  pef$p2*(value[3]-value[1])/eps2

    Jii = el[["Ji2i3"]]
    tmpJ[Jii] = tmpJ[Jii] + pef$p2*(value[4]-value[1])/eps3

    Jii = el[["Ji3i1"]]
    tmpJ[Jii] = tmpJ[Jii] + pef$p3*(value[2]-value[1])/eps1

    Jii = el[["Ji3i2"]]
    tmpJ[Jii] = tmpJ[Jii] + pef$p3*(value[3]-value[1])/eps2

    tmpJ[nid3] = tmpJ[nid3] +  pef$p3*(value[4]-value[1])/eps3
  }
  # now doing line external fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      el   = model$elements[sdep[[j,"elnum"]],]
      nid1 = sdep[[j,"n1"]]
      nid2 = sdep[[j,"n2"]]
      nid3 = sdep[[j,"n3"]]

      eps1 = eps[nid1]
      eps2 = eps[nid2]
      eps3 = eps[nid3]

      states1 = model$states[nid1]+c(0,eps1,0,0)
      states2 = model$states[nid2]+c(0,0,eps2,0)
      states3 = model$states[nid3]+c(0,0,0,eps3)

      svalue = sdep[j,"p1"] * states1+
        sdep[j,"p2"] * states2+
        sdep[j,"p3"] * states3
      nodesvalue = sdep[j,"p1"] * model$nodes[nid1,]+
        sdep[j,"p2"] * model$nodes[nid2,]+
        sdep[j,"p3"] * model$nodes[nid3,]
      value = lineflux$rates[[ sdep[j,"pointnum"] ]](
        nodesvalue[1],nodesvalue[2],svalue)*
        sdep[j,"weight"]

      tmpJ[nid1] = tmpJ[nid1] + sdep[j,"p1"]*(value[2]-value[1])/eps1

      Jii = el[["Ji1i2"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p1"]*(value[3]-value[1])/eps2

      Jii = el[["Ji1i3"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p1"]*(value[4]-value[1])/eps3

      Jii = el[["Ji2i3"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p2"]*(value[2]-value[1])/eps1

      tmpJ[nid2] = tmpJ[nid2] + sdep[j,"p2"]*(value[3]-value[1])/eps2

      Jii = el[["Ji2i3"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p2"]*(value[4]-value[1])/eps3

      Jii = el[["Ji3i1"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p3"]*(value[2]-value[1])/eps1

      Jii = el[["Ji3i2"]]
      tmpJ[Jii] = tmpJ[Jii] + sdep[j,"p3"]*(value[3]-value[1])/eps2

      tmpJ[nid3] = tmpJ[nid3] + sdep[j,"p3"]*(value[4]-value[1])/eps3
    }
  }
  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nid1 = model$boundarypart[i,"nid1"]
    nid2 = model$boundarypart[i,"nid2"]
    eps1 = eps[nid1]
    eps2 = eps[nid2]
    states1 = model$states[nid1]+c(0,eps1,0)
    states2 = model$states[nid2]+c(0,0,eps2)

    segBC = model$BC[[segid]]
    if(segBC$type == "fluxstate")
    {
      statemid = (states1+states2)/2

      value = model$boundarypart[i,"domainlength"]*segBC$func(statemid)

      tmpJ[nid1] = tmpJ[nid1] + 0.5*(value[2]-value[1])/eps1

      Jii = model$boundarypart[[i,"Ji2i1"]]
      tmpJ[Jii] = tmpJ[Jii] + 0.5*(value[2]-value[1])/eps1

      Jii = model$boundarypart[[i,"Ji1i2"]]
      tmpJ[Jii] = tmpJ[Jii] + 0.5*(value[3]-value[1])/eps2

      tmpJ[nid2] = tmpJ[nid2] + 0.5*(value[3]-value[1])/eps2
    }
  }
  model$Jacob@x = tmpJ
}


calc.NumJacobian.FElinear2D =  calc.NumJacobian.GENFE2D
calc.NumJacobian.FEquadratic2D =  calc.NumJacobian.GENFE2D
calc.NumJacobian.FEcubic2D =  calc.NumJacobian.GENFE2D
calc.NumJacobian.FEquartic2D =  calc.NumJacobian.GENFE2D

calc.NumJacobian.FV2D = function(model)
{
  tmpJ = rep(0,length(model$Jacob@x))
  # model$Jacob@x[] = 0

  eps = calc.alleps(model)

  for(i in 1:model$Numinterfaces)
  {
    x = model$cellinterfaces[[i,"x"]]
    y = model$cellinterfaces[[i,"y"]]
    ni1 = model$cellinterfaces[[i,"ni1"]]
    ni2 = model$cellinterfaces[[i,"ni2"]]
    Ji1i2 = model$cellinterfaces[[i,"Ji1i2"]]
    Ji2i1 = model$cellinterfaces[[i,"Ji2i1"]]
    L = model$cellinterfaces[[i,"nodedistance"]]
    l = model$cellinterfaces[[i,"facelength"]]

    eps1 = eps[ni1]
    state1 = model$states[ni1] + c(0,eps1,0)
    eps2 = eps[ni2]
    state2 = model$states[ni2]+ c(0,0,eps2)
    grad = (state2-state1)/L
    mids = (state1+state2)/2
    flux = l*model$systemflux(x,y,mids,grad)

    dflux = (flux[2]-flux[1])/eps1

    tmpJ[ni1] = tmpJ[ni1]-dflux

    tmpJ[Ji2i1] = tmpJ[Ji2i1] + dflux

    dflux = (flux[3]-flux[1])/eps2

    tmpJ[Ji1i2] = tmpJ[Ji1i2] - dflux

    tmpJ[ni2] = tmpJ[ni2] + dflux
  }
  # now doing spatial external fluxes

  isef = seq(along=model$sdepspatxflux)
  for(i in 1:model$Numnodes)
  {
    A = model$cellarea[i]
    for(j in isef)
    {
      epsh = eps[i]
      stateeps = model$states[i]+c(0,epsh)
      f = A*model$sdepspatxflux[[j]](model$nodes[i,1],
                                     model$nodes[i,2],stateeps)

      tmpJ[i] = tmpJ[i] + (f[2]-f[1])/epsh
    }
  }
  # now doing point external fluxes
  ipef = seq(along=model$sdeppntxflux)
  for(i in ipef)
  {
    pef = model$sdeppntxflux[[i]]
    j = pef$nodeid
    epsh = eps[j]
    stateeps = model$states[j]+c(0,epsh)
    f = pef$func(stateeps)
    tmpJ[j] = tmpJ[j] + (f[2]-f[1])/epsh
  }
  # now do line fluxes
  lpef = seq(along=model$linexflux)
  for(i in lpef)
  {
    lineflux = model$linexflux[[i]]
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      nn = sdep[j,"nodenum"]
      epsh = eps[nn]
      stateeps = model$states[nn]+c(0,epsh)
      v = lineflux$rates[[sdep[j,"pointnum"]]](
        model$nodes[nn,1],model$nodes[nn,2],stateeps)*
        sdep[j,"weight"]
      tmpJ[nn] = tmpJ[nn] + (v[2]-v[1])/epsh
    }
  }
  # now do boundary conditions
  for(i in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[i,"domainsegid"]
    nodeid = model$boundarypart[i,"nid"]
    epsh  =  eps[nodeid]
    segBC = model$BC[[segid]]
    if(segBC$type=="fluxstate")
    {
      values = model$boundarypart[i,"domainlength"]*
        segBC$func(model$states[nodeid]+c(0,epsh))
      tmpJ[nodeid] = tmpJ[nodeid] + (values[2]-values[1])/epsh
    }
  }
  model$Jacob@x = tmpJ
}



#' Do one solution step
#'
#' Does one step to determine new state values that solves the flow problem
#' If the model is linear, this one step should suffice. If not-linear it will
#' try to reduce the misfits by a Newton-Raphson step.
#' If this improvement is not enough (as e.g. judged
#' by inspecting the returned misfit statistics), one should
#' repeat applying this function or use the more general
#' \code{solve.steps} function
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a list with two entries: \code{RMSM} which contains the root mean
#' square of the misfits and \code{MAM} which contains the max absolute misfit.
#' @seealso \code{solve.steps}
#' @rdname solve.step
#' @export solve.step
#' @examples
#' lingradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M1 = newFLOW2D(domain=domain,systemfluxfunction=lingradflux,name="example")
#' set.discretisation(M1,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M1,0.1)
#' set.BC.fixedstate(M1,"NE",0.1)
#' solve.step(M1)
#' nonlingradflux = function(x,y,s,grads) { return(-sqrt(s)*grads)}
#' M2 = newFLOW2D(domain=domain,systemfluxfunction=nonlingradflux,name="example")
#' set.isacceptable(M2,function(x,y,s){return(s>=0)})
#' set.discretisation(M2,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M2,0.1)
#' set.BC.fixedstate(M2,"NE",0.1)
#' solve.step(M2)
solve.step =  function(model)
  UseMethod("solve.step")

solve.step.GENFEFV2D = function(model)
{
  return(solve.steps(model,maxiter=1))
}

#' @export solve.step.FLOW2D
solve.step.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export solve.step.FV2D
solve.step.FV2D = solve.step.GENFEFV2D

#' @export solve.step.FElinear2D
solve.step.FElinear2D = solve.step.GENFEFV2D

#' @export solve.step.FEquadratic2D
solve.step.FEquadratic2D = solve.step.GENFEFV2D

#' @export solve.step.FEcubic2D
solve.step.FEcubic2D = solve.step.GENFEFV2D

#' @export solve.step.FEquartic2D
solve.step.FEquartic2D = solve.step.GENFEFV2D

#' Do solution steps
#'
#' Does steps to determine new state values that solves the flow problem
#' If the model is linear, one step should suffice. If not-linear it will
#' try to reduce the misfits iteratively by a Newton-Raphson method.
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' #' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param  maxstatechangecrit (default 1E-8): if during the iterations the state changes
#' are smaller than this value, the iterations will be stopped
#' @param RMSMcrit (default 1E-5): if during iterations the RootMeanSquareMisfit is smaller
#' than this value, the iterations will be stopped
#' @param MAMcrit  (default 1E-5): if during iterations the MaximumAbsoluteMisfit is smaller
#' than this number the iterations will be stopped
#' @param maxiter (default 500): maximum number of iteration steps
#' @param maxiteracceptability (default 10): step made to make new state values
#' acceptable
#' @param verboselevel (default 0): if non-zero, iteration progress will be shown
#' @return returns a list with two entries: \code{RMSM} which contains the root mean
#' square of the misfits and \code{MAM} which contains the max absolute misfit.
#' @seealso \code{calc.RMSM}. \code{calc.MAM}, \code{calc.misfits}
#' @rdname solve.steps
#' @export solve.steps
#' @examples
#' nonlingradflux = function(x,y,s,grads) { return(-sqrt(s)*grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=nonlingradflux,name="example")
#' set.isacceptable(M,function(x,y,s){return(s>=0)})
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0.1)
#' control = solve.steps(M,verboselevel=1)
solve.steps =  function(model,
                        maxstatechangecrit = 1e-8,
                        RMSMcrit = 1e-5,
                        MAMcrit = 1e-5,
                        maxiter = 500,
                        maxiteracceptability = 11,
                        verboselevel=0)
  UseMethod("solve.steps")

solve.steps.GENFEFV2D = function(model,
                                 maxstatechangecrit = 1e-8,
                                 RMSMcrit = 1e-5,
                                 MAMcrit = 1e-5,
                                 maxiter = 500,
                                 maxiteracceptability = 11,
                                 verboselevel=0)
{
  if(!do.numericalbc(model))
  {
    return(list(RMSM=Inf,MAM=Inf))
  }
  do.numericalpointfluxes(model)
  calc.sindepmisfits(model)
  calc.modmisfits(model)
  oldRMSMcrit = sqrt(mean(model$misfits[model$activenodes]^2))
  oldMAMcrit = max(abs(model$misfits[model$activenodes]))
  oldmisfit = model$misfits[model$activenodes]
  calc.NumJacobian(model)
  Bold = model$Jacob[model$activenodes,model$activenodes]
  xold = model$states[model$activenodes]
  for(k in 1:maxiter)
  {
    dx =  try(solve(Bold,-oldmisfit),silent=TRUE)
    while (class(dx) == "try-error") {
      Bold = Bold+diag(0.00001,nrow=nrow(Bold))
      dx = try(solve(Bold,-oldmisfit),silent=TRUE)
    }
    if(max(abs(dx)) < maxstatechangecrit)
    {
      if(verboselevel>0)
      {
        print(paste("stopped because of small statechange",mean(dx^2)))
      }
      return(list(RMSM=oldRMSMcrit,MAM=oldMAMcrit))
    }
    factor = 1
    xnew = xold+factor*dx
    model$states[model$activenodes] =  as.vector(xnew)
    acceptabilityiter = 0
    while(statesareacceptable(model)!="")
    {
      factor=0.5*factor
      xnew = xold+factor*dx
      model$states[model$activenodes] =  as.vector(xnew)
      acceptabilityiter=acceptabilityiter+1
      if(acceptabilityiter>maxiteracceptability)
      {
        stop("unable to find acceptable state as solution",call.=FALSE)
      }
    }
    calc.modmisfits(model)
    newRMSMcrit = sqrt(mean(model$misfits[model$activenodes]^2))
    decreasefactor = 0.25
    while(newRMSMcrit > oldRMSMcrit)
    {
      factor = decreasefactor*factor
      if(factor < 1e-9) break
      xnew = xold+factor*dx
      model$states[model$activenodes] = as.vector(xnew)

      calc.modmisfits(model)
      newRMSMcrit = sqrt(mean(model$misfits[model$activenodes]^2))
      if(verboselevel>1) print(paste("   factor=",factor))
    }

    xold = xnew
    model$states[model$activenodes] = as.vector(xold)
    calc.modmisfits(model)
    newRMSMcrit = sqrt(mean(model$misfits[model$activenodes]^2))
    newMAMcrit = max(abs(model$misfits[model$activenodes]))
    if(newRMSMcrit < RMSMcrit)
    {
      if(verboselevel>0)
      {
        print(paste("stopped because of small RMSM=",newRMSMcrit))
      }
      return(list(RMSM=newRMSMcrit,MAM=newMAMcrit))
    }
    if(newMAMcrit < MAMcrit)
    {
      if(verboselevel>0)
      {
        print(paste("stopped because of small MAM=",newMAMcrit))
      }
      return(list(RMSM=newRMSMcrit,MAM=newMAMcrit))
    }
    if(verboselevel>0) print(paste("iteration", k,"; RMSM=",newRMSMcrit,"; MAM=",newMAMcrit))
    oldRMSMcrit = newRMSMcrit
    oldMAMcrit = newMAMcrit
    oldmisfit = model$misfits[model$activenodes]
    calc.NumJacobian(model)
    Bold = model$Jacob[model$activenodes,model$activenodes]
  }

  if((k==maxiter)&(verboselevel>0))
  {
    print("stopped because of maximum number of iterations")
  }
  return(list(RMSM=newRMSMcrit,MAM=newMAMcrit))
}

#' @export solve.steps.FLOW2D
solve.steps.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export solve.steps.FV2D
solve.steps.FV2D = solve.steps.GENFEFV2D

#' @export solve.steps.FElinear2D
solve.steps.FElinear2D = solve.steps.GENFEFV2D

#' @export solve.steps.FEquadratic2D
solve.steps.FEquadratic2D = solve.steps.GENFEFV2D

#' @export solve.steps.FEcubic2D
solve.steps.FEcubic2D = solve.steps.GENFEFV2D

#' @export solve.steps.FEquartic2D
solve.steps.FEquartic2D = solve.steps.GENFEFV2D


#
# some postprocessing helpers
#

#' Get current nodes
#'
#' Returns a data frame with current nodes in the model.
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a data frame consisting of two columns names "x" and "y"
#' containing the coordinates of the nodes (can if needed be converted into a matrix
#' by the \code{as.matrix} function)
#' @rdname dataframe.nodes
#' @export dataframe.nodes
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="geomgen",optdist=1),
#'                    method="FV")
#' head(dataframe.nodes(M))
dataframe.nodes = function(model)
  UseMethod("dataframe.nodes")
dataframe.nodes.GENFEFV2D = function(model)
{
  return(data.frame(x=model$nodes[,1],y=model$nodes[,2]))
}

#' @export dataframe.nodes.FLOW2D
dataframe.nodes.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export dataframe.nodes.FV2D
dataframe.nodes.FV2D = dataframe.nodes.GENFEFV2D

#' @export dataframe.nodes.FElinear2D
dataframe.nodes.FElinear2D = dataframe.nodes.GENFEFV2D

#' @export dataframe.nodes.FEquadratic2D
dataframe.nodes.FEquadratic2D = dataframe.nodes.GENFEFV2D

#' @export dataframe.nodes.FEcubic2D
dataframe.nodes.FEcubic2D = dataframe.nodes.GENFEFV2D

#' @export dataframe.nodes.FEquartic2D
dataframe.nodes.FEquartic2D = dataframe.nodes.GENFEFV2D

#' Get function for current state values
#'
#' Returns a function which return  state values at points
#' for the current state of the  model.
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return a function of two arguments, the space coordinates, that returns
#' the state at that point of the model as present during constrution.
#' If the model is of the FV type, the state value of the nearest node is returned.
#' If the model is of the FE type, a linear interpolation of the states at the nodes
#' of the triangle that contains the point.
#' In the FE case also a third parameter eps may be used. If a node exist closer than
#' eps to the argument, the state value at that node (without interpolation) is returned.
#' @rdname state.fun
#' @export state.fun
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.fixedstate(M,"SW",0)
#' solve.steps(M)
#' sf= state.fun(M)
#' print(sf(5,5))
#'
state.fun = function(model)
  UseMethod("state.fun")


#' @export state.fun.FV2D
state.fun.FV2D = function(model)
{
  X = dataframe.states(model)
  E = model$lemenents
  foo = function(x,y)
  {
    return(X$state[which.min((X$x-x)^2+(X$y-y)^2)])
  }
  environment(foo)=new.env()
  assign("X",X,environment(foo))

  return(Vectorize(foo))
}

state.fun.GENFE2D = function(model)
{
  X = dataframe.states(model)
  E = model$elements
  foo = function(x,y,eps=1e-6)
  {
    Z = (X$x-x)^2+(X$y-y)^2
    i = which.min(Z)
    if(Z[i]<eps)
    {
      return(X$state[i])
    } else {
      Es = E[(E[,"nid1"]==i)|(E[,"nid2"]==i)|(E[,"nid3"]==i),]
      if(is.null(dim(Es))) {
        Es = data.frame(t(Es))
      }
      for(k in 1:nrow(Es))
      {
        # calculate barycentric coordinates
        dy2y3 = Es[k,"y2"]-Es[k,"y3"]
        dx3x2 = Es[k,"x3"]-Es[k,"x2"]
        dy3y1 = Es[k,"y3"]-Es[k,"y1"]
        dx1x3 = Es[k,"x1"]-Es[k,"x3"]
        dxx3 = x-Es[k,"x3"]
        dyy3 = y-Es[k,"y3"]
        det = dy2y3*dx1x3-dx3x2*dy3y1
        if(abs(det)>0)
        {
          L1 = (dy2y3*dxx3+dx3x2*dyy3)/det
          L2 = (dy3y1*dxx3+dx1x3*dyy3)/det
          L3 = 1-L1-L2
          if((L1>0)&(L2>0)&(L3>0)) {
            return(L1*X$state[Es[k,"nid1"]]+
                   L2*X$state[Es[k,"nid2"]]+
                   L3*X$state[Es[k,"nid3"]])
          }
        }
      }
      return(X$state[i])
    }
  }
  environment(foo)=new.env()
  assign("X",X,environment(foo))
  assign("E",E,environment(foo))
  return(Vectorize(foo))
}

#' @export state.fun.FLOW2D
state.fun.FLOW2D = function(model)
{
  discretizationwarning()
}
#' @export state.fun.FElinear2D
state.fun.FElinear2D = state.fun.GENFE2D

#' @export state.fun.FEquadratic2D
state.fun.FEquadratic2D = state.fun.GENFE2D

#' @export state.fun.FEcubic2D
state.fun.FEcubic2D = state.fun.GENFE2D

#' @export state.fun.FEquartic2D
state.fun.FEquartic2D = state.fun.GENFE2D

#' Get current state values
#'
#' Returns a data frame with current state values in the model.
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a data frame consisting of three columns: first two columns
#' (named "x" and "y")
#' contains the coordinates of the nodes, second column (called "state")
#' the corresponding state values
#' @rdname dataframe.states
#' @export dataframe.states
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,0.1)
#' set.BC.fixedstate(M,"NE",0)
#' set.BC.fixedstate(M,"SW",0)
#' solve.steps(M)
#' plot(M,fill="state")
#' dataframe.states(M)
dataframe.states = function(model)
  UseMethod("dataframe.states")
dataframe.states.GENFEFV2D = function(model)
{
  return(data.frame(x=model$nodes[,1],y=model$nodes[,2],state=model$states))
}

#' @export dataframe.states.FLOW2D
dataframe.states.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export dataframe.states.FV2D
dataframe.states.FV2D = dataframe.states.GENFEFV2D

#' @export dataframe.states.FElinear2D
dataframe.states.FElinear2D = dataframe.states.GENFEFV2D

#' @export dataframe.states.FEquadratic2D
dataframe.states.FEquadratic2D = dataframe.states.GENFEFV2D

#' @export dataframe.states.FEcubic2D
dataframe.states.FEcubic2D = dataframe.states.GENFEFV2D

#' @export dataframe.states.FEquartic2D
dataframe.states.FEquartic2D = dataframe.states.GENFEFV2D

#
#' Get current internal fluxes
#'
#' Returns a data frame of the internal fluxes between nodes as calculated with
#' the current state values
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a data frame consisting of several columns giving an overview
#' of the internal fluxes as calculated with the current states.
#' \itemize{
#' \item if the numerical method is of the Finite Volume type the first two columns
#' give the nodenumbers between which the internal flux is calculated, the second column
#' gives the flux intensity, and the third column the total flux over the side that
#' separates the volume of the first node from the volume of the second node
#' \item if the numerical method is of the Finite Element type, the first three columns
#' give the nodenumbers of the triangular element,
#' the columns 4 to 6 give the total fluxes calculated in this triangle,
#' and column 7,8 give of the total flux vector its x and y component.
#' }
#' @rdname dataframe.internalfluxes
#' @export dataframe.internalfluxes
#' @examples
#'  invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#'
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' control=solve.steps(M)
#' head(dataframe.internalfluxes(M))
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FE")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' control = solve.steps(M)
#' head(dataframe.internalfluxes(M))

dataframe.internalfluxes =  function(model)
  UseMethod("dataframe.internalfluxes")

dataframe.internalfluxes.GENFE2D = function(model)
{
  result = data.frame()
  for(i in 1:model$Numelements)
  {
    nid1 = model$elements[i,"nid1"]
    nid2 = model$elements[i,"nid2"]
    nid3 = model$elements[i,"nid3"]
    A = model$elements[i,"area"]

    gradx = model$elements[i,"dg11"]*(model$states[nid2]-model$states[nid1])+
      model$elements[i,"dg12"]*(model$states[nid3]-model$states[nid1])

    grady = model$elements[i,"dg21"]*(model$states[nid2]-model$states[nid1])+
      model$elements[i,"dg22"]*(model$states[nid3]-model$states[nid1])

    fluxx = 0
    fluxy = 0

    gradsize = sqrt(gradx^2+grady^2)
    if(gradsize>0)
    {
      flowdist1 = (gradx*model$elements[i,"n1x"]+
                     grady*model$elements[i,"n1y"])/gradsize
      flowdist2 = (gradx*model$elements[i,"n2x"]+
                     grady*model$elements[i,"n2y"])/gradsize
      flowdist3 = (gradx*model$elements[i,"n3x"]+
                     grady*model$elements[i,"n3y"])/gradsize
      normgradx = gradx/gradsize
      normgrady = grady/gradsize
    } else {
      # should no happen
      flowdist1 = 1/3
      flowdist2 = 1/3
      flowdist3 = 1/3
      normgradx = 0
      nromgrady = 0
    }
    fluxint1 = 0
    fluxint2 = 0
    fluxint3 = 0
    for(k in 1:model$Numgp)
    {
      ints = model$gamma[k,1]*model$states[nid1]+
        model$gamma[k,2]*model$states[nid2]+  model$gamma[k,3]*model$states[nid3]

      fluxsize = model$weight[k]*model$systemflux(model$gpointelx[i,k],
                                                  model$gpointely[i,k],
                                                  ints,gradsize)
      fluxx = fluxx + fluxsize * normgradx
      fluxy = fluxy + fluxsize * normgrady
      fluxint1 = fluxint1+flowdist1*fluxsize
      fluxint2 = fluxint2+flowdist2*fluxsize
      fluxint3 = fluxint3+flowdist3*fluxsize
    }
    result = rbind(result,data.frame(node1=nid1,node2=nid2,node3=nid3,
                                     fluxto1=fluxint1,
                                     fluxto2=fluxint2,
                                     fluxto3=fluxint3,
                                     fluxx=fluxx,fluxy=fluxy))
  }
  rownames(result)=NULL
  return(result)
}

#' @export dataframe.internalfluxes.FLOW2D
dataframe.internalfluxes.FLOW2D = function(model)
{
  discretizationwarning()
}
#' @export dataframe.internalfluxes.FElinear2D
dataframe.internalfluxes.FElinear2D = dataframe.internalfluxes.GENFE2D

#' @export dataframe.internalfluxes.FEquadratic2D
dataframe.internalfluxes.FEquadratic2D = dataframe.internalfluxes.GENFE2D

#' @export dataframe.internalfluxes.FEcubic2D
dataframe.internalfluxes.FEcubic2D = dataframe.internalfluxes.GENFE2D

#' @export dataframe.internalfluxes.FEquartic2D
dataframe.internalfluxes.FEquartic2D = dataframe.internalfluxes.GENFE2D

#' @export dataframe.internalfluxes.FV2D
dataframe.internalfluxes.FV2D = function(model)
{
  result = data.frame()
  for(i in 1:model$Numinterfaces)
  {
    x = model$cellinterfaces[[i,"x"]]
    y = model$cellinterfaces[[i,"y"]]
    ni1 = model$cellinterfaces[i,"ni1"]
    ni2 = model$cellinterfaces[i,"ni2"]
    state1 = model$states[ni1]
    state2 = model$states[ni2]
    l = model$cellinterfaces[[i,"facelength"]]
    L = model$cellinterfaces[[i,"nodedistance"]]
    mids = (state1+state2)/2
    grad = (state2-state1)/L
    flux = model$systemflux(x,y,mids,grad)
    result = rbind(result,data.frame(node1=ni1,node2=ni2,flux1to2=flux,totflux1to2=l*flux))
  }
  rownames(result)=NULL
  return(result)
}

#' Get current external fluxes
#'
#' Returns a data frame of the external fluxes in the nodes as calculated with
#' the current state values
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @return returns a data frame consisting of several columns:
#' \itemize{
#' \item first and second columns ("x" and "y")
#'  contain the coordinates of the nodes
#'\item the following columns contain spatial external fluxes (if present) both
#' as intensities (column name equals fluxname) in the nodepoint
#' an as the total intergrated contribution to the balance of that node
#' (column name is \code{S(fluxname)dxdy})
#' \item the next columns contain the point flux (if present) contribution to
#' the balance of the node
#' (column name is pointflux name);
#' for FV models this contribution goes completely to the node nearest to the
#' position of the point flux,
#' for FE models the contribution is distributed over the nodes of the
#' element containing the position of the point flux.
#' \item the last columns contain the line flux (if present) both as
#' intensities (column name equals fluxname) in the nodepoint and as
#' total integrated contribution
#' to the balance of that node (column name is \code{S(lineflux)dl})
#' }
#' @rdname dataframe.externalfluxes
#' @export dataframe.externalfluxes
#' @examples
#'   invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' add.pointflux(M,c(2,3),1,"pf")
#' sfunc = function(x,y,s){return(-(x+y)/10)}
#' add.spatialflux(M,sfunc)
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FE")
#' head(dataframe.externalfluxes(M))

dataframe.externalfluxes =  function(model)
  UseMethod("dataframe.externalfluxes")

#' @export dataframe.externalfluxes.FLOW2D
dataframe.externalfluxes.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export dataframe.externalfluxes.FV2D
dataframe.externalfluxes.FV2D = function(model)
{
  isdep = seq(along=model$sdepspatxflux)
  isindep = seq(along=model$sindepspatxflux)
  sdepnames = names(model$sdepspatxflux)
  Sdxsdepnames = c()
  for(i in isdep)
  {
    Sdxsdepnames[i] = paste("S{",sdepnames[i],"}dxdy",sep="")
  }
  sindepnames = names(model$sindepspatxflux)
  Sdxsindepnames = c()
  for(i in isindep)
  {
    Sdxsindepnames[i] = paste("S{",sindepnames[i],"}dxdy",sep="")
  }
  ipdep = seq(along=model$sdeppntxflux)
  pdepnames = names(model$sdeppntxflux)
  ipindep = seq(along=model$sindeppntxflux)
  pindepnames = names(model$sindeppntxflux)
  ilf = seq(along=model$linexflux)
  lfnames = names(model$linexflux)
  Slfnames = c()
  for (i in ilf)
  {
    Slfnames[i] = paste("S{",lfnames[i],"}dl",sep="")
  }
  cnames = c("x","y",sdepnames,sindepnames,Sdxsdepnames,Sdxsindepnames,pdepnames,pindepnames,
             lfnames,Slfnames)

  result = matrix(0,nrow=model$Numnodes,ncol=length(cnames))
  colnames(result) = cnames
  for(i in 1:model$Numnodes)
  {
    x = model$nodes[i,1]
    result[i,"x"] = x
    y = model$nodes[i,2]
    result[i,"y"] = y
    A = model$cellarea[i]
    #result[i,"cell-area"] = A
    for(j in isdep)
    {
      f = model$sdepspatxflux[[j]](x,y,model$states[i])
      result[i,sdepnames[j]] = f
      result[i,Sdxsdepnames[j]]= A*f
    }
    for(j in isindep)
    {
      f = model$sindepspatxflux[[j]](x,y)
      result[i,sindepnames[j]] = f
      result[i,Sdxsindepnames[j]]= A*f
    }
  }
  for(j in ipdep)
  {
    pef = model$sdeppntxflux[[j]]
    result[pef$nodeid,pdepnames[j]] = pef$func(model$states[pef$nodeid])
  }
  for(j in ipindep)
  {
    pef = model$sindeppntxflux[[j]]
    result[pef$nodeid,pindepnames[j]] = pef$func()
  }
  for(j in ilf)
  {
    lineflux = model$linexflux[[j]]
    lfname = lfnames[j]
    Slfname = Slfnames[j]
    sindep = lineflux$sindep
    sumweights = rep(0,model$Numnodes)
    for(j in seq(along=sindep[,1]))
    {
      nn = sindep[j,"nodenum"]
      w  = sindep[j,"weight"]
      sumweights[nn] = sumweights[nn]+w
      v = eval.sindep.lineflux(lineflux,sindep[j,"pointnum"])* w
      result[nn,lfname] = result[nn,lfname] + v
      result[nn,Slfname] = result[nn,Slfname] + v
    }
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      nn = sdep[j,"nodenum"]
      w  = sdep[j,"weight"]
      sumweights[nn] = sumweights[nn]+w
      v = lineflux$rates[[ sdep[j,"pointnum"] ]](
        model$nodes[nn,1],model$nodes[nn,2],model$states[nn])* w
      result[nn,lfname] = result[nn,lfname] + v
      result[nn,Slfname] = result[nn,Slfname] + v
    }
    for(i in 1:model$Numnodes)
    {
      if(sumweights[i]>0) result[i,lfname] = result[i,lfname]/sumweights[i]
    }
  }
  result = as.data.frame(result)
  names(result)=cnames
  return(result)
}

dataframe.externalfluxes.GENFE2D = function(model)
{
  isdep = seq(along=model$sdepspatxflux)
  isindep = seq(along=model$sindepspatxflux)
  sdepnames = names(model$sdepspatxflux)
  Sdxsdepnames = c()
  for(i in isdep)
  {
    Sdxsdepnames[i] = paste("S{",sdepnames[i],"}dxdy",sep="")
  }
  sindepnames = names(model$sindepspatxflux)
  Sdxsindepnames = c()
  for(i in isindep)
  {
    Sdxsindepnames[i] = paste("S{",sindepnames[i],"}dxdy",sep="")
  }
  ipdep = seq(along=model$sdeppntxflux)
  pdepnames = names(model$sdeppntxflux)
  ipindep = seq(along=model$sindeppntxflux)
  pindepnames = names(model$sindeppntxflux)
  ilf = seq(along=model$linexflux)
  lfnames = names(model$linexflux)
  Slfnames = c()
  for (i in ilf)
  {
    Slfnames[i] = paste("S{",lfnames[i],"}dl",sep="")
  }
  cnames = c("x","y",sdepnames,sindepnames,Sdxsdepnames,Sdxsindepnames,pdepnames,pindepnames,
             lfnames,Slfnames)

  result = matrix(0,nrow=model$Numnodes,ncol=length(cnames))
  colnames(result) = cnames

  for(i in 1:model$Numnodes)
  {
    result[i,"x"] = model$nodes[i,1]
    result[i,"y"] = model$nodes[i,2]

    for(j in isdep)
    {
      result[i,sdepnames[j]] =
        model$sdepspatxflux[[j]](model$nodes[i,1],
                                 model$nodes[i,2],
                                 model$states[i])
    }
    for(j in isindep)
    {
      result[i,sindepnames[j]] =
        model$sindepspatxflux[[j]](model$nodes[i,1],
                                   model$nodes[i,2])
    }
  }

  for(i in 1:model$Numelements)
  {
    nid1 = model$elements[i,"nid1"]
    nid2 = model$elements[i,"nid2"]
    nid3 = model$elements[i,"nid3"]
    A = model$elements[i,"area"]

    for(k in 1:model$Numgp)
    {
      ints = model$gamma[k,1]*model$states[nid1]+
        model$gamma[k,2]*model$states[nid2]+  model$gamma[k,3]*model$states[nid3]

      for(j in isdep)
      {
        colname = Sdxsdepnames[j]
        value = model$sdepspatxflux[[j]](model$gpointelx[i,k],
                                         model$gpointely[i,k],
                                         ints)
        result[nid1,colname] = result[nid1,colname]+
          model$weight[k]*A*model$gamma[k,1]*value

        result[nid2,colname] = result[nid2,colname]+
          model$weight[k]*A*model$gamma[k,2]*value

        result[nid3,colname] = result[nid3,colname]+
          model$weight[k]*A*model$gamma[k,3]*value
      }
      for(j in isindep)
      {
        colname = Sdxsindepnames[j]
        value = model$sindepspatxflux[[j]](model$gpointelx[i,k],
                                           model$gpointely[i,k])
        result[nid1,colname] = result[nid1,colname]+
          model$weight[k]*A*model$gamma[k,1]*value

        result[nid2,colname] = result[nid2,colname]+
          model$weight[k]*A*model$gamma[k,2]*value

        result[nid3,colname] = result[nid3,colname]+
          model$weight[k]*A*model$gamma[k,3]*value
      }
    }
  }

  for(j in ipdep)
  {
    pef = model$sdeppntxflux[[j]]
    el = model$elements[pef$indelem,]
    nid1 = el[["nid1"]]
    nid2 = el[["nid2"]]
    nid3 = el[["nid3"]]
    sint = pef$p1 * model$states[nid1]+
      pef$p2 * model$states[nid2]+
      pef$p3 * model$states[nid3]
    value = pef$func(sint)
    colname = pdepnames[j]
    result[nid1,colname] = result[nid1,colname]+ pef$p1 * value
    result[nid2,colname] = result[nid2,colname]+ pef$p2 * value
    result[nid3,colname] = result[nid3,colname]+ pef$p3 * value
  }
  for(j in ipindep)
  {
    pef = model$sindeppntxflux[[j]]
    el = model$elements[pef$indelem,]
    nid1 = el[["nid1"]]
    nid2 = el[["nid2"]]
    nid3 = el[["nid3"]]
    value = pef$func()
    colname = pindepnames[j]
    result[nid1,colname] = result[nid1,colname]+ pef$p1 * value
    result[nid2,colname] = result[nid2,colname]+ pef$p2 * value
    result[nid3,colname] = result[nid3,colname]+ pef$p3 * value
  }
  for(j in ilf)
  {
    lineflux = model$linexflux[[j]]
    lfname = lfnames[j]
    Slfname = Slfnames[j]
    sindep = lineflux$sindep
    sumweights = rep(0,model$Numnodes)
    for(j in seq(along=sindep[,1]))
    {
      nid1 = sindep[j,"n1"]
      nid2 = sindep[j,"n2"]
      nid3 = sindep[j,"n3"]
      w1 = sindep[j,"weight"]*sindep[j,"p1"]
      w2 = sindep[j,"weight"]*sindep[j,"p2"]
      w3 = sindep[j,"weight"]*sindep[j,"p3"]
      v = eval.sindep.lineflux(lineflux,sindep[j,"pointnum"])
      result[nid1,Slfname] = result[nid1,Slfname] + v*w1
      result[nid1,lfname] = result[nid1,lfname] + v*w1
      sumweights[nid1] = sumweights[nid1] + w1
      result[nid2,Slfname] = result[nid2,Slfname] + v*w2
      result[nid2,lfname] = result[nid2,lfname] + v*w2
      sumweights[nid2] = sumweights[nid2] + w2
      result[nid3,Slfname] = result[nid3,Slfname] + v*w3
      result[nid3,lfname] = result[nid3,lfname] + v*w3
      sumweights[nid3] = sumweights[nid3] + w3
    }
    sdep = lineflux$sdep
    for(j in seq(along=sdep[,1]))
    {
      nid1 = sdep[j,"n1"]
      nid2 = sdep[j,"n2"]
      nid3 = sdep[j,"n3"]
      svalue = sdep[j,"p1"] * model$states[nid1]+
        sdep[j,"p2"] * model$states[nid2]+
        sdep[j,"p3"] * model$states[nid3]
      nodesvalue = sdep[j,"p1"] * model$nodes[nid1,]+
        sdep[j,"p2"] * model$nodes[nid2,]+
        sdep[j,"p3"] * model$nodes[nid3,]
      v = lineflux$rates[[ sdep[j,"pointnum"] ]](
        nodesvalue[1],nodesvalue[2],svalue)
      w1 = sdep[j,"weight"]*sdep[j,"p1"]
      w2 = sdep[j,"weight"]*sdep[j,"p2"]
      w3 = sdep[j,"weight"]*sdep[j,"p3"]
      result[nid1,lfname] = result[nid1,lfname] + v*w1
      result[nid1,Slfname] = result[nid1,Slfname] + v*w1
      sumweights[nid1] = sumweights[nid1] + w1
      result[nid2,lfname] = result[nid2,lfname] + v*w2
      result[nid2,Slfname] = result[nid2,Slfname] + v*w2
      sumweights[nid2] = sumweights[nid2] + w2
      result[nid3,lfname] = result[nid3,lfname] + v*w3
      result[nid3,Slfname] = result[nid3,Slfname] + v*w3
      sumweights[nid3] = sumweights[nid3] + w3
    }
    for(i in 1:model$Numnodes)
    {
      if(sumweights[i]>0) result[i,lfname] = result[i,lfname]/sumweights[i]
    }
  }
  result = as.data.frame(result)
  names(result)=cnames
  return(result)
}

#' @export dataframe.externalfluxes.FElinear2D
dataframe.externalfluxes.FElinear2D = dataframe.externalfluxes.GENFE2D

#' @export dataframe.externalfluxes.FEquadratic2D
dataframe.externalfluxes.FEquadratic2D = dataframe.externalfluxes.GENFE2D

#' @export dataframe.externalfluxes.FEcubic2D
dataframe.externalfluxes.FEcubic2D = dataframe.externalfluxes.GENFE2D

#' @export dataframe.externalfluxes.FEquartic2D
dataframe.externalfluxes.FEquartic2D = dataframe.externalfluxes.GENFE2D

#' Get boundary fluxes
#'
#' Returns a data frame of the fluxes over the boundaries of the
#' domain  as calculated with the current state values. If the boudary
#' condition was a fixed state, the flux is calculated such that the
#' balance in that point is statisfied
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D}, \code{[A]FEquartic2D} or \code{FV2D}
#' (as generated by \code{set.discretisation})
#' @return Returns a data frame consisting of five columns: first column contains
#' the nodenumber,  the second the total flux over the boundary in the mass balance
#' of the node, third column the boundary type, fourth and fifth column the domain segment number
#' and  the wind direction id of
#' that segment, as also given by the \code{plot.BC.id} function
#' @rdname dataframe.boundaries
#' @export dataframe.boundaries
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' solve.steps(M)
#' dataframe.boundaries(M)

dataframe.boundaries  =  function(model)
  UseMethod("dataframe.boundaries")


dataframe.boundaries.GENFE2D = function(model)
{
  result  = data.frame(nodenum = c(),
                       flux  = c(),
                       type = c(),
                       segid = c(),
                       winddir = c(),
                       stringsAsFactors=FALSE)
  for(k in 1:nrow(model$boundarypart))
  {
    segid = model$boundarypart[k,"domainsegid"]
    length = model$boundarypart[k,"domainlength"]
    nodeid1 = model$boundarypart[k,"nid1"]
    nodeid2 = model$boundarypart[k,"nid2"]
    segBC = model$BC[[segid]]
    name = segBC$type
    value = NULL
    if (name=="fixedflux")
    {
      value = length*segBC$func()
    } else if (name=="fluxstate")
    {
      value = length*segBC$func((model$states[nodeid1]+model$states[nodeid2])/2)
    }
    for( i in c(nodeid1,nodeid2))
    {
      I = which(result$nodenum==i)
      if(length(I)==0){
        if(!is.element(i,model$activenodes)){
          result = rbind(result,
                         data.frame(nodenum=i,
                                    flux=-model$misfits[i],
                                    type="fixedstate",
                                    segid=segid,
                                    winddir = segBC$name,
                                    stringsAsFactors = FALSE))
        } else {
          result = rbind(result,
                         data.frame(nodenum=i,
                                    flux=value/2,
                                    type=name,
                                    segid=segid,
                                    winddir = segBC$name,
                                    stringsAsFactors = FALSE))
        }
      } else {
        if(is.element(i,model$activenodes)){
          if(name != result$type[I[1]]){
            result$type[I[1]] = paste(result$type[I[1]],name,sep="-")
          }
          result$flux[I[1]] = result$flux[I[1]]+value/2
        }
      }

    }
  }
  return(result)
}

#' @export dataframe.boundaries.FLOW2D
dataframe.boundaries.FLOW2D = function(model)
{
  discretizationwarning()
}

#' @export dataframe.boundaries.FElinear2D
dataframe.boundaries.FElinear2D = dataframe.boundaries.GENFE2D

#' @export dataframe.boundaries.FEquadratic2D
dataframe.boundaries.FEquadratic2D = dataframe.boundaries.GENFE2D

#' @export dataframe.boundaries.FEcubic2D
dataframe.boundaries.FEcubic2D = dataframe.boundaries.GENFE2D

#' @export dataframe.boundaries.FEquartic2D
dataframe.boundaries.FEquartic2D = dataframe.boundaries.GENFE2D

#' @export dataframe.boundaries.FV2D
dataframe.boundaries.FV2D = function(model)
{
  result  = data.frame(nodenum = c(),
                       flux  = c(),
                       type = c(),
                       segid = c(),
                       winddir = c(),
                       stringsAsFactors=FALSE)

  for(k in 1:nrow(model$boundarypart))
  {
    nodeid = model$boundarypart[k,"nid"]
    segid = model$boundarypart[k,"domainsegid"]
    segBC = model$BC[[segid]]

    if(segBC$type == "fixedstate")
    {
      i = which((result$nodenum==nodeid)&(result$type=="given-state"))
      if(length(i)==0)
      {

        result = rbind(result,
                       data.frame(nodenum=nodeid,
                                  flux=-model$misfits[nodeid],
                                  type="fixedstate",
                                  segid=segid,
                                  winddir = segBC$name))
      }
    } else if(segBC$type=="fixedflux") {
      i = which((result$nodenum==nodeid)&(result$segid==segid))
      if(length(i)==0)
      {
        result = rbind(result,
                       data.frame(nodenum=nodeid,
                                  flux=model$boundarypart[k,"domainlength"]*segBC$func(),
                                  type="fixedflux",
                                  segid=segid,
                                  winddir = segBC$name))
      } else {
        fluxtoadd = flux=model$boundarypart[k,"domainlength"]*segBC$func()
        result$flux[i] = result$flux[i]+fluxtoadd
      }

    } else if(segBC$type=="fluxstate") {
      i = which((result$nodenum==nodeid)&(result$segid==segid))
      if(length(i)==0)
      {
        result = rbind(result,
                       data.frame(nodenum=nodeid,
                                  flux=model$boundarypart[k,"domainlength"]*
                                    segBC$func(model$states[nodeid]),
                                  type="stateflux",
                                  segid=segid,
                                  winddir = segBC$name))
      } else {
        fluxtoadd =model$boundarypart[k,"domainlength"]*segBC$func(model$states[nodeid])
        result$flux[i] = result$flux[i]+fluxtoadd
      }
    }
  }

  rownames(result)=NULL
  return(result)
}



#' Get balance overview
#'
#' Returns a data frame of the balance terms for a region defined by
#' a subset of notes of the
#' domain  as calculated with the current state values.
#'
#' @param model a two dimensional flow model of the class \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param region a vector of nodes for which the balance is calculated, if empty
#' (which is default) the region will the whole domain
#' @return returns a data frame consisting of four columns: first column contains
#' the name of the flux, the second all contributions of that flux that result
#' in a inflow into the domain, the third the contributions resulting in an outflow
#' from the region, the fourth the net contribution to the balance of the region.
#' The last row of the data frame contains the sum over the columns.
#' @rdname dataframe.balance
#' @export dataframe.balance
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#' set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
#' add.spatialflux(M,1)
#' add.pointflux(M,c(5,5),-30,"pf")
#' set.BC.fixedstate(M,"NE",2)
#' set.BC.fixedflux(M,1,0.4)
#' solve.steps(M)
#' plot(M,fill="state",nodenumbersize=1)
#' dataframe.balance(M,c(14,15,19,20))
#' dataframe.balance(M)

dataframe.balance = function(model,region=numeric(0))
  UseMethod("dataframe.balance")


#' @export dataframe.balance.FLOW2D
dataframe.balance.FLOW2D = function(model, ...)
{
  discretizationwarning()
}

#' @export dataframe.balance.FV2D
dataframe.balance.FV2D = function(model,region=numeric(0))
{
  is.valid("n","*",region,
           "second argument should be a vector of nodenumbers")
  if(length(region)==0)
  {
    region = 1:model$Numnodes
  }

  region = intersect(region,1:model$Numnodes)

  infl= dataframe.internalfluxes(model)
  result = data.frame(name="internal",inregion=0,outregion=0)
  for(i in 1:nrow(infl))
  {
    n1 = infl[i,"node1"]
    n2 = infl[i,"node2"]
    f = infl[i,"totflux1to2"]

    if(is.element(n1,region))
    {
      if(!is.element(n2,region))
      {
        if(f>0)
        {
          result$outregion[1]=result$outregion[1]+f
        } else {
          result$inregion[1] = result$inregion[1]-f
        }
      }
    } else if(is.element(n2,region))
    {
      if(f>0)
      {
        result$inregion[1]=result$inregion[1]+f
      } else {
        result$outregion[1] = result$outregion[1]-f
      }
    }
  }

  exfl = dataframe.externalfluxes(model)
  for(n in c(names(model$sdepspatxflux),names(model$sindepspatxflux)))
  {
    Sname = paste("S{",n,"}dxdy",sep="")
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    for(i in region)
    {
      f = exfl[i,Sname]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }
  for(n in c(names(model$sdeppntxflux),names(model$sindeppntxflux)))
  {
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    for(i in region)
    {
      f = exfl[i,n]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }
  for(n in names(model$linexflux))
  {
    Sname = paste("S{",n,"}dl",sep="")
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    for(i in region)
    {
      f = exfl[i,Sname]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }

  newresult  = data.frame(name="boundary",inregion=0,outregion=0)
  bfl = dataframe.boundaries(model)

  for(k in 1:nrow(bfl))
  {
    ni = bfl[k,"nodenum"]
    if(is.element(ni,region))
    {
      f = bfl[k,"flux"]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
  }
  result = rbind(result,newresult)
  result[["net"]] = result[,"inregion"]-result[,"outregion"]
  newresult  = data.frame(name="sum",inregion=sum(result[,"inregion"]),
                          outregion=sum(result[,"outregion"]),
                          net = sum(result[,"net"]))
  result=rbind(result,newresult)
  return(result)
}

dataframe.balance.GENFE2D = function(model,region=numeric(0))
{
  is.valid("n","*",region,
           "second argument should be a vector of nodenumbers")
  if(length(region)==0)
  {
    region = 1:model$Numnodes
  }

  region = intersect(region,1:model$Numnodes)

  infl= dataframe.internalfluxes(model)
  result = data.frame(name="internal",inregion=0,outregion=0)
  for(i in 1:nrow(infl))
  {
    n1 = infl[i,"node1"]
    n2 = infl[i,"node2"]
    n3 = infl[i,"node3"]
    nin = intersect(region,c(n1,n2,n3))
    nout = setdiff(c(n1,n2,n3),nin)
    f=0
    f1=0
    f2=0
    if(length(nin)==1)
    {
      if(nin[1]==n1)
      {
        f = infl[i,"fluxto1"]
      } else if(nin[1]==n2)
      {
        f = infl[i,"fluxto2"]
      } else if(nin[1]==n3)
      {
        f = infl[i,"fluxto3"]
      }
      if(f>0)
      {
        result$inregion[1]=result$inregion[1]+f
      } else {
        result$outregion[1] = result$outregion[1] - f
      }
    } else if(length(nout)==1)
    {
      if(nout[1]==n1)
      {
        f1 = infl[i,"fluxto2"]
        f2 = infl[i,"fluxto3"]
      } else if(nout[1]==n2)
      {
        f1 = infl[i,"fluxto3"]
        f2 = infl[i,"fluxto1"]
      } else if(nout[1]==n3)
      {
        f1 = infl[i,"fluxto1"]
        f2 = infl[i,"fluxto2"]
      }
      if(f1>0)
      {
        result$inregion[1]=result$inregion[1]+f1
      } else {
        result$outregion[1] = result$outregion[1] - f1
      }
      if(f2>0)
      {
        result$inregion[1]=result$inregion[1]+f2
      } else {
        result$outregion[1] = result$outregion[1] - f2
      }
    }
  }


  exfl = dataframe.externalfluxes(model)
  for(n in c(names(model$sdepspatxflux),names(model$sindepspatxflux)))
  {
    Sname = paste("S{",n,"}dxdy",sep="")
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    for(i in region)
    {
      f = exfl[i,Sname]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }
  for(n in c(names(model$sdeppntxflux),names(model$sindeppntxflux)))
  {
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    for(i in region)
    {
      f = exfl[i,n]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }
  for(n in names(model$linexflux))
  {
    newresult  = data.frame(name=n,inregion=0,outregion=0)
    Sname = paste("S{",n,"}dl",sep="")
    for(i in region)
    {
      f = exfl[i,Sname]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
    result = rbind(result,newresult)
  }
  newresult  = data.frame(name="boundary",inregion=0,outregion=0)
  bfl = dataframe.boundaries(model)

  for(k in 1:nrow(bfl))
  {
    ni = bfl[k,"nodenum"]
    if(is.element(ni,region))
    {
      f = bfl[k,"flux"]
      if(f>0)
      {
        newresult$inregion[1]=newresult$inregion[1]+f
      } else {
        newresult$outregion[1] = newresult$outregion[1] - f
      }
    }
  }
  result = rbind(result,newresult)
  result[["net"]] = result[,"inregion"]-result[,"outregion"]
  newresult  = data.frame(name="sum",inregion=sum(result[,"inregion"]),
                          outregion=sum(result[,"outregion"]),
                          net = sum(result[,"net"]))
  result=rbind(result,newresult)
  return(result)
}

#' @export dataframe.balance.FElinear2D
dataframe.balance.FElinear2D = dataframe.balance.GENFE2D

#' @export dataframe.balance.FEquadratic2D
dataframe.balance.FEquadratic2D = dataframe.balance.GENFE2D

#' @export dataframe.balance.FEcubic2D
dataframe.balance.FEcubic2D = dataframe.balance.GENFE2D

#' @export dataframe.balance.FEquartic2D
dataframe.balance.FEquartic2D = dataframe.balance.GENFE2D



# just a first implementation of summary

#' @export summary.FLOW2D
summary.FLOW2D = function(model)
{
  cat("two dimensional flow model\n")
  cat(paste("name: ",model$name,"\n"))
  allspatxflux = c(names(model$sdepspatxflux),names(model$sindepspatxflux))
  N = length(allspatxflux)
  if(N>0)
  {
    cat(paste("model has",N,"spatial flux, with name\n"))
    cat(" ")
    cat(allspatxflux)
    cat("\n")
  } else {
    cat("model has no spatial fluxes\n")
  }
  allpnttxflux = c(names(model$sdeppntxflux),names(model$sindeppntxflux))
  N = length(allpnttxflux)
  if(N>0)
  {
    cat(paste("model has",N,"point flux, with name\n"))
    cat(" ")
    cat(allpnttxflux)
    cat("\n")
  } else {
    cat("model has no point fluxes\n")
  }
  alllinexflux = c(names(model$linexflux))
  N = length(alllinexflux)
  if(N>0)
  {
    cat(paste("model has",N,"line flux, with name\n"))
    cat(" ")
    cat(alllinexflux)
    cat("\n")
  } else {
    cat("model has no line fluxes\n")
  }
  N = length(model$BC)
  Ns = 0
  Nf = 0
  Nsf = 0
  for(i in 1:N)
  {
    if(model$BC[[i]]$type=="fixedflux")
    {
      Nf = Nf +1
    } else if(model$BC[[i]]$type=="fixedstate")
    {
      Ns = Ns + 1
    } else if(model$BC[[i]]$type=="fluxstate")
    {
      Nsf = Nsf+1
    }
  }
  cat(paste("model has",N,"segment-boundary conditions\n"))
  cat(paste(" of which",Nf,"of type given flux\n"))
  cat(paste(" of which",Ns,"of type given state\n"))
  cat(paste(" of which",Nsf,"of type state-flux relation\n"))
  cat("\n")
}

summary.GENFEFV2D = function(model)
{
  summary.FLOW2D(model)
  cat(paste("numerical model of type",attr(model,"class"),"\n"))
  cat(paste("number of nodes is ",model$Numnodes,"\n"))
}

#' @export summary.FV2D
summary.FV2D = summary.GENFEFV2D

#' @export summary.FElinear2D
summary.FElinear2D = summary.GENFEFV2D

#' @export summary.FEquadratic2D
summary.FEquadratic2D = summary.GENFEFV2D

#' @export summary.FEcubic2D
summary.FEcubic2D = summary.GENFEFV2D

#' @export summary.FEquartic2D
summary.FEquartic2D = summary.GENFEFV2D
