#' Add a line flux
#'
#' Adds an external line flux to an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D}, \code{[A]FEquadratic2D},
#' \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param points a matrix with two columns being the x and y coordinates of the
#' points  that determine the line (the points are connected in order of the rows)
#' @param rates is a list of flux definitions. Each element of this list corresponds
#' to the flux in a definition point of the line, identiefied by the order of the
#' \code{points} argument.
#' If there are more elements in the list then definition points in the line, the last
#' ones are not used. If there are less elements in the list, the last one is reused for
#' the remaining points. In between two definition points of the line, a flux linearly
#' interpolated between those of the definition points will be used.
#' Each of the fluxes in the list has  a physical dimension is that
#' of the internal flux. The elements in the rates list can be given by either
#' \itemize{
#' \item a number,
#' \item a string giving a variable name (at every evalution later the value of that variable
#' at that time will be used)
#' \item or a function of  three argument : x,y,state that
#'  returns the intenisity of the line flux
#'  as a function of the coordinates and the state at that point}
#' @param name optional name for the flux
#' @rdname add.lineflux
#' @export add.lineflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="with lineflux")
#' set.BC.fixedstate(M,"W",2)
#' set.BC.fixedstate(M,"E",2)
#' river = matrix(c(3,1,4,6,7,7),ncol=2,byrow=TRUE)
#' add.lineflux(M,river,rates=list(-2,-1.5),name="river")
#' set.discretisation(M,nodes=list(type="hexagonal",side=0.5),method="FE")
#' solve.steps(M)
#' plot(M,fill="state",fill.3D=TRUE)

add.lineflux = function(model,points,rates,name)
  UseMethod("add.lineflux")

#' @export add.lineflux.FLOW2D
add.lineflux.FLOW2D = function(model,points,rates,name="")
{
  is.valid("m","+x2",points,
           "first (points) argument should be a matrix with two columns")
  Nlp = nrow(points)
  if(Nlp<2)
  {
    stop("need at least two points in add.lineflux",call.=FALSE)
  }
  is.valid("l","+",rates,
           "second (rates) argument should be a list with at least one element")
  Nlv = length(rates)
  if(Nlv < Nlp) {
    for(j in Nlv:Nlp)
    {
      rates[[j]]=rates[[Nlv]]
    }
  }
  vtypes = c()
  for(i in 1:Nlp)
  {
    vtypes[i] = is.valid(c("n","s","g"),c(1,"+",3),rates[[i]],
                         paste(i,"th element in value list ",
                               "should either be a number, a variable name or a
              function of three arguments",sep=""))
    if(vtypes[i]==3)
    {
      rates[[i]] = Vectorize(rates[[i]])
    }

  }
  is.valid("s","*",name,
           "fourth argument of add.lineflux should be a string")
  if(name=="")
  {
    name = paste("lineflux",
                 length(model$lineflux)+length(model$lineflux)+1,
                 sep="")
  }
  model$linexflux[[name]] = list(points=points,rates=rates,vtypes=vtypes)
}

#
# # allow to add point fluxes to numerical models
#
add.lineflux.GENFVFE2D = function(model,points,rates,name="")
{
  add.lineflux.FLOW2D(model,points,rates,name)
  do.numericallinefluxes(model)
}

#' @export add.lineflux.FElinear2D
add.lineflux.FElinear2D = add.lineflux.GENFVFE2D

#' @export add.lineflux.FEquadratic2D
add.lineflux.FEquadratic2D = add.lineflux.GENFVFE2D

#' @export add.lineflux.FEcubic2D
add.lineflux.FEcubic2D = add.lineflux.GENFVFE2D

#' @export add.lineflux.FEquartic2D
add.lineflux.FEquartic2D = add.lineflux.GENFVFE2D

#' @export add.lineflux.FV2D
add.lineflux.FV2D = add.lineflux.GENFVFE2D

eval.sindep.lineflux = function(lineflux,pointnum)
{
  vtype = lineflux$vtypes[[pointnum]]
  if(vtype==1)
  {
    return(lineflux$rates[[pointnum]])
  } else if(vtype==2)
  {
    return(get(lineflux$rates[[pointnum]]))
  }
}

#' Remove lineflux
#'
#' Removes a line  flux from an existing model
#'
#' @param model a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
#' \code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
#' \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
#' \code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})
#' @param fluxname is the name of the flux to be removed
#' (use \code{summary} to see the names)
#' @rdname rem.lineflux
#' @export rem.lineflux
#' @examples
#' invgradflux = function(x,y,s,grads) { return(-grads)}
#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux)
#' river = matrix(c(3,1,4,6,7,7),ncol=2,byrow=TRUE)
#' add.lineflux(M,river,rates=list(-2,-1.5),name="river")
#' summary(M)
#' rem.lineflux(M,"river")
#' summary(M)


rem.lineflux = function(model,name)
  UseMethod("rem.lineflux")

#' @export rem.lineflux.FLOW2D
rem.lineflux.FLOW2D = function(model,name)
{
  is.valid("s","*",name,
           "second argument of rem.lineflux should be a string")
  model$linexflux[[name]] = NULL
}

do.numericallinefluxes = function(model)
  UseMethod("do.numericallinefluxes")


do.numericallinefluxes.FV2D = function(model)
{
  # determine for each linesegment the intersection with the element
  # result:
  # a matrix of sindep
  # nodenum pointnum weight
  # a vector of sdep
  nlf = names(model$linexflux)
  for(n in nlf)
  {
    lineflux = model$linexflux[[n]]
    sindep = matrix(0,nrow=0,ncol=3)
    colnames(sindep) = c("nodenum","pointnum","weight")
    sdep = matrix(0,nrow=0,ncol=3)
    colnames(sdep) = c("nodenum","pointnum","weight")

    saved.seed = .Random.seed
    set.seed(1952)
    jpoints = jitter.points(lineflux$points,1e-7*min(model$xscale,model$yscale));
    .Random.seed = saved.seed


    for(k in 1:(nrow(lineflux$points)-1))
    {
      linetosect = jpoints[k:(k+1),]
      lenlinetosect = sqrt(sum((linetosect[2,]-linetosect[1,])^2))
      for(i in 1:length(model$cellgeo))
      {
        cell = as.matrix(model$cellgeo[[i]])
        if(nrow(cell)>0)
        {
          inters = GEO$intersection.poly.segment(cell,linetosect)
          if(!is.null(inters))
          {
            if(nrow(inters)==1)
            {
              #either the begin point or the eindpoint of the linetosect falls in the element
              #first test point 1
              if(GEO$inside.poly(cell,linetosect[1,]))
              {
                midx = (linetosect[1,1]+inters[1,1])/2
                lsegx = (linetosect[1,1]-inters[1,1])^2
                lp1midx = (linetosect[1,1]-midx)^2
                lp2midx = (linetosect[2,1]-midx)^2
                midy = (linetosect[1,2]+inters[1,2])/2
                lsegy = (linetosect[1,2]-inters[1,2])^2
                lp1midy = (linetosect[1,2]-midy)^2
                lp2midy = (linetosect[2,2]-midy)^2
              } else {
                # was point 2
                midx = (linetosect[2,1]+inters[1,1])/2
                lsegx = (linetosect[2,1]-inters[1,1])^2
                lp1midx = (linetosect[1,1]-midx)^2
                lp2midx = (linetosect[2,1]-midx)^2
                midy = (linetosect[2,2]+inters[1,2])/2
                lsegy = (linetosect[2,2]-inters[1,2])^2
                lp1midy = (linetosect[1,2]-midy)^2
                lp2midy = (linetosect[2,2]-midy)^2
              }
            }
            else if(nrow(inters)>1)
            {
              midx = (inters[2,1]+inters[1,1])/2
              lsegx = (inters[2,1]-inters[1,1])^2
              lp1midx = (linetosect[1,1]-midx)^2
              lp2midx = (linetosect[2,1]-midx)^2
              midy = (inters[2,2]+inters[1,2])/2
              lsegy = (inters[2,2]-inters[1,2])^2
              lp1midy = (linetosect[1,2]-midy)^2
              lp2midy = (linetosect[2,2]-midy)^2
            }
            lseg = sqrt(lsegx+lsegy)
            w1 = lseg*sqrt(lp1midx+lp1midy)/lenlinetosect
            w2 = lseg*sqrt(lp2midx+lp2midy)/lenlinetosect
            if(lineflux$vtypes[k]==3)
            {
              sdep = rbind(sdep,c(i,k,w1))
            } else {
              sindep = rbind(sindep,c(i,k,w1))
            }
            if(lineflux$vtypes[k+1]==3)
            {
              sdep = rbind(sdep,c(i,k+1,w2))
            } else {
              sindep = rbind(sindep,c(i,k+1,w2))
            }
          }
        }
      }
    }
    model$linexflux[[n]][["sindep"]]=sindep
    model$linexflux[[n]][["sdep"]] = sdep
  }
}

do.numericallinefluxes.GENFE2D = function(model)
{
  # l1 = dist(midp-linebegin)/(distline)
  # p1,p2,p3: p-coordinates of midpoint
  # Qtot = lseg*(l1*f1(p1*s1+p2*s2+p3*s3)+l2*f2(p1*s1+p1))
  # Qtot * p1 -> node1
  # w1 = lseg*l1*f1
  nlf = names(model$linexflux)
  for(n in nlf)
  {
    lineflux = model$linexflux[[n]]
    sindep = matrix(0,nrow=0,ncol=9)
    colnames(sindep) = c("elnum","n1","n2","n3", "p1", "p2", "p3", "pointnum","weight")
    sdep = matrix(0,nrow=0,ncol=9)
    colnames(sdep) = c("elnum","n1","n2","n3", "p1", "p2", "p3", "pointnum","weight")
    xynames = c("x1","x2","x3","y1","y2","y3")

    saved.seed = .Random.seed
    set.seed(1952)
    jpoints = jitter.points(lineflux$points,1e-7*min(model$xscale,model$yscale));
    .Random.seed = saved.seed

    for(k in 1:(nrow(lineflux$points)-1))
    {
      linetosect = jpoints[k:(k+1),]
      lenlinetosect = sqrt(sum((linetosect[2,]-linetosect[1,])^2))
      for(i in 1:model$Numelements)
      {
        e = model$elements[i,]
        triangle = matrix(e[xynames],ncol=2)
        inters = GEO$intersection.poly.segment(triangle,linetosect)
        if(!is.null(inters))
        {
          #either the begin point or the eindpoint of the linetosect falls in the element
          #first test point 1
          if(nrow(inters)==1)
          {
            if(GEO$inside.poly(triangle,linetosect[1,]))
            {
              midx = (linetosect[1,1]+inters[1,1])/2
              lsegx = (linetosect[1,1]-inters[1,1])^2
              lp1midx = (linetosect[1,1]-midx)^2
              lp2midx = (linetosect[2,1]-midx)^2
              midy = (linetosect[1,2]+inters[1,2])/2
              lsegy = (linetosect[1,2]-inters[1,2])^2
              lp1midy = (linetosect[1,2]-midy)^2
              lp2midy = (linetosect[2,2]-midy)^2
            } else {
              # was point 2
              midx = (linetosect[2,1]+inters[1,1])/2
              lsegx = (linetosect[2,1]-inters[1,1])^2
              lp1midx = (linetosect[1,1]-midx)^2
              lp2midx = (linetosect[2,1]-midx)^2
              midy = (linetosect[2,2]+inters[1,2])/2
              lsegy = (linetosect[2,2]-inters[1,2])^2
              lp1midy = (linetosect[1,2]-midy)^2
              lp2midy = (linetosect[2,2]-midy)^2
            }
          } else if(nrow(inters)>1) {
            midx = (inters[2,1]+inters[1,1])/2
            lsegx = (inters[2,1]-inters[1,1])^2
            lp1midx = (linetosect[1,1]-midx)^2
            lp2midx = (linetosect[2,1]-midx)^2
            midy = (inters[2,2]+inters[1,2])/2
            lsegy = (inters[2,2]-inters[1,2])^2
            lp1midy = (linetosect[1,2]-midy)^2
            lp2midy = (linetosect[2,2]-midy)^2
          }

          p2 = e[["dg11"]]*(midx-e[["x1"]])+
            e[["dg21"]]*(midy-e[["y1"]])
          p3 = e[["dg12"]]*(midx-e[["x1"]])+
            e[["dg22"]]*(midy-e[["y1"]])
          p1 = 1-p2-p3
          lseg = sqrt(lsegx+lsegy)
          w1 = lseg*sqrt(lp1midx+lp1midy)/lenlinetosect
          w2 = lseg*sqrt(lp2midx+lp2midy)/lenlinetosect
          if(lineflux$vtypes[k]==3)
          {
            sdep = rbind(sdep,c(i,e[["nid1"]],e[["nid2"]],e[["nid3"]],
                                p1,p2,p3,k,w1))
          } else {
            sindep = rbind(sindep,c(i,e[["nid1"]],e[["nid2"]],e[["nid3"]],
                                    p1,p2,p3,k,w1))
          }
          if(lineflux$vtypes[k+1]==3)
          {
            sdep = rbind(sdep,c(i,e[["nid1"]],e[["nid2"]],e[["nid3"]],
                                p1,p2,p3,k+1,w2))
          } else {
            sindep = rbind(sindep,c(i,e[["nid1"]],e[["nid2"]],e[["nid3"]],
                                    p1,p2,p3,k+1,w2))
          }
        }
      }
    }
    model$linexflux[[n]][["sindep"]]=sindep
    model$linexflux[[n]][["sdep"]] = sdep
  }
}

do.numericallinefluxes.FElinear2D = do.numericallinefluxes.GENFE2D
do.numericallinefluxes.FEquadratic2D = do.numericallinefluxes.GENFE2D
do.numericallinefluxes.FEcubic2D = do.numericallinefluxes.GENFE2D
do.numericallinefluxes.FEquartic2D = do.numericallinefluxes.GENFE2D
