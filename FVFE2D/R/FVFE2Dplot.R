

# do not want to use roxygen for this:
#norox#' Plots states and/or internal fluxes as calculated by the
#norox#' current state of the model
#
#norox#' @param model a one dimensional flow model of the class \code{FElinear2D},
#norox#' \code{FEquadratic2D}, \code{FEcubic2D},
#norox#' \code{FEquartic2D} (as generated by \code{set.discretisation})
#norox#' @param showdomain TRUE/FALSE (default TRUE) for showing the domain in the plot
#norox#' @param shownodes TRUE/FALSE (default TRUE) for showing the position of
#norox#' the nodes in the plot
#norox#' @param nodenumbersize (default=0) size of the nodenumbers in the plot
#norox#' @param fill.colors the color palette just for fill plots if fill="state"
#norox#' @param fill.border the color of the border of the triangles; if NA (=default)
#norox#' no borders will be plotted
#norox#' @param fill
#norox#' \itemize{
#norox#' \item if \code{fill=""} (the default) no fill plot will be made
#norox#' \item if \code{fill="state"} a fill plot with the current state values will
#norox#' be made
#norox#' \item if \code{fill="random"} random values will be used
#norox#' \item if the value of \code{fill} is a vector, the values of this vector (in the order
#norox#' of the nodes, so the vector should have the length of the number of nodes in the model)
#norox#' will be used for fill values
#norox#' \item the value of \code{fill} can also be a function of three coordinates:
#norox#' \code{function(x,y,s)}. The values used for the fill will then be calculated for each node
#norox#' by using the coordinates of that node and the current state value in that node as arguments.
#norox#' }
#norox#' @param fill.colors is a vector of colors to be used in the filling.
#norox#' If \code{NULL} a default vector will be used.  See \code{help(colors)} for other choices.
#norox#' @param fill.contours a vector of values for which contour lines
#norox#' (in the FV cases: on the borders of the cells, in the FE cases: linearly interpolated
#norox#' inside the triangles) will be drawn
#norox#' @param fill.3D if TRUE a 3D plot by rgl is made with colors corresponding to the
#norox#' 2D fill plot; the plot can be changed by the mouse
#norox#' @param fill.2D if FALSE none of the 2D plots is made
#norox#' @param  fluxvecsize if larger then 0 (= the default) vectors indicating the size
#norox#' and directions within each triangle (at the midpoint) will be drawn;
#norox#' the value of this parameter will be used as a multiplication factor the vector size
#norox#' @rdname plot
#norox#' @examples
#norox#' invgradflux = function(x,y,s,grads) { return(-grads)}
#norox#' domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
#norox#' M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
#norox#' add.spatialflux(M,0.1)
#norox#' set.BC.fixedstate(M,"NE",2)
#norox#' set.BC.fixedstate(M,"SW",1)
#norox#' set.discretisation(M,nodes=list(type="geomgen",optdist=1.5),method="FE")
#norox#' plot(M,fill="random",nodenumbersize=0.3)
#norox#' line1 = list(x=c(4,4),y=c(2,8),col="white",lwd=3)
#norox#' line2 = list(x=c(1,6),y=c(4,4),col="black",lwd=3)
#norox#' point1 = list(x=5,y=6,col="white",pch=20,cex=3)
#norox#' point2 = list(x=3,y=3,col="black",pch=5)
#norox#' polygon1 = list(x=c(3.1,3.5,4.2),y=c(4.5,5.8,5.1),col="blue")
#norox#' plot(M,fill="random",addlines=list(line1,line2),addpoints=list(point1,point2),addpolygons = list(polygon1))
#norox#' control=solve.steps(M)
#norox#' plot(M,fill="state",fill.contours=seq(1,3,length=20),fluxvecsize=2)
#norox#' foo = function(x,y,s){return(s-0.1*y)}
#norox#' plot(M,fill=foo)
#norox#' f2 =exp(-dataframe.states(M)$state)
#norox#' plot(M,fill=f2,addlines=list(line1),addpoints=list(point1))
#' @export plot.FLOW2D
plot.FLOW2D = function(model, ...)
{
  discretizationwarning();
}

#' @export plot.FV2D

plot.FV2D = function(model,
                     showdomain = TRUE,
                     shownodes = TRUE,
                     nodenumbersize = 0,
                     fill.border = NA,
                     fill.contours = c(),
                     fill = "",
                     fill.name = "",
                     main.title = NULL,
                     fill.lim = NULL,
                     fill.colors = NULL,
                     fill.3D = FALSE,
                     fill.2D = TRUE,
                     fluxvecsize = 0,
                     xlim = NULL,
                     ylim = NULL,
                     linesection="",
                     addlines=list(),
                     addpoints=list(),
                     addpolygons= list())
{
  farg = is.valid(c("s","g","n"),c("*",3,"+"),fill,
                  "fill argument shoulde be a string, a vector or a function of three arguments:(x,y,state)")
  fillvalue = c()
  if(farg==3)
  {
    lengthfill = length(fill)
    if(lengthfill!= model$Numnodes)
    {
      stopmessage = paste(model$Numnodes, "= num nodes is not equal to the length of fill =",lengthfill)
      stop(stopmessage,call.=FALSE)
    }
    fillvalue = fill
  }
  else if(farg==2)
  {
    for(i in 1:model$Numnodes)
    {
      fillvalue[i] = fill(model$nodes[i,1],model$nodes[i,2],model$states[i])
    }
  } else if(farg==1)
  {
    if(fill=="state")
    {
      for(i in 1:model$Numnodes)
      {
        fillvalue[i] = model$states[i]
      }
    } else if(fill=="random")
    {
      fillvalue = runif(model$Numnodes)
    } else
    {
      fillvalue = rep(NA,model$Numnodes)
    }
  }
  
  larg = is.valid(c("s","n"),c("*",4),linesection,
                  "linesection argument should be a string,
                  or a vector of four arguments")
  linetosect = NULL
  linteractive = FALSE
  lineresult = matrix(0,nrow=0,ncol=8)
  colnames(lineresult)=c("x1","y1","x2","y2",
                         "length1","length2","value1","value2")
  if(larg==1){
    if(linesection=="interactive")
    {
      linteractive = TRUE
    }
  } else if(larg==2)
  {
    linetosect = matrix(linesection,ncol=2,byrow=TRUE)
  }
  
  if((length(fill.contours)>0)&&(length(fillvalue)==0))
  {
    stop("can not create contours without fill values",call.=FALSE)
  }
  if((fill.3D)&(length(fillvalue)==0))
  {
    stop("can not create 3D plot without fill values",call.=FALSE)
  }
  
  if(is.null(fill.colors))
  {
    fill.colors= deffillcolors
  }
  Nfc = length(fill.colors)
  if(fill.2D)
  {
    old.par = par(no.readonly=TRUE)
  }
  if(is.null(xlim))
  {
    xrange = range(model$domain[,1])
  } else {
    xrange = sort(xlim);
  }
  xscale = xrange[2]-xrange[1]
  xmin = xrange[1]
  if(is.null(ylim))
  {
    yrange = range(model$domain[,2])
  } else {
    yrange = sort(ylim)
  }
  yscale = yrange[2]-yrange[1]
  ymin = yrange[1]
  
  
  if(length(fillvalue)>0)
  {
    if(is.null(fill.lim))
    {
      if(sum(is.na(fillvalue))==model$Numnodes)
      {
        srange = c(0,1)
      } else {
        srange = range(fillvalue,na.rm=TRUE)
      }
      if(srange[2]==srange[1])
      {
        srange[1]=srange[1]-1
        srange[2]=srange[2]+1
      }
    } else {
      is.valid("n",2,fill.lim,"fill.lim should be a vector of two numbers")
      srange = range(fill.lim)
    }
  }
  if(is.null(main.title))
  {
    main.title =  model$name
  }
  
  if(fill.2D)
  {
    par(mar=c(4,4,4,5))
    fc = function(s,shift=FALSE)
    {
      if(is.na(s)) return(fill.colors[1])
      s[s > srange[2]] = srange[2]
      s[s < srange[1]] = srange[1]
      ss = (s-srange[1])/(srange[2]-srange[1])
      if(shift)
      {
        ss = ss+0.25
        if(ss>1) ss=ss-1
      }
      return(fill.colors[1+ss*(Nfc-1)])
    }
    sseq = seq(srange[1],srange[2],length=(Nfc+1))
    Ncvs = 0
    if(length(fill.contours)>0)
    {
      contvals = fill.contours[(fill.contours >= srange[1])&
                                 (fill.contours <= srange[2])]
      Ncvs = length(contvals)
    }
    
    xlim = c(xmin,xmin+1.1*xscale)
    ylim = c(ymin,ymin+yscale)
    plot(x=c(),y=c(),main=main.title,
         xlim=xlim, ylim=ylim,xlab="x",ylab="y")
    
    for(i in 1:length(model$cellgeo))
    {
      polygon(model$cellgeo[[i]],border=fill.border,col=fc(fillvalue[i]))
    }
    
    if(length(fill.contours)>0)
    {
      for( i in 1:nrow(model$cellinterfaces))
      {
        ci = model$cellinterfaces[i,]
        v = sort(fillvalue[c(ci["ni1"],ci["ni2"])])
        ctodraw = contvals[(contvals > v[1])&(contvals <v[2])]
        for( k in seq(along=ctodraw))
        {
          lines(ci[c("x1","x2")],ci[c("y1","y2")],lwd=3,col="black")
          lines(ci[c("x1","x2")],ci[c("y1","y2")],lwd=2.9,col=fc(ctodraw[k],shift=TRUE))
        }
      }
    }
    if(showdomain)
    {
      polygon(model$domain,col=rgb(0,0,0,0.07))
    }
    if(shownodes)
    {
      points(model$nodes,pch=20,cex=0.6,col="white")
      points(model$nodes,pch=20,cex=0.4,col="red")
    }
    if(nodenumbersize>0)
    {
      text(model$nodes[,1],model$nodes[,2],labels=1:model$Numnodes,
           pos=3,cex=nodenumbersize,col="blue")
    }
    if(fluxvecsize>0)
    {
      ifl = dataframe.internalfluxes(model)
      
      flvec  = matrix(0,nrow=model$Numnodes,ncol=3)
      for(i in 1:nrow(ifl))
      {
        n1 = ifl[i,"node1"]
        n2 = ifl[i,"node2"]
        e2to1 = (model$nodes[n1,]-model$nodes[n2,])/model$cellinterfaces[i,"nodedistance"]
        flvec[n1,1] = flvec[n1,1]-e2to1[1]*ifl[i,"totflux1to2"]
        flvec[n1,2] = flvec[n1,2]-e2to1[2]*ifl[i,"totflux1to2"]
        flvec[n1,3] = flvec[n1,3]+model$cellinterfaces[i,"facelength"]
        flvec[n2,1] = flvec[n2,1]-e2to1[1]*ifl[i,"totflux1to2"]
        flvec[n2,2] = flvec[n2,2]-e2to1[2]*ifl[i,"totflux1to2"]
        flvec[n2,3] = flvec[n2,3]+model$cellinterfaces[i,"facelength"]
      }
      flvec[,1] = flvec[,1]/flvec[,3]
      flvec[,2] = flvec[,2]/flvec[,3]
      mf = 0.03*model$scale/(mean(abs(flvec[,1]))+mean(abs(flvec[,2])))*
        fluxvecsize
      Arrows(model$nodes[,1],model$nodes[,2],
             model$nodes[,1]+mf*flvec[,1],model$nodes[,2]+mf*flvec[,2])
    }
    # redraw color bar
    if(linteractive)
    {
      cat("select two points for linesection by clicking on graph\n")
      sel = locator(n=2)
      linetosect = matrix(c(sel$x,sel$y),nrow=2)
    }
    if(!is.null(linetosect))
    {
      if(nrow(linetosect)>0)
      {
        lines(linetosect[,1],linetosect[,2],lwd=4)
      }
    }
    if(!is.null(linetosect))
    {
      value = c()
      length = c()
      xynames = c("x1","x2","x3","y1","y2","y3")
      for(i in 1:length(model$cellgeo))
      {
        cell = as.matrix(model$cellgeo[[i]])
        inters = GEO$intersection.poly.segment(cell,linetosect)
        if(!is.null(inters))
        {
          if(nrow(inters)==1)
          {
            #either the begin point or the eindpoint of the linetosect falls in the element
            #first test point 1
            if(GEO$inside.poly(cell,linetosect[1,]))
            {
              length[1]=0
              x1 = linetosect[1,1]
              y1 = linetosect[1,2]
            } else {
              # was point 2
              x1 = linetosect[2,1]
              y1 = linetosect[2,2]
              length[1] = sqrt(sum((linetosect[2,]-linetosect[1,])^2))
            }
            value[1] = fillvalue[i]
            value[2] = fillvalue[i]
            length[2] = sqrt(sum((inters[1,1:2]-linetosect[1,])^2))
            I = order(length)
            lineresult = rbind(lineresult,c(x1,y1,
                                            inters[1,"x"],inters[1,"y"],
                                            length[I[1]],length[I[2]],
                                            value[I[1]],value[I[2]]))
            lines(c(x1,inters[1,"x"]),c(y1,inters[1,"y"]),col="white",lwd=3)
            
          }
          else if(nrow(inters)>1)
          {
            value[1] = fillvalue[i]
            value[2] = fillvalue[i]
            length[1] = sqrt(sum((inters[1,1:2]-linetosect[1,])^2))
            length[2] = sqrt(sum((inters[2,1:2]-linetosect[1,])^2))
            I = order(length)
            lineresult = rbind(lineresult,c(inters[1,"x"],inters[1,"y"],
                                            inters[2,"x"],inters[2,"y"],
                                            length[I[1]],length[I[2]],
                                            value[I[1]],value[I[2]]))
            lines(c(inters[1,"x"],inters[2,"x"]),c(inters[1,"y"],inters[2,"y"]),col="white",lwd=3)
          }
        } 
      }
    }
    for(l in addlines)
    {
      do.call(lines,l)
    }
    for(p in addpoints)
    {
      do.call(points,p)
    }
    for(p in addpolygons)
    {
      do.call(polygon,p)
    }
    
    par(new=TRUE)
    plot(0,0,xlim=c(0,1),ylim=srange,col="white",axes=FALSE,xlab="",ylab="")
    axis(4)
    
    barright = par()$usr[2]
    barleft = barright-0.04*(par()$usr[2]-par()$usr[1])
    barfarleft = barright-0.06*(par()$usr[2]-par()$usr[1])
    barlow = par()$usr[3]+0.0*(par()$usr[4]-par()$usr[3])
    barup = par()$usr[4]-0.0*(par()$usr[4]-par()$usr[3])
    sseq = seq(srange[1],srange[2],length=(Nfc+1))
    polygon(c(barfarleft,barfarleft,barright,barright),
            c(barlow,barup,barup,barlow),border=NA,
            col="white")
    for(i in 1:Nfc)
    {
      polygon(c(barleft,barleft,barright,barright),
              c(sseq[i],sseq[i+1],sseq[i+1],sseq[i]),border=NA,
              col=fc((sseq[i]+sseq[i+1])/2))
    }
    lines(c(barleft,barleft),c(barlow,barup))
    lines(c(barleft,barright),c(sseq[1],sseq[1]))
    lines(c(barleft,barright),c(sseq[Nfc+1],sseq[Nfc+1]))
    mtext(fill.name,4,line=2.5)
    if(Ncvs>0)
    {
      cvcols = c()
      for(i in 1:Ncvs)
      {
        co = contvals[i]
        cvcols[i] = fc(contvals[i],shift=TRUE)
        lines(c(barleft,barright),c(co,co),lwd=3,col="white")
        lines(c(barleft,barright),c(co,co),col=cvcols[i],lwd=2.9)
      }
    }
    for(l in addlines)
    {
      do.call(lines,l)
    }
    for(p in addpoints)
    {
      do.call(points,p)
    }
    for(p in addpolygons)
    {
      do.call(polygon,p)
    }
    
    
    if(nrow(lineresult)>0){
      plot(0,xlim=range(lineresult[,"length1"],lineresult[,"length2"]),
           ylim = range(lineresult[,"value1"],lineresult[,"value2"]),
           main = "line section",
           xlab= "distance",ylab="",col="white")
      mtext(text=paste("(",
                       prettyNum(linetosect[1,1]),",",
                       prettyNum(linetosect[1,2]),")-(",
                       prettyNum(linetosect[2,1]),",",
                       prettyNum(linetosect[2,2]),")"),side=3)
      for(i in 1:nrow(lineresult))
      {
        lines(c(lineresult[i,"length1"],lineresult[i,"length2"]),
              c(lineresult[i,"value1"],lineresult[i,"value2"]),
              lwd=4,col=fc((lineresult[i,"value1"]+lineresult[i,"value2"])/2))
      }
      grid(col="black")
    }
  }
  
  if(fill.3D)
  {
    for3D.x.toplot = c()
    for3D.y.toplot = c()
    for3D.z.toplot = c()
    for3D.col.toplot = c()
    
    Q.x.toplot = c()
    Q.y.toplot = c()
    Q.z.toplot = c()
    Q.col.toplot= c()
    
    do_ci = function(ci)
    {
      for3D.x.toplot<<-c(for3D.x.toplot,model$nodes[ci["ni1"],1])
      for3D.x.toplot<<-c(for3D.x.toplot,ci["x1"])
      for3D.x.toplot<<-c(for3D.x.toplot,ci["x2"])
      for3D.y.toplot<<-c(for3D.y.toplot,model$nodes[ci["ni1"],2])
      for3D.y.toplot<<-c(for3D.y.toplot,ci["y1"])
      for3D.y.toplot<<-c(for3D.y.toplot,ci["y2"])
      for(k in 1:3)
      {
        for3D.z.toplot<<-c(for3D.z.toplot,fillvalue[ci["ni1"]])
        for3D.col.toplot<<-c(for3D.col.toplot,fc(fillvalue[ci["ni1"]]))
      }
      
      
      for3D.x.toplot<<-c(for3D.x.toplot,model$nodes[ci["ni2"],1])
      for3D.x.toplot<<-c(for3D.x.toplot,ci["x1"])
      for3D.x.toplot<<-c(for3D.x.toplot,ci["x2"])
      for3D.y.toplot<<-c(for3D.y.toplot,model$nodes[ci["ni2"],2])
      for3D.y.toplot<<-c(for3D.y.toplot,ci["y1"])
      for3D.y.toplot<<-c(for3D.y.toplot,ci["y2"])
      for(k in 1:3)
      {
        for3D.z.toplot<<-c(for3D.z.toplot,fillvalue[ci["ni2"]])
        for3D.col.toplot<<-c(for3D.col.toplot,fc(fillvalue[ci["ni2"]]))
      }
      
      
      Q.x.toplot <<- c(Q.x.toplot,ci["x1"])
      Q.x.toplot <<- c(Q.x.toplot,ci["x1"])
      Q.x.toplot <<- c(Q.x.toplot,ci["x2"])
      Q.x.toplot <<- c(Q.x.toplot,ci["x2"])
      Q.y.toplot <<- c(Q.y.toplot,ci["y1"])
      Q.y.toplot <<- c(Q.y.toplot,ci["y1"])
      Q.y.toplot <<- c(Q.y.toplot,ci["y2"])
      Q.y.toplot <<- c(Q.y.toplot,ci["y2"])
      
      Q.z.toplot <<- c(Q.z.toplot,fillvalue[ci["ni1"]])
      Q.col.toplot<<-c(Q.col.toplot,fc(fillvalue[ci["ni1"]]))
      Q.z.toplot <<- c(Q.z.toplot,fillvalue[ci["ni2"]])
      Q.col.toplot<<-c(Q.col.toplot,fc(fillvalue[ci["ni2"]]))
      Q.z.toplot <<- c(Q.z.toplot,fillvalue[ci["ni2"]])
      Q.col.toplot<<-c(Q.col.toplot,fc(fillvalue[ci["ni2"]]))
      Q.z.toplot <<-c(Q.z.toplot,fillvalue[ci["ni1"]])
      Q.col.toplot<<-c(Q.col.toplot,fc(fillvalue[ci["ni1"]]))
      return(NULL)
    }
    
    dummy = apply(model$cellinterfaces,1, do_ci)
    
    
    
    for(i in 1:nrow(model$boundarypart))
    {
      bp = model$boundarypart[i,]
      for3D.x.toplot=c(for3D.x.toplot,bp["x1"])
      for3D.y.toplot=c(for3D.y.toplot,bp["y1"])
      for3D.x.toplot=c(for3D.x.toplot,bp["x2"])
      for3D.y.toplot=c(for3D.y.toplot,bp["y2"])
      ni = bp["nid"]
      for3D.x.toplot=c(for3D.x.toplot,model$nodes[ni,1])
      for3D.y.toplot=c(for3D.y.toplot,model$nodes[ni,2])
      for(k in 1:3)
      {
        for3D.z.toplot=c(for3D.z.toplot,fillvalue[ni])
        for3D.col.toplot=c(for3D.col.toplot,fc(fillvalue[ni]))
      }
    }
    
    staterange = range(fillvalue,na.rm=TRUE)
    zaspect = 0.8*model$scale/(staterange[2]-staterange[1])
    
    # rgl.open()
    rgl.viewpoint(-90,50)
    bg3d("white")
    axes3d(col="black")
    aspect3d(x=1,y=zaspect,z=1)
    rgl.triangles(for3D.y.toplot,for3D.z.toplot,for3D.x.toplot,col=for3D.col.toplot,alpha=0.9)
    rgl.quads(Q.y.toplot,Q.z.toplot,Q.x.toplot,col=Q.col.toplot,alpha=0.9)
  }
  
}



plot.GENFE2D = function(model,
                        showdomain = TRUE,
                        shownodes = TRUE,
                        nodenumbersize = 0,
                        fill.colors = NULL,
                        fill.border = NA,
                        fill = "",
                        fill.name = "",
                        main.title = NULL,
                        fill.lim = NULL,
                        fill.contours = c(),
                        fill.3D = FALSE,
                        fill.2D = TRUE,
                        fluxvecsize=0,
                        xlim = NULL,
                        ylim = NULL,
                        linesection="",
                        addlines=list(),
                        addpoints=list(),
                        addpolygons= list())
{
  farg = is.valid(c("s","g","n"),c("*",3,"+"),fill,
                  "fill argument shoulde be a string, a vector or a function of three arguments:(x,y,state)")
  fillvalue = c()
  if(farg==3)
  {
    lengthfill = length(fill)
    if(lengthfill!= model$Numnodes)
    {
      stopmessage = paste(model$Numnodes, "= num nodes is not equal to the length of fill =",lengthfill)
      stop(stopmessage,call.=FALSE)
    }
    fillvalue = fill
  }
  else if(farg==2)
  {
    for(i in 1:model$Numnodes)
    {
      fillvalue[i] = fill(model$nodes[i,1],model$nodes[i,2],model$states[i])
    }
  } else if(farg==1)
  {
    if(fill=="state")
    {
      for(i in 1:model$Numnodes)
      {
        fillvalue[i] = model$states[i]
      }
    } else if(fill=="random")
    {
      fillvalue = runif(model$Numnodes)
    } else
    {
      fillvalue = rep(NA,model$Numnodes)
    }
  }
  
  larg = is.valid(c("s","n"),c("*",4),linesection,
                  "linesection argument should be a string,
                  or a vector of four arguments")
  linetosect = NULL
  linteractive = FALSE
  lineresult = matrix(0,nrow=0,ncol=8)
  colnames(lineresult)=c("x1","y1","x2","y2",
                         "length1","length2","value1","value2")
  if(larg==1){
    if(linesection=="interactive")
    {
      linteractive = TRUE
    }
  } else if(larg==2)
  {
    linetosect = matrix(linesection,ncol=2,byrow=TRUE)
  }
  
  if((length(fill.contours)>0)&&(length(fillvalue)==0))
  {
    stop("can not create contours without fill values",call.=FALSE)
  }
  if((fill.3D)&(length(fillvalue)==0))
  {
    stop("can not create 3D plot without fill values",call.=FALSE)
  }
  
  if(is.null(fill.colors))
  {
    fill.colors= deffillcolors
  }
  Nfc = length(fill.colors)
  if(fill.2D)
  {
    old.par = par(no.readonly=TRUE)
  }
  if(is.null(xlim))
  {
    xrange = range(model$domain[,1])
  } else {
    xrange = sort(xlim);
  }
  xscale = xrange[2]-xrange[1]
  xmin = xrange[1]
  if(is.null(ylim))
  {
    yrange = range(model$domain[,2])
  } else {
    yrange = sort(ylim)
  }
  yscale = yrange[2]-yrange[1]
  ymin = yrange[1]
  
  if(length(fillvalue)>0)
  {
    if(is.null(fill.lim))
    {
      if(sum(is.na(fillvalue))==model$Numnodes)
      {
        srange = c(0,1)
      } else {
        srange = range(fillvalue,na.rm=TRUE)
      }
      if(srange[2]==srange[1])
      {
        srange[1]=srange[1]-1
        srange[2]=srange[2]+1
      }
    } else {
      is.valid("n",2,fill.lim,"fill.lim should be a vector of two numbers")
      srange = range(fill.lim)
    }
  }
  if(is.null(main.title))
  {
    main.title =  model$name
  }
  if(fill.2D)
  {
    par(mar=c(4,4,4,5))
    fc = function(s,shift=FALSE)
    {
      if(is.na(s)) return(fill.colors[1])
      s[s > srange[2]] = srange[2]
      s[s < srange[1]] = srange[1]
      ss = (s-srange[1])/(srange[2]-srange[1])
      if(shift)
      {
        ss = ss+0.25
        if(ss>1) ss=ss-1
      }
      return(fill.colors[1+ss*(Nfc-1)])
    }
    sseq = seq(srange[1],srange[2],length=(Nfc+1))
    Ncvs = 0
    if(length(fill.contours)>0)
    {
      contvals = fill.contours[(fill.contours >= srange[1])&
                                 (fill.contours <= srange[2])]
      Ncvs = length(contvals)
    }
    
    xlim = c(xmin,xmin+1.1*xscale)
    ylim = c(ymin,ymin+yscale)
    plot(x=c(),y=c(),main=main.title,
         xlim=xlim, ylim=ylim,xlab="x",ylab="y")
    
    xs = c("x1","x2","x3")
    ys = c("y1","y2","y3")
    nids = c("nid1","nid2","nid3")
    for(k in 1:model$Numelements)
    {
      el = model$elements[k,]
      x = el[xs]
      y = el[ys]
      s = fillvalue[el[nids]]
      polygon(x,y,border=fill.border,col=fc(mean(s)))
    }
    if(length(fill.contours)>0)
    {
      
      cvcols = c()
      for(i in 1:Ncvs)
      {
        co = contvals[i]
        cvcols[i] = fc(contvals[i],shift=TRUE)
      }
      
      for(k in 1:model$Numelements)
      {
        el = model$elements[k,]
        x = el[xs]
        y = el[ys]
        s = fillvalue[el[nids]]
        
        I = order(s)
        so = s[I]
        for(i in seq(along=contvals))
        {
          co = contvals[i]
          if((so[1]<co)&(co<so[3]))
          {
            if(co<so[2])
            {
              f= (co-so[1])/(so[2]-so[1])
              lx = c(f*x[I[2]]+(1-f)*x[I[1]])
              ly = c(f*y[I[2]]+(1-f)*y[I[1]])
            } else {
              f = (co-so[2])/(so[3]-so[2])
              lx = c(f*x[I[3]]+(1-f)*x[I[2]])
              ly = c(f*y[I[3]]+(1-f)*y[I[2]])
            }
            f = (co-so[1])/(so[3]-so[1])
            lx = c(lx,f*x[I[3]]+(1-f)*x[I[1]])
            ly = c(ly,f*y[I[3]]+(1-f)*y[I[1]])
            lines(lx,ly,lwd=3,col="white")
            lines(lx,ly,lwd=2.9,col=cvcols[i])
          }
        }
      }
    }
    if(showdomain)
    {
      polygon(model$domain,col=rgb(0,0,0,0.07))
    }
    if(shownodes)
    {
      points(model$nodes,pch=20,cex=0.6,col="white")
      points(model$nodes,pch=20,cex=0.4,col="red")
    }
    if(nodenumbersize>0)
    {
      text(model$nodes[,1],model$nodes[,2],labels=1:model$Numnodes,
           pos=3,cex=nodenumbersize,col="blue")
    }
    if(fluxvecsize>0)
    {
      ifl = dataframe.internalfluxes(model)
      mf = 0.03*model$scale/(mean(abs(ifl[,"fluxx"]))+mean(abs(ifl[,"fluxy"])))*
        fluxvecsize
      xs = c("x1","x2","x3")
      ys = c("y1","y2","y3")
      for(i in 1:model$Numelements)
      {
        mx = mean(model$elements[i,xs])
        my = mean(model$elements[i,ys])
        Arrows(mx,my,mx+mf*ifl[i,"fluxx"],my+mf*ifl[i,"fluxy"])
      }
    }
    # redraw color bar
    if(linteractive)
    {
      cat("select two points for linesection by clicking on graph\n")
      sel = locator(n=2)
      linetosect = matrix(c(sel$x,sel$y),nrow=2)
    }
    if(!is.null(linetosect))
    {
      if(nrow(linetosect)>0)
      {
        lines(linetosect[,1],linetosect[,2],lwd=4)
      }
    }
    if(!is.null(linetosect))
    {
      lines(linetosect[,1],linetosect[,2],lwd=4)
      value = c()
      length = c()
      xynames = c("x1","x2","x3","y1","y2","y3")
      for(i in 1:model$Numelements)
      {
        e = model$elements[i,]
        inters = GEO$intersection.poly.segment(
          matrix(model$elements[i,xynames],ncol=2),linetosect)
        if(!is.null(inters))
        {
          if(nrow(inters)==1)
          {
            #either the begin point or the eindpoint of the linetosect falls in the element
            #first test point 1
            x1 = linetosect[1,1]
            y1 = linetosect[1,2]
            p2 = e[["dg11"]]*(x1-e[["x1"]])+
              e[["dg21"]]*(y1-e[["y1"]])
            p3 = e[["dg12"]]*(x1-e[["x1"]])+
              e[["dg22"]]*(y1-e[["y1"]])
            p1 = 1-p2-p3
            length[1]=0
            if(min(p1,p2,p3)<0)
            {
              # was point 2
              x1 = linetosect[2,1]
              y1 = linetosect[2,2]
              p2 = e[["dg11"]]*(x1-e[["x1"]])+
                e[["dg21"]]*(y1-e[["y1"]])
              p3 = e[["dg12"]]*(x1-e[["x1"]])+
                e[["dg22"]]*(y1-e[["y1"]])
              p1 = 1-p2-p3
              length[1] = sqrt(sum((linetosect[2,]-linetosect[1,])^2))
            }
            value[1] = p1*fillvalue[e[["nid1"]]]+
              p2*fillvalue[e[["nid2"]]]+
              p3*fillvalue[e[["nid3"]]]
            p2 = e[["dg11"]]*(inters[1,"x"]-e[["x1"]])+
              e[["dg21"]]*(inters[1,"y"]-e[["y1"]])
            p3 = e[["dg12"]]*(inters[1,"x"]-e[["x1"]])+
              e[["dg22"]]*(inters[1,"y"]-e[["y1"]])
            p1 = 1-p2-p3
            value[2] = p1*fillvalue[e[["nid1"]]]+
              p2*fillvalue[e[["nid2"]]]+
              p3*fillvalue[e[["nid3"]]]
            length[2] = sqrt(sum((inters[1,1:2]-linetosect[1,])^2))
            I = order(length)
            lines(inters[,"x"],inters[,"y"],col="white",lwd=2)
            lineresult = rbind(lineresult,c(x1,y1,
                                            inters[1,"x"],inters[1,"y"],
                                            length[I[1]],length[I[2]],
                                            value[I[1]],value[I[2]]))
          }
          else if(nrow(inters)>1)
          {
            p2 = e[["dg11"]]*(inters[1,"x"]-e[["x1"]])+
              e[["dg21"]]*(inters[1,"y"]-e[["y1"]])
            p3 = e[["dg12"]]*(inters[1,"x"]-e[["x1"]])+
              e[["dg22"]]*(inters[1,"y"]-e[["y1"]])
            p1 = 1-p2-p3
            value[1] = p1*fillvalue[e[["nid1"]]]+
              p2*fillvalue[e[["nid2"]]]+
              p3*fillvalue[e[["nid3"]]]
            p2 = e[["dg11"]]*(inters[2,"x"]-e[["x1"]])+
              e[["dg21"]]*(inters[2,"y"]-e[["y1"]])
            p3 = e[["dg12"]]*(inters[2,"x"]-e[["x1"]])+
              e[["dg22"]]*(inters[2,"y"]-e[["y1"]])
            p1 = 1-p2-p3
            value[2] = p1*fillvalue[e[["nid1"]]]+
              p2*fillvalue[e[["nid2"]]]+
              p3*fillvalue[e[["nid3"]]]
            length[1] = sqrt(sum((inters[1,1:2]-linetosect[1,])^2))
            length[2] = sqrt(sum((inters[2,1:2]-linetosect[1,])^2))
            I = order(length)
            lines(inters[,"x"],inters[,"y"],col="white",lwd=2)
            lineresult = rbind(lineresult,c(inters[1,"x"],inters[1,"y"],
                                            inters[2,"x"],inters[2,"y"],
                                            length[I[1]],length[I[2]],
                                            value[I[1]],value[I[2]]))
          }
        }
      }
    }
    for(l in addlines)
    {
      do.call(lines,l)
    }
    for(p in addpoints)
    {
      do.call(points,p)
    }
    for(p in addpolygons)
    {
      do.call(polygon,p)
    }
    par(new=TRUE)
    plot(0,0,xlim=c(0,1),ylim=srange,col="white",axes=FALSE,xlab="",ylab="")
    axis(4)
    
    barright = par()$usr[2]
    barleft = barright-0.04*(par()$usr[2]-par()$usr[1])
    barfarleft = barright-0.06*(par()$usr[2]-par()$usr[1])
    barlow = par()$usr[3]+0.0*(par()$usr[4]-par()$usr[3])
    barup = par()$usr[4]-0.0*(par()$usr[4]-par()$usr[3])
    sseq = seq(srange[1],srange[2],length=(Nfc+1))
    polygon(c(barfarleft,barfarleft,barright,barright),
            c(barlow,barup,barup,barlow),border=NA,
            col="white")
    for(i in 1:Nfc)
    {
      polygon(c(barleft,barleft,barright,barright),
              c(sseq[i],sseq[i+1],sseq[i+1],sseq[i]),border=NA,
              col=fc((sseq[i]+sseq[i+1])/2))
    }
    lines(c(barleft,barleft),c(barlow,barup))
    lines(c(barleft,barright),c(sseq[1],sseq[1]))
    lines(c(barleft,barright),c(sseq[Nfc+1],sseq[Nfc+1]))
    mtext(fill.name,4,line=2.5)
    if(Ncvs>0)
    {
      cvcols = c()
      for(i in 1:Ncvs)
      {
        co = contvals[i]
        cvcols[i] = fc(contvals[i],shift=TRUE)
        lines(c(barleft,barright),c(co,co),lwd=3,col="white")
        lines(c(barleft,barright),c(co,co),col=cvcols[i],lwd=2.9)
      }
    }
    for(l in addlines)
    {
      do.call(lines,l)
    }
    for(p in addpoints)
    {
      do.call(points,p)
    }
    for(p in addpolygons)
    {
      do.call(polygon,p)
    }
    if(nrow(lineresult)>0)
    {
      plot(0,xlim=range(lineresult[,"length1"],lineresult[,"length2"]),
           ylim = range(lineresult[,"value1"],lineresult[,"value2"]),
           main = "line section",
           xlab= "distance",ylab="",col="white")
      mtext(text=paste("(",
                       prettyNum(linetosect[1,1]),",",
                       prettyNum(linetosect[1,2]),")-(",
                       prettyNum(linetosect[2,1]),",",
                       prettyNum(linetosect[2,2]),")"),side=3)
      for(i in 1:nrow(lineresult))
      {
        lines(c(lineresult[i,"length1"],lineresult[i,"length2"]),
              c(lineresult[i,"value1"],lineresult[i,"value2"]),
              lwd=4,col=fc((lineresult[i,"value1"]+lineresult[i,"value2"])/2))
      }
      grid(col="black")
    }
  }
  if(fill.3D)
  {
    for3D.x.toplot = c()
    for3D.y.toplot = c()
    for3D.z.toplot = c()
    for3D.col.toplot = c()
    for(k in 1:model$Numelements)
    {
      el = model$elements[k,]
      x = el[xs]
      y = el[ys]
      s = fillvalue[el[nids]]
      
      for3D.x.toplot=c(for3D.x.toplot,x)
      for3D.y.toplot=c(for3D.y.toplot,y)
      for3D.z.toplot=c(for3D.z.toplot,s)
      for3D.col.toplot=c(for3D.col.toplot,c(fc(s[1]),fc(s[2]),fc(s[3])))
    }
    #rgl.open()
    rgl.viewpoint(-90,50)
    bg3d("white")
    axes3d(col="black")
    staterange = range(model$states)
    zaspect = 0.8*model$scale/(staterange[2]-staterange[1])
    aspect3d(x=1,y=zaspect,z=1)
    rgl.triangles(for3D.y.toplot,for3D.z.toplot,for3D.x.toplot,col=for3D.col.toplot,alpha=0.9)
  }
  
}


#' @export plot.FElinear2D
plot.FElinear2D = plot.GENFE2D

#' @export plot.FEquadratic2D
plot.FEquadratic2D = plot.GENFE2D

#' @export plot.FEcubic2D
plot.FEcubic2D = plot.GENFE2D

#' @export plot.FEquartic2D
plot.FEquartic2D = plot.GENFE2D
