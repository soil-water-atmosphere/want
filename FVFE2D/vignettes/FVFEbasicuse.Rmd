
---
title: "Basic 2D Example"
author: Paul Torfs
date: Jan 29 2015
output: slidy_presentation
footer: Introduction to FVFE2D
---

# How to use this:

The following shortcut keys can be used:

- **space**, **page down**: next slide
- **C**: show table of contents
- **F**: toggles the display of the footer
- **A**: toggles display of current vs all slides (useful for printing handouts)
- **S**: make fonts smaller
- **B**: make fonts larger

# Starting up

The following two lines of code clears the working space and loads the library
```{r}
rm(list=ls())
library(FVFE2D)
```

Loading the library loads some other libraries:

- The Matrix library for use of sparse matrices
- The rlg library for making 3D plots
- The deldir library for constructing Voronoi cells and Delauney triangles

# Creating a domain

The first step consists in chosing the spatial model domain. 

The following code lines construct a domain, and prints it.
```{r}
domain = matrix(c(50,0,100,60,80,100,30,80,20,30),ncol=2,byrow=TRUE)
print(domain)
```


- The first column gives the x-coordinates of the domain

- The second column the y-coordinates


# A first plot of the domain

```{r}
plot(domain,xlab="x",ylab="y")
grid(col="black")
polygon(domain,col=rgb(0.5,0.9,0.9,0.2))
```

# Specifying an internal flux 

The physics of the internal flux should be implemented in 
the  internal flux definition. 


In the example below the internal flux is given by a flux opposite to the gradient:

```{r}
internal.flux = function(x,y,state,gradstate)  
{
  return(-10*gradstate)
}
```

The user should define but normally not call this function.

This function is called by the model whenever the model needs to calculate an internal flux:

- at positision x,y
- with a by the model provided value for the state (at x,y)
- with a by the model provided value for the gradient of the state gradstate
- all this arguments may be used inside the flux calculations

# Construction the model

With the help of a domain and internal flux function a 2D flow model can be constructed:


```{r}
model = newFLOW2D(domain,internal.flux,name="Basic 2D example") 
```

- the variable name   
(in this case **model**, but the user may choose another name)
will be used in all other calls that follow  
- the third argument is used for printing and plotting 

# Adding external fluxes

The are three types of external fluxes:

- a spatial external flux; the following line adds a constant spatial flux

```{r}
add.spatialflux(model,0.01,name="S")
```

- a line flux; the following line adds a constant line extraction

```{r}
line = matrix(c(40,40,80,80),ncol=2,byrow=TRUE)
add.lineflux(model,line,values=list(-2),name="L")
```

- a point flux: 
```{r}
add.pointflux(model,c(50,20),-100)
```


All three forms have more variation in the interface than shown above. The following gives an example:
```{r}
Sx = function(x,y,state){return(0.001+x/20000)}
add.spatialflux(model,Sx,name="S2")
```

Please consult the help for other possibilities in this.


# Adding boundary conditions

```{r ,fig.width=6, fig.height=5}
plot.BC.id(model)
set.BC.fixedstate(model,"NE",1) 
set.BC.fixedstate(model,5,2)
```

# Making the model discrete

The following line makes the model discrete:
```{r, message=FALSE}
set.discretisation(model,nodes=list(type="geomgen",optdist=5,verbose=FALSE),method="FE")
```

This is done by 
- placing a finite number of nodes in the domain   
There are more techniques than the one above implemented in FVFE2D
- chosing for the Finite Element technique as discretisation scheme   
Another choice would be FV (Finite Volume)

A plot of the nodes and elements:
```{r,fig.width=5,fig.height=4}
plot(model,fill.border="black")
```


# Solving

The resulting discrete equations are solved iteratively by:
```{r}
control = solve.steps(model)
```
More arguments can be added to control the solution procedure.


The variable control contains information for the remaining misfits of the cell wise balances:
```{r}
control
```
- RMSM = root mean square misfit
- MAM  = maximum absolute misfit

# Plotting result

```{r}
plot(model,fill="state",fill.contours=seq(-3,2,length=5))
```

# Post processing

