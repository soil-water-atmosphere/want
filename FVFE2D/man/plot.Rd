\name{plot for FVFE2D}
\alias{plot for FVFE2D}
\title{Plots states and/or internal fluxes as calculated by the
current state of the model}
\usage{
  plot(model, showdomain = TRUE, shownodes = TRUE,
      nodenumbersize = 0, 
      fill = "", fill.colors = NULL, fill.lim = NULL, 
      fill.border = NA, fill.contours = c(), 
      fill.name = "", main.title = NULL,
      fill.3D = FALSE, 
      fluxvecsize = 0,
      linesection="",
      addpoints=list(),
      addlines=list(),
      addpolygons=list())
}
\arguments{
  \item{model}{a two dimensional flow model of the class
  \code{[A]FElinear2D}, \code{[A]FEquadratic2D},
  \code{[A]FEcubic2D}, \code{[A]FEquartic2D} (as generated by
  \code{set.discretisation})}

  \item{showdomain}{TRUE/FALSE (default TRUE) for showing
  the domain in the plot}

  \item{shownodes}{TRUE/FALSE (default TRUE) for showing
  the position of the nodes in the plot}

  \item{nodenumbersize}{(default=0) size of the nodenumbers
  in the plot}

 \item{fill}{\itemize{ \item if \code{fill=""} (the
  default) no fill plot will be made \item if
  \code{fill="state"} a fill plot with the current state
  values will be made \item if \code{fill="random"} random
  values will be used \item if the value of \code{fill} is
  a vector, the values of this vector (in the order of the
  nodes, so the vector should have the length of the number
  of nodes in the model) will be used for fill values \item
  the value of \code{fill} can also be a function of three
  coordinates: \code{function(x,y,s)}. The values used for
  the fill will then be calculated for each node by using
  the coordinates of that node and the current state value
  in that node as arguments. }}

  \item{fill.colors}{is a vector of colors to be used in
  the filling. If \code{NULL} a default vector will be
  used.  See \code{help(colors)} for other choices.}
  
  \item{fill.lim}{if not NULL  a vector of two numbers 
  that form the limits between the colors are distributed.}

  \item{fill.border}{the color of the border of the
  cells (FV) or triangles (FE); 
  if NA (=default) no borders will be plotted}
  
  \item{fill.contours}{a vector of values for which contour
  lines (in the FV cases: on the borders of the cells, in
  the FE cases: linearly interpolated inside the triangles)
  will be drawn}

  \item{fill.name}{the string to be plotted along the color
  scale bar on the right}
  
  \item{main.title}{the string to be used as main title of 
  the plot. If NULL (=default) the name of the model will be 
  used}
  
  \item{fill.3D}{a 3D plot by rgl is made with colors
  corresponding to the 2D fill plot; the plot can be
  changed by the mouse}

  \item{fluxvecsize}{if larger then 0 (= the default)
  vectors indicating the size and directions within each
  triangle (at the midpoint) will be drawn; the value of
  this parameter will be used as a multiplication factor
  the vector size}
  \item{linesection}{produces a plot along a line of 
  the current \code{fill}
  \itemize{
  \item if equal to \code{""} (default) no line plot
  will be made
  \item if equal to a vector of four elements \code{x1,y1,x2,y2}
  a plot of the values along the line connecting the point
  \code{x1,y1} with the point \code{x2,y2} will be made
  \item if equal to the string \code{"interactive"} the user will 
  be requested to click twice on a two dimensional plot to identify
  begin point and end point of the line to be used for a 
  line section plot.
  }
  }
  \item{addpoints}{a list of points to add to the plot.
  Each element of addpoints is a list of arguments as usually passed to
  the \code{points} function.}
  \item{addlines}{a list of lines to add to the plot.
  Each element of addlines is a list of arguments as usually passed to
  the \code{lines} function.}
  \item{addpolygons}{a list of polygons to add to the plot.
  Each element of addpolygons is a list of arguments as usually passed to
  the \code{polygon} function.}
}
\description{
Plots states and/or internal fluxes as calculated by the
current state of the model
}
\examples{
invgradflux = function(x,y,s,grads) { return(-grads)}
domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
add.spatialflux(M,0.1)
set.BC.fixedstate(M,"NE",2)
set.BC.fixedstate(M,"SW",1)
set.discretisation(M,nodes=list(type="geomgen",optdist=1.5),method="FE")
plot(M,fill="random",nodenumbersize=0.3)
line1 = list(x=c(4,4),y=c(2,8),col="white",lwd=3)
line2 = list(x=c(1,6),y=c(4,4),col="black",lwd=3)
point1 = list(x=5,y=6,col="white",pch=20,cex=3)
point2 = list(x=3,y=3,col="black",pch=5)
polygon1 = list(x=c(3.1,3.5,4.2),y=c(4.5,5.8,5.1),col="blue")
plot(M,fill="random",addlines=list(line1,line2),addpoints=list(point1,point2),addpolygons = list(polygon1))
control=solve.steps(M)
plot(M,fill="state",fill.contours=seq(1,3,length=20),fluxvecsize=2)
foo = function(x,y,s){return(s-0.1*y)}
plot(M,fill=foo)
f2 =exp(-dataframe.states(M)$state)
plot(M,fill=f2,addlines=list(line1),addpoints=list(point1))
}

