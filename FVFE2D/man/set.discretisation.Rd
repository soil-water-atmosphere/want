% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FVFE2D.R
\name{set.discretisation}
\alias{set.discretisation}
\title{Set a discretisation of a two dimensional flow problem}
\usage{
set.discretisation(model, nodes, method)
}
\arguments{
\item{model}{a two dimensional flow model of the class \code{[A]FLOW2D} (as generated by
\code{newFLOW2D} or \code{newAFLOW2D}) or \code{[A]FElinear2D},
\code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
\code{[A]FEquartic2D} or \code{FV2D} (as generated by \code{set.discretisation})}

\item{nodes}{Either a matrix  or a list specifying the way by which the nodes are generated. The fist entry
should be called type and has as value a string identifying the method by which the
nodes are generated. Choices are:
\itemize{
\item In the simpliest case a matrix with two columns, giving the x and
y coordinates respectively of the nodes. Such a matrix can for instance
come from another model or from file.
\item \code{nodes=list(type="rectregular",dx= ,dy= )} \cr
Generates a rectangular regulare grid. \cr
The entries \code{dx} and \code{dy} should be numbers that give
the distance of gridlines in the x and y direction respectively.
\item \code{nodes=list(type="rectgeneral", x= , y=)}\cr
Generates a rectangular grid with gridlines with varying distances.\cr
\code{x} and \code{y} should be vectors containing respectively the x-coordinates
for the vertical gridlines and the y-coordinates for the horizontal gridlines
\item  \code{nodes=list(type="hexagonal",side= )}\cr
Generates a hexagonal grid with a the value of \code{side} as distance between the nodes
\item  \code{nodes=list(type="randgen",minist= )}\cr
Generates points in the domain by a random process, but does not use points
closer (with a distance controlled by the ytoxratio, see below)
than \code{mindist} to points already constructed.
As this method uses random points, the value
of the ranomd seed (see help on \code{set.seed}) may influence the result.\cr
\code{mindist} can be either a number or a function of two
arguments returning the minist at the x-y place given by the arguments.
Such functions can be e.g. generated by \code{func.dist.to.point},
\code{func.dist.to.line} and \code{func.dist.to.poly}. \cr
The list may contain the following optional arguments:\cr
\itemize{
\item  \code{maxfails} (default set to 30): if the node generator generates more than
maxfails number of rejected random points from a given node, that node is decleared inactive \cr
\item  \code{startnodes} (default empty) a matrix with two columns (for the x and y coordinates respectively)
giving points that are included to the nodes before the random points are added\cr
\item \code{verbose} (default \code{FALSE}), if \code{TRUE} shows graphically the progress
of the node generation
\item \code{sleeptime} (default \code{0}), if \code{verbose} is \code{TRUE}, plots showing intermediate
steps are shown; if this goes to fast for the screen updating, a positive number for
(e.g. 0.1) generates some extrea time needed for screen updating.
\item \code{ytoxratio} (default=1) gives the ratio between the x and y direction e.g for the
calculation of distances:
           d((x0,y0),(x1,y1)) = sqrt((x0-x1)^2+ytoxratio^2*(y0-y1)^2)
}
\item  \code{nodes=list(type="geomgen", optdist=)}\cr
Generates points in the domain by a geometrical method which iteratively
creates new points, removes bad points and moves points to better positions
in an attempt to optimally position nodes with a distance
(with a distance controlled by the ytoxratio, see below) to each other
given by \code{optdist}.\cr
\code{optdist} can be either a number or a function of two
arguments returning the optimal distance at the x-y place given by the arguments.
Such functions can be e.g. generated by \code{func.dist.to.point},
\code{func.dist.to.line} and \code{func.dist.to.poly}. \cr
The list may contain the following optional arguments:\cr
\itemize{
\item \code{startnodes}  (default empty) a matrix with two columns (for the x and y coordinates respectively)
giving points that are included to the nodes before the random points are adde\cr
\item \code{maxiter} the maximum number of iterations after which the node generation stops
anyway (default set to 20)\cr
\item \code{stopcrit} the node generation calculates a criterion that measures how
far the nodes generated are form an optimal position, the smaller this number the
better the nodes are positioned (default set to 0.005),\cr
For an insight into values of  criterion in a particular case, the field \code{verbose=TRUE}
may be set.  \cr
\item \code{movefactor} Nodes can be moved inside the domain in an attempt to approach the optimal
distance better. During any iteration step this is a constant. From iteration to iteration
this constant can change. Default this constant is calculated by \cr
\code{function(iter){if(iter<5) return(0) else return(1.0)}}\cr
A larger number generates larger moves.
A too large \code{movefactor} may generate instability: points kicked out of the domain
too fast. The value is  by defualt set to \code{1.25}.
If another value or function (see also examples for other factors) is needed
(generated for instance by inspection of the process
setting \code{verbose=TRUE}), a new function may be assigned to the \code{movefactor}
entry in the list.\cr
\item \code{createfactor} New nodes can be created inside the domain in an attempt to approach the optimal
distance better. During any iteration this rate of creation is a constant.
From iteration to iteration this constant can change.
Default this constant is set to
\code{function(iter){if(iter<3) return(5) return(10)}}\cr
The larger the returned value, the less nodes are created.\cr
If another function is needed (generated for instance by inspection of the process
setting \code{verbose=TRUE}), a new function may be assigned to the \code{createfactor}
entry in the list.\cr
\item  \code{removefactor} Nodes can be removed in an attempt to approach the optimal
distance better. During any iteration this rate of removal  is a constant.
From iteration to iteration this constant can change.
Default this constant is calculated by \cr
\code{function(iter){if(iter<3) return(0)return(0.01)}}\cr
The larger the returned value, the less nodes are removed.\cr
If another function is needed (generated for instance by inspection of the process
setting \code{verbose=TRUE}), a new function may be assigned to the \code{createfactor}
entry in the list.\cr
\item \code{verbose} if \code{TRUE} (default is set to \code{FALSE}) shows graphically the progress
of the node generation. In this plot blue-ish cirlces give an indication of optimal distances,
new created nodes are marked green, removed nodes are marked yellow and the moves of points
are show by arrows. The iteration number and criterion value (which may be used to stop the
node generation) are given in the title. The subtitle gives the current values of the movefactor
(m), createfactor (c) and removefactor (r).
\item \code{sleeptime} (default \code{0}), if \code{verbose} is \code{TRUE}, plots showing intermediate
steps are shown; if this goes to fast for the screen updating, a positive number for
(e.g. 0.1) generates some extrea time needed for screen updating.
\item \code{ytoxratio} (default=1) gives the ratio between the x and y direction e.g for the
calculation of distances:
           d((x0,y0),(x1,y1)) = sqrt((x0-x1)^2+ytoxratio^2*(y0-y1)^2)
So if in the domain the range of y values  is f times smaller than the range of x values on can set
ytoxratio = f to compensate the distributions of the nodes for this.
}
}}

\item{method}{A string, giving the choice of discretisation method, the following choices are implemented:
"FE" for the Finite Element technique (is actually equal to "FElinear"),
"FElinear" (integration done by just taking the midpoint),
"FEquadratic" (i.e. FE with a intergration technique based on
three points),"FEcubic" (intergration based on four points),
"FEquartic" (integration based on 6 points), "FV" for the Finite Volume technique.}
}
\value{
a two dimensional flow model according to the method chosen:
\code{[A]FElinear2D}, \code{[A]FEquadratic2D}, \code{[A]FEcubic2D},
\code{[A]FEquartic2D} or \code{FV2D}
}
\description{
Set discretisation nodes and discretisation method for
a two dimensional flow problem
}
\examples{
 invgradflux = function(x,y,s,grads) { return(-grads)}
domain = matrix(c(1,2,6,1,9,7,4,9),ncol=2,byrow=TRUE)
M = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
set.discretisation(M,nodes=list(type="rectregular",dx=1,dy=0.5),method="FV")
plot(M,fill="random")
set.discretisation(M,nodes=list(type="rectgeneral",x=seq(0,10,length=10),
                                y=seq(0,sqrt(10),length=20)^2),method="FE")
plot(M,fill="random")
set.discretisation(M,nodes=list(type="hexagonal",side=1),method="FV")
plot(M,fill="random")
set.discretisation(M,nodes=list(type="randgen",mindist=1),method="FE")
plot(M,fill="random")
fd = func.dist.to.point(c(5,5),width=2,atvalue=0.1,farvalue=1)
set.discretisation(M,nodes=list(type="geomgen",optdist=fd,verbose=TRUE),
                   method="FV")
plot(M,fill="random")
Mnodes = dataframe.nodes(M)
M2 = newFLOW2D(domain=domain,systemfluxfunction=invgradflux,name="example")
set.discretisation(M2,as.matrix(Mnodes),method="FE")
plot(M2,fill="random")
}
